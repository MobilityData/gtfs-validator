// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: csvspec.proto

package org.mobilitydata.gtfsvalidator.protos;

public final class GtfsSpecificationProto {
  private GtfsSpecificationProto() {
  }

  public static void registerAllExtensions(
          com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
          com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
            (com.google.protobuf.ExtensionRegistryLite) registry);
  }

  public interface ColumnInputTypeOrBuilder extends
          // @@protoc_insertion_point(interface_extends:csvspec.ColumnInputType)
          com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Wrapping the type in a message like this is just for exporting the enum to
     * other proto files.
     * </pre>
     *
     * <code>required .csvspec.ColumnInputType.InputType type = 1;</code>
     */
    boolean hasType();

    /**
     * <pre>
     * Wrapping the type in a message like this is just for exporting the enum to
     * other proto files.
     * </pre>
     *
     * <code>required .csvspec.ColumnInputType.InputType type = 1;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.InputType getType();
  }
  /**
   * <pre>
   * A CsvSpecProto specifies what an input csv is expected to look like. It
   * allows for some configuring of the csv such as renaming of columns, grouping
   * columns into keys, and defining column types.
   * This file can be consumed by a GTFS schema generator by which CsvSpecProto
   * and some of its contained elements are turned into class structures and
   * accessors. Some elements (i.e. NamedValueProto) were especially added to
   * support the generator with some additional input.
   * A CsvErrorProto describes how an input csv fails to meet some requirements.
   * //////////////////////////////////////////////////////////////////////////////
   * </pre>
   *
   * Protobuf type {@code csvspec.ColumnInputType}
   */
  public static final class ColumnInputType extends
          com.google.protobuf.GeneratedMessageV3 implements
          // @@protoc_insertion_point(message_implements:csvspec.ColumnInputType)
          ColumnInputTypeOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use ColumnInputType.newBuilder() to construct.
    private ColumnInputType(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ColumnInputType() {
      type_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
            UnusedPrivateParameter unused) {
      return new ColumnInputType();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }

    private ColumnInputType(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
              com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              int rawValue = input.readEnum();
              @SuppressWarnings("deprecation")
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.InputType value = org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.InputType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(1, rawValue);
              } else {
                bitField0_ |= 0x00000001;
                type_ = rawValue;
              }
              break;
            }
            default: {
              if (!parseUnknownField(
                      input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
                e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor
    getDescriptor() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnInputType_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
    internalGetFieldAccessorTable() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnInputType_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.Builder.class);
    }

    /**
     * <pre>
     * See: https://gtfs.org/reference/static#field-types
     * </pre>
     * <p>
     * Protobuf enum {@code csvspec.ColumnInputType.InputType}
     */
    public enum InputType
            implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>INPUT_TYPE_UNSPECIFIED = 0;</code>
       */
      INPUT_TYPE_UNSPECIFIED(0),
      /**
       * <pre>
       * This is the default type, it does not need to be specified.
       * </pre>
       *
       * <code>TEXT = 1;</code>
       */
      TEXT(1),
      /**
       * <pre>
       * A color encoded as a six-digit hexadecimal number
       * </pre>
       *
       * <code>COLOR = 2;</code>
       */
      COLOR(2),
      /**
       * <code>FLOAT = 3;</code>
       */
      FLOAT(3),
      /**
       * <pre>
       * Service day in the YYYYMMDD format
       * </pre>
       *
       * <code>DATE = 4;</code>
       */
      DATE(4),
      /**
       * <pre>
       * Time in the HH:MM:SS format (H:MM:SS is also accepted).
       * measured from "noon minus 12h" of the service day
       * </pre>
       *
       * <code>TIME = 5;</code>
       */
      TIME(5),
      /**
       * <pre>
       * An ISO 4217 alphabetical currency code
       * </pre>
       *
       * <code>CURRENCY_CODE = 6;</code>
       */
      CURRENCY_CODE(6),
      /**
       * <code>EMAIL = 7;</code>
       */
      EMAIL(7),
      /**
       * <code>ENUM = 8;</code>
       */
      ENUM(8),
      /**
       * <code>ID = 9;</code>
       */
      ID(9),
      /**
       * <pre>
       * An IETF BCP 47 language code
       * </pre>
       *
       * <code>LANGUAGE_CODE = 10;</code>
       */
      LANGUAGE_CODE(10),
      /**
       * <pre>
       * WGS84 latitude in decimal degrees
       * </pre>
       *
       * <code>LATITUDE = 11;</code>
       */
      LATITUDE(11),
      /**
       * <pre>
       * WGS84 longitude in decimal degrees
       * </pre>
       *
       * <code>LONGITUDE = 12;</code>
       */
      LONGITUDE(12),
      /**
       * <code>INTEGER = 13;</code>
       */
      INTEGER(13),
      /**
       * <code>PHONE_NUMBER = 14;</code>
       */
      PHONE_NUMBER(14),
      /**
       * <pre>
       * TZ timezone from the https://www.iana.org/time-zones
       * </pre>
       *
       * <code>TIMEZONE = 15;</code>
       */
      TIMEZONE(15),
      /**
       * <pre>
       * https or https with special characters escaped
       * </pre>
       *
       * <code>URL = 16;</code>
       */
      URL(16),
      ;

      /**
       * <code>INPUT_TYPE_UNSPECIFIED = 0;</code>
       */
      public static final int INPUT_TYPE_UNSPECIFIED_VALUE = 0;
      /**
       * <pre>
       * This is the default type, it does not need to be specified.
       * </pre>
       *
       * <code>TEXT = 1;</code>
       */
      public static final int TEXT_VALUE = 1;
      /**
       * <pre>
       * A color encoded as a six-digit hexadecimal number
       * </pre>
       *
       * <code>COLOR = 2;</code>
       */
      public static final int COLOR_VALUE = 2;
      /**
       * <code>FLOAT = 3;</code>
       */
      public static final int FLOAT_VALUE = 3;
      /**
       * <pre>
       * Service day in the YYYYMMDD format
       * </pre>
       *
       * <code>DATE = 4;</code>
       */
      public static final int DATE_VALUE = 4;
      /**
       * <pre>
       * Time in the HH:MM:SS format (H:MM:SS is also accepted).
       * measured from "noon minus 12h" of the service day
       * </pre>
       *
       * <code>TIME = 5;</code>
       */
      public static final int TIME_VALUE = 5;
      /**
       * <pre>
       * An ISO 4217 alphabetical currency code
       * </pre>
       *
       * <code>CURRENCY_CODE = 6;</code>
       */
      public static final int CURRENCY_CODE_VALUE = 6;
      /**
       * <code>EMAIL = 7;</code>
       */
      public static final int EMAIL_VALUE = 7;
      /**
       * <code>ENUM = 8;</code>
       */
      public static final int ENUM_VALUE = 8;
      /**
       * <code>ID = 9;</code>
       */
      public static final int ID_VALUE = 9;
      /**
       * <pre>
       * An IETF BCP 47 language code
       * </pre>
       *
       * <code>LANGUAGE_CODE = 10;</code>
       */
      public static final int LANGUAGE_CODE_VALUE = 10;
      /**
       * <pre>
       * WGS84 latitude in decimal degrees
       * </pre>
       *
       * <code>LATITUDE = 11;</code>
       */
      public static final int LATITUDE_VALUE = 11;
      /**
       * <pre>
       * WGS84 longitude in decimal degrees
       * </pre>
       *
       * <code>LONGITUDE = 12;</code>
       */
      public static final int LONGITUDE_VALUE = 12;
      /**
       * <code>INTEGER = 13;</code>
       */
      public static final int INTEGER_VALUE = 13;
      /**
       * <code>PHONE_NUMBER = 14;</code>
       */
      public static final int PHONE_NUMBER_VALUE = 14;
      /**
       * <pre>
       * TZ timezone from the https://www.iana.org/time-zones
       * </pre>
       *
       * <code>TIMEZONE = 15;</code>
       */
      public static final int TIMEZONE_VALUE = 15;
      /**
       * <pre>
       * https or https with special characters escaped
       * </pre>
       *
       * <code>URL = 16;</code>
       */
      public static final int URL_VALUE = 16;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static InputType valueOf(int value) {
        return forNumber(value);
      }

      public static InputType forNumber(int value) {
        switch (value) {
          case 0:
            return INPUT_TYPE_UNSPECIFIED;
          case 1:
            return TEXT;
          case 2:
            return COLOR;
          case 3:
            return FLOAT;
          case 4:
            return DATE;
          case 5:
            return TIME;
          case 6:
            return CURRENCY_CODE;
          case 7:
            return EMAIL;
          case 8:
            return ENUM;
          case 9:
            return ID;
          case 10:
            return LANGUAGE_CODE;
          case 11:
            return LATITUDE;
          case 12:
            return LONGITUDE;
          case 13:
            return INTEGER;
          case 14:
            return PHONE_NUMBER;
          case 15:
            return TIMEZONE;
          case 16:
            return URL;
          default:
            return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<InputType>
      internalGetValueMap() {
        return internalValueMap;
      }

      private static final com.google.protobuf.Internal.EnumLiteMap<
              InputType> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<InputType>() {
                public InputType findValueByNumber(int number) {
                  return InputType.forNumber(number);
                }
              };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.getDescriptor().getEnumTypes().get(0);
      }

      private static final InputType[] VALUES = values();

      public static InputType valueOf(
              com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
                  "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private InputType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:csvspec.ColumnInputType.InputType)
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;

    /**
     * <pre>
     * Wrapping the type in a message like this is just for exporting the enum to
     * other proto files.
     * </pre>
     *
     * <code>required .csvspec.ColumnInputType.InputType type = 1;</code>
     */
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Wrapping the type in a message like this is just for exporting the enum to
     * other proto files.
     * </pre>
     *
     * <code>required .csvspec.ColumnInputType.InputType type = 1;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.InputType getType() {
      @SuppressWarnings("deprecation")
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.InputType result = org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.InputType.valueOf(type_);
      return result == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.InputType.INPUT_TYPE_UNSPECIFIED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasType()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, type_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType)) {
        return super.equals(obj);
      }
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType other = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (type_ != other.type_) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
              ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     * <pre>
     * A CsvSpecProto specifies what an input csv is expected to look like. It
     * allows for some configuring of the csv such as renaming of columns, grouping
     * columns into keys, and defining column types.
     * This file can be consumed by a GTFS schema generator by which CsvSpecProto
     * and some of its contained elements are turned into class structures and
     * accessors. Some elements (i.e. NamedValueProto) were especially added to
     * support the generator with some additional input.
     * A CsvErrorProto describes how an input csv fails to meet some requirements.
     * //////////////////////////////////////////////////////////////////////////////
     * </pre>
     * <p>
     * Protobuf type {@code csvspec.ColumnInputType}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:csvspec.ColumnInputType)
            org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputTypeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnInputType_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnInputType_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.Builder.class);
      }

      // Construct using org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
              com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
      getDescriptorForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnInputType_descriptor;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType getDefaultInstanceForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.getDefaultInstance();
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType build() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType buildPartial() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType result = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(
              com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(
              com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType) {
          return mergeFrom((org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType other) {
        if (other == org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.getDefaultInstance())
          return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasType()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private int type_ = 0;

      /**
       * <pre>
       * Wrapping the type in a message like this is just for exporting the enum to
       * other proto files.
       * </pre>
       *
       * <code>required .csvspec.ColumnInputType.InputType type = 1;</code>
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }

      /**
       * <pre>
       * Wrapping the type in a message like this is just for exporting the enum to
       * other proto files.
       * </pre>
       *
       * <code>required .csvspec.ColumnInputType.InputType type = 1;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.InputType getType() {
        @SuppressWarnings("deprecation")
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.InputType result = org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.InputType.valueOf(type_);
        return result == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.InputType.INPUT_TYPE_UNSPECIFIED : result;
      }

      /**
       * <pre>
       * Wrapping the type in a message like this is just for exporting the enum to
       * other proto files.
       * </pre>
       *
       * <code>required .csvspec.ColumnInputType.InputType type = 1;</code>
       */
      public Builder setType(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.InputType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value.getNumber();
        onChanged();
        return this;
      }

      /**
       * <pre>
       * Wrapping the type in a message like this is just for exporting the enum to
       * other proto files.
       * </pre>
       *
       * <code>required .csvspec.ColumnInputType.InputType type = 1;</code>
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 0;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csvspec.ColumnInputType)
    }

    // @@protoc_insertion_point(class_scope:csvspec.ColumnInputType)
    private static final org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType();
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<ColumnInputType>
            PARSER = new com.google.protobuf.AbstractParser<ColumnInputType>() {
      @java.lang.Override
      public ColumnInputType parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return new ColumnInputType(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ColumnInputType> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ColumnInputType> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SupersetKeySpecProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csvspec.SupersetKeySpecProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This is used to define the keys of which the value tuples defined by the
     * KeySpecProto must be a subset.
     * This can be used to verify references between two tables. By default, rows
     * with a null value in one of the key columns are silently skipped. Note that
     * the superset table and keycolumns may be declared optional, but they must
     * exist whenever the subset table and key columns exist and do not have a
     * null key in each row. If the test is performed, and the superset key
     * cannot be found, an error will be flagged.
     * </pre>
     *
     * <code>required string csvname = 1;</code>
     */
    boolean hasCsvname();

    /**
     * <pre>
     * This is used to define the keys of which the value tuples defined by the
     * KeySpecProto must be a subset.
     * This can be used to verify references between two tables. By default, rows
     * with a null value in one of the key columns are silently skipped. Note that
     * the superset table and keycolumns may be declared optional, but they must
     * exist whenever the subset table and key columns exist and do not have a
     * null key in each row. If the test is performed, and the superset key
     * cannot be found, an error will be flagged.
     * </pre>
     *
     * <code>required string csvname = 1;</code>
     */
    java.lang.String getCsvname();
    /**
     * <pre>
     * This is used to define the keys of which the value tuples defined by the
     * KeySpecProto must be a subset.
     * This can be used to verify references between two tables. By default, rows
     * with a null value in one of the key columns are silently skipped. Note that
     * the superset table and keycolumns may be declared optional, but they must
     * exist whenever the subset table and key columns exist and do not have a
     * null key in each row. If the test is performed, and the superset key
     * cannot be found, an error will be flagged.
     * </pre>
     *
     * <code>required string csvname = 1;</code>
     */
    com.google.protobuf.ByteString
    getCsvnameBytes();

    /**
     * <code>required string keyname = 2;</code>
     */
    boolean hasKeyname();

    /**
     * <code>required string keyname = 2;</code>
     */
    java.lang.String getKeyname();

    /**
     * <code>required string keyname = 2;</code>
     */
    com.google.protobuf.ByteString
    getKeynameBytes();

    /**
     * <pre>
     * If true, a null value in one of the key columns in this table is
     * recognized as an error (instead of being skipped), unless the superset
     * key has no more than one non-null value.
     * </pre>
     *
     * <code>optional bool restrictnulltosingleforeignkey = 3 [default = false];</code>
     */
    boolean hasRestrictnulltosingleforeignkey();

    /**
     * <pre>
     * If true, a null value in one of the key columns in this table is
     * recognized as an error (instead of being skipped), unless the superset
     * key has no more than one non-null value.
     * </pre>
     *
     * <code>optional bool restrictnulltosingleforeignkey = 3 [default = false];</code>
     */
    boolean getRestrictnulltosingleforeignkey();
  }

  /**
   * Protobuf type {@code csvspec.SupersetKeySpecProto}
   */
  public static final class SupersetKeySpecProto extends
          com.google.protobuf.GeneratedMessageV3 implements
          // @@protoc_insertion_point(message_implements:csvspec.SupersetKeySpecProto)
          SupersetKeySpecProtoOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use SupersetKeySpecProto.newBuilder() to construct.
    private SupersetKeySpecProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SupersetKeySpecProto() {
      csvname_ = "";
      keyname_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SupersetKeySpecProto();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private SupersetKeySpecProto(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
              com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              csvname_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              keyname_ = bs;
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              restrictnulltosingleforeignkey_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                      input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_SupersetKeySpecProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_SupersetKeySpecProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder.class);
    }

    private int bitField0_;
    public static final int CSVNAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object csvname_;
    /**
     * <pre>
     * This is used to define the keys of which the value tuples defined by the
     * KeySpecProto must be a subset.
     * This can be used to verify references between two tables. By default, rows
     * with a null value in one of the key columns are silently skipped. Note that
     * the superset table and keycolumns may be declared optional, but they must
     * exist whenever the subset table and key columns exist and do not have a
     * null key in each row. If the test is performed, and the superset key
     * cannot be found, an error will be flagged.
     * </pre>
     *
     * <code>required string csvname = 1;</code>
     */
    public boolean hasCsvname() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This is used to define the keys of which the value tuples defined by the
     * KeySpecProto must be a subset.
     * This can be used to verify references between two tables. By default, rows
     * with a null value in one of the key columns are silently skipped. Note that
     * the superset table and keycolumns may be declared optional, but they must
     * exist whenever the subset table and key columns exist and do not have a
     * null key in each row. If the test is performed, and the superset key
     * cannot be found, an error will be flagged.
     * </pre>
     *
     * <code>required string csvname = 1;</code>
     */
    public java.lang.String getCsvname() {
      java.lang.Object ref = csvname_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          csvname_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * This is used to define the keys of which the value tuples defined by the
     * KeySpecProto must be a subset.
     * This can be used to verify references between two tables. By default, rows
     * with a null value in one of the key columns are silently skipped. Note that
     * the superset table and keycolumns may be declared optional, but they must
     * exist whenever the subset table and key columns exist and do not have a
     * null key in each row. If the test is performed, and the superset key
     * cannot be found, an error will be flagged.
     * </pre>
     *
     * <code>required string csvname = 1;</code>
     */
    public com.google.protobuf.ByteString
    getCsvnameBytes() {
      java.lang.Object ref = csvname_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
                com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
        csvname_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KEYNAME_FIELD_NUMBER = 2;
    private volatile java.lang.Object keyname_;
    /**
     * <code>required string keyname = 2;</code>
     */
    public boolean hasKeyname() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>required string keyname = 2;</code>
     */
    public java.lang.String getKeyname() {
      java.lang.Object ref = keyname_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          keyname_ = s;
        }
        return s;
      }
    }
    /**
     * <code>required string keyname = 2;</code>
     */
    public com.google.protobuf.ByteString
        getKeynameBytes() {
      java.lang.Object ref = keyname_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        keyname_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RESTRICTNULLTOSINGLEFOREIGNKEY_FIELD_NUMBER = 3;
    private boolean restrictnulltosingleforeignkey_;
    /**
     * <pre>
     * If true, a null value in one of the key columns in this table is
     * recognized as an error (instead of being skipped), unless the superset
     * key has no more than one non-null value.
     * </pre>
     *
     * <code>optional bool restrictnulltosingleforeignkey = 3 [default = false];</code>
     */
    public boolean hasRestrictnulltosingleforeignkey() {
      return ((bitField0_ & 0x00000004) != 0);
    }

    /**
     * <pre>
     * If true, a null value in one of the key columns in this table is
     * recognized as an error (instead of being skipped), unless the superset
     * key has no more than one non-null value.
     * </pre>
     *
     * <code>optional bool restrictnulltosingleforeignkey = 3 [default = false];</code>
     */
    public boolean getRestrictnulltosingleforeignkey() {
      return restrictnulltosingleforeignkey_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasCsvname()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasKeyname()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, csvname_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, keyname_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(3, restrictnulltosingleforeignkey_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, csvname_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, keyname_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, restrictnulltosingleforeignkey_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto)) {
        return super.equals(obj);
      }
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto other = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto) obj;

      if (hasCsvname() != other.hasCsvname()) return false;
      if (hasCsvname()) {
        if (!getCsvname()
                .equals(other.getCsvname())) return false;
      }
      if (hasKeyname() != other.hasKeyname()) return false;
      if (hasKeyname()) {
        if (!getKeyname()
                .equals(other.getKeyname())) return false;
      }
      if (hasRestrictnulltosingleforeignkey() != other.hasRestrictnulltosingleforeignkey()) return false;
      if (hasRestrictnulltosingleforeignkey()) {
        if (getRestrictnulltosingleforeignkey()
                != other.getRestrictnulltosingleforeignkey()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCsvname()) {
        hash = (37 * hash) + CSVNAME_FIELD_NUMBER;
        hash = (53 * hash) + getCsvname().hashCode();
      }
      if (hasKeyname()) {
        hash = (37 * hash) + KEYNAME_FIELD_NUMBER;
        hash = (53 * hash) + getKeyname().hashCode();
      }
      if (hasRestrictnulltosingleforeignkey()) {
        hash = (37 * hash) + RESTRICTNULLTOSINGLEFOREIGNKEY_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getRestrictnulltosingleforeignkey());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
              ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     * Protobuf type {@code csvspec.SupersetKeySpecProto}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csvspec.SupersetKeySpecProto)
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_SupersetKeySpecProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_SupersetKeySpecProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder.class);
      }

      // Construct using org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
              com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        csvname_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        keyname_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        restrictnulltosingleforeignkey_ = false;
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
      getDescriptorForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_SupersetKeySpecProto_descriptor;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto getDefaultInstanceForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto build() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto buildPartial() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto result = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.csvname_ = csvname_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          to_bitField0_ |= 0x00000002;
        }
        result.keyname_ = keyname_;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.restrictnulltosingleforeignkey_ = restrictnulltosingleforeignkey_;
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(
              com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(
              com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto) {
          return mergeFrom((org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto other) {
        if (other == org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.getDefaultInstance())
          return this;
        if (other.hasCsvname()) {
          bitField0_ |= 0x00000001;
          csvname_ = other.csvname_;
          onChanged();
        }
        if (other.hasKeyname()) {
          bitField0_ |= 0x00000002;
          keyname_ = other.keyname_;
          onChanged();
        }
        if (other.hasRestrictnulltosingleforeignkey()) {
          setRestrictnulltosingleforeignkey(other.getRestrictnulltosingleforeignkey());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasCsvname()) {
          return false;
        }
        if (!hasKeyname()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object csvname_ = "";
      /**
       * <pre>
       * This is used to define the keys of which the value tuples defined by the
       * KeySpecProto must be a subset.
       * This can be used to verify references between two tables. By default, rows
       * with a null value in one of the key columns are silently skipped. Note that
       * the superset table and keycolumns may be declared optional, but they must
       * exist whenever the subset table and key columns exist and do not have a
       * null key in each row. If the test is performed, and the superset key
       * cannot be found, an error will be flagged.
       * </pre>
       *
       * <code>required string csvname = 1;</code>
       */
      public boolean hasCsvname() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * This is used to define the keys of which the value tuples defined by the
       * KeySpecProto must be a subset.
       * This can be used to verify references between two tables. By default, rows
       * with a null value in one of the key columns are silently skipped. Note that
       * the superset table and keycolumns may be declared optional, but they must
       * exist whenever the subset table and key columns exist and do not have a
       * null key in each row. If the test is performed, and the superset key
       * cannot be found, an error will be flagged.
       * </pre>
       *
       * <code>required string csvname = 1;</code>
       */
      public java.lang.String getCsvname() {
        java.lang.Object ref = csvname_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
                  (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            csvname_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This is used to define the keys of which the value tuples defined by the
       * KeySpecProto must be a subset.
       * This can be used to verify references between two tables. By default, rows
       * with a null value in one of the key columns are silently skipped. Note that
       * the superset table and keycolumns may be declared optional, but they must
       * exist whenever the subset table and key columns exist and do not have a
       * null key in each row. If the test is performed, and the superset key
       * cannot be found, an error will be flagged.
       * </pre>
       *
       * <code>required string csvname = 1;</code>
       */
      public com.google.protobuf.ByteString
          getCsvnameBytes() {
        java.lang.Object ref = csvname_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          csvname_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This is used to define the keys of which the value tuples defined by the
       * KeySpecProto must be a subset.
       * This can be used to verify references between two tables. By default, rows
       * with a null value in one of the key columns are silently skipped. Note that
       * the superset table and keycolumns may be declared optional, but they must
       * exist whenever the subset table and key columns exist and do not have a
       * null key in each row. If the test is performed, and the superset key
       * cannot be found, an error will be flagged.
       * </pre>
       *
       * <code>required string csvname = 1;</code>
       */
      public Builder setCsvname(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        csvname_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is used to define the keys of which the value tuples defined by the
       * KeySpecProto must be a subset.
       * This can be used to verify references between two tables. By default, rows
       * with a null value in one of the key columns are silently skipped. Note that
       * the superset table and keycolumns may be declared optional, but they must
       * exist whenever the subset table and key columns exist and do not have a
       * null key in each row. If the test is performed, and the superset key
       * cannot be found, an error will be flagged.
       * </pre>
       *
       * <code>required string csvname = 1;</code>
       */
      public Builder clearCsvname() {
        bitField0_ = (bitField0_ & ~0x00000001);
        csvname_ = getDefaultInstance().getCsvname();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is used to define the keys of which the value tuples defined by the
       * KeySpecProto must be a subset.
       * This can be used to verify references between two tables. By default, rows
       * with a null value in one of the key columns are silently skipped. Note that
       * the superset table and keycolumns may be declared optional, but they must
       * exist whenever the subset table and key columns exist and do not have a
       * null key in each row. If the test is performed, and the superset key
       * cannot be found, an error will be flagged.
       * </pre>
       *
       * <code>required string csvname = 1;</code>
       */
      public Builder setCsvnameBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        csvname_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object keyname_ = "";

      /**
       * <code>required string keyname = 2;</code>
       */
      public boolean hasKeyname() {
        return ((bitField0_ & 0x00000002) != 0);
      }

      /**
       * <code>required string keyname = 2;</code>
       */
      public java.lang.String getKeyname() {
        java.lang.Object ref = keyname_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
                  (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            keyname_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>required string keyname = 2;</code>
       */
      public com.google.protobuf.ByteString
          getKeynameBytes() {
        java.lang.Object ref = keyname_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          keyname_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>required string keyname = 2;</code>
       */
      public Builder setKeyname(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        keyname_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required string keyname = 2;</code>
       */
      public Builder clearKeyname() {
        bitField0_ = (bitField0_ & ~0x00000002);
        keyname_ = getDefaultInstance().getKeyname();
        onChanged();
        return this;
      }
      /**
       * <code>required string keyname = 2;</code>
       */
      public Builder setKeynameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        keyname_ = value;
        onChanged();
        return this;
      }

      private boolean restrictnulltosingleforeignkey_ ;
      /**
       * <pre>
       * If true, a null value in one of the key columns in this table is
       * recognized as an error (instead of being skipped), unless the superset
       * key has no more than one non-null value.
       * </pre>
       *
       * <code>optional bool restrictnulltosingleforeignkey = 3 [default = false];</code>
       */
      public boolean hasRestrictnulltosingleforeignkey() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * If true, a null value in one of the key columns in this table is
       * recognized as an error (instead of being skipped), unless the superset
       * key has no more than one non-null value.
       * </pre>
       *
       * <code>optional bool restrictnulltosingleforeignkey = 3 [default = false];</code>
       */
      public boolean getRestrictnulltosingleforeignkey() {
        return restrictnulltosingleforeignkey_;
      }

      /**
       * <pre>
       * If true, a null value in one of the key columns in this table is
       * recognized as an error (instead of being skipped), unless the superset
       * key has no more than one non-null value.
       * </pre>
       *
       * <code>optional bool restrictnulltosingleforeignkey = 3 [default = false];</code>
       */
      public Builder setRestrictnulltosingleforeignkey(boolean value) {
        bitField0_ |= 0x00000004;
        restrictnulltosingleforeignkey_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * If true, a null value in one of the key columns in this table is
       * recognized as an error (instead of being skipped), unless the superset
       * key has no more than one non-null value.
       * </pre>
       *
       * <code>optional bool restrictnulltosingleforeignkey = 3 [default = false];</code>
       */
      public Builder clearRestrictnulltosingleforeignkey() {
        bitField0_ = (bitField0_ & ~0x00000004);
        restrictnulltosingleforeignkey_ = false;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csvspec.SupersetKeySpecProto)
    }

    // @@protoc_insertion_point(class_scope:csvspec.SupersetKeySpecProto)
    private static final org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto();
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<SupersetKeySpecProto>
            PARSER = new com.google.protobuf.AbstractParser<SupersetKeySpecProto>() {
      @java.lang.Override
      public SupersetKeySpecProto parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return new SupersetKeySpecProto(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<SupersetKeySpecProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SupersetKeySpecProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NamedValueProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csvspec.NamedValueProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This message attaches a name to a specific constant value within various
     * contexts. Eg. "parent_station" to value "1" in the context of the
     * location_type column in stops.txt (see the GTFS spec). Exactly one of the
     * *value fields must be set, according to the type of the value. Named values
     * are intended to be used for code generation from a csv specification.
     * CsvParser and CsvParserSet do not support them.
     * For an example see the namedvalue definitions for the column location_type
     * within the stops csvspec in gtfs_spec.asciipb.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    boolean hasName();

    /**
     * <pre>
     * This message attaches a name to a specific constant value within various
     * contexts. Eg. "parent_station" to value "1" in the context of the
     * location_type column in stops.txt (see the GTFS spec). Exactly one of the
     * *value fields must be set, according to the type of the value. Named values
     * are intended to be used for code generation from a csv specification.
     * CsvParser and CsvParserSet do not support them.
     * For an example see the namedvalue definitions for the column location_type
     * within the stops csvspec in gtfs_spec.asciipb.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    java.lang.String getName();

    /**
     * <pre>
     * This message attaches a name to a specific constant value within various
     * contexts. Eg. "parent_station" to value "1" in the context of the
     * location_type column in stops.txt (see the GTFS spec). Exactly one of the
     * *value fields must be set, according to the type of the value. Named values
     * are intended to be used for code generation from a csv specification.
     * CsvParser and CsvParserSet do not support them.
     * For an example see the namedvalue definitions for the column location_type
     * within the stops csvspec in gtfs_spec.asciipb.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    com.google.protobuf.ByteString
    getNameBytes();

    /**
     * <code>optional int64 intvalue = 2;</code>
     */
    boolean hasIntvalue();

    /**
     * <code>optional int64 intvalue = 2;</code>
     */
    long getIntvalue();

    /**
     * <code>optional string stringvalue = 3;</code>
     */
    boolean hasStringvalue();

    /**
     * <code>optional string stringvalue = 3;</code>
     */
    java.lang.String getStringvalue();

    /**
     * <code>optional string stringvalue = 3;</code>
     */
    com.google.protobuf.ByteString
        getStringvalueBytes();

    /**
     * <code>optional string enumtype = 4;</code>
     */
    boolean hasEnumtype();
    /**
     * <code>optional string enumtype = 4;</code>
     */
    java.lang.String getEnumtype();
    /**
     * <code>optional string enumtype = 4;</code>
     */
    com.google.protobuf.ByteString
        getEnumtypeBytes();
  }
  /**
   * Protobuf type {@code csvspec.NamedValueProto}
   */
  public  static final class NamedValueProto extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csvspec.NamedValueProto)
      NamedValueProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NamedValueProto.newBuilder() to construct.
    private NamedValueProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NamedValueProto() {
      name_ = "";
      stringvalue_ = "";
      enumtype_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new NamedValueProto();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NamedValueProto(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              intvalue_ = input.readInt64();
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              stringvalue_ = bs;
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              enumtype_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                      input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_NamedValueProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_NamedValueProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * This message attaches a name to a specific constant value within various
     * contexts. Eg. "parent_station" to value "1" in the context of the
     * location_type column in stops.txt (see the GTFS spec). Exactly one of the
     * *value fields must be set, according to the type of the value. Named values
     * are intended to be used for code generation from a csv specification.
     * CsvParser and CsvParserSet do not support them.
     * For an example see the namedvalue definitions for the column location_type
     * within the stops csvspec in gtfs_spec.asciipb.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This message attaches a name to a specific constant value within various
     * contexts. Eg. "parent_station" to value "1" in the context of the
     * location_type column in stops.txt (see the GTFS spec). Exactly one of the
     * *value fields must be set, according to the type of the value. Named values
     * are intended to be used for code generation from a csv specification.
     * CsvParser and CsvParserSet do not support them.
     * For an example see the namedvalue definitions for the column location_type
     * within the stops csvspec in gtfs_spec.asciipb.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * This message attaches a name to a specific constant value within various
     * contexts. Eg. "parent_station" to value "1" in the context of the
     * location_type column in stops.txt (see the GTFS spec). Exactly one of the
     * *value fields must be set, according to the type of the value. Named values
     * are intended to be used for code generation from a csv specification.
     * CsvParser and CsvParserSet do not support them.
     * For an example see the namedvalue definitions for the column location_type
     * within the stops csvspec in gtfs_spec.asciipb.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
                com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INTVALUE_FIELD_NUMBER = 2;
    private long intvalue_;
    /**
     * <code>optional int64 intvalue = 2;</code>
     */
    public boolean hasIntvalue() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional int64 intvalue = 2;</code>
     */
    public long getIntvalue() {
      return intvalue_;
    }

    public static final int STRINGVALUE_FIELD_NUMBER = 3;
    private volatile java.lang.Object stringvalue_;
    /**
     * <code>optional string stringvalue = 3;</code>
     */
    public boolean hasStringvalue() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional string stringvalue = 3;</code>
     */
    public java.lang.String getStringvalue() {
      java.lang.Object ref = stringvalue_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          stringvalue_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string stringvalue = 3;</code>
     */
    public com.google.protobuf.ByteString
        getStringvalueBytes() {
      java.lang.Object ref = stringvalue_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
                com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
        stringvalue_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ENUMTYPE_FIELD_NUMBER = 4;
    private volatile java.lang.Object enumtype_;
    /**
     * <code>optional string enumtype = 4;</code>
     */
    public boolean hasEnumtype() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional string enumtype = 4;</code>
     */
    public java.lang.String getEnumtype() {
      java.lang.Object ref = enumtype_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          enumtype_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string enumtype = 4;</code>
     */
    public com.google.protobuf.ByteString
        getEnumtypeBytes() {
      java.lang.Object ref = enumtype_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        enumtype_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasName()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt64(2, intvalue_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, stringvalue_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, enumtype_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, intvalue_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, stringvalue_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, enumtype_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto)) {
        return super.equals(obj);
      }
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto other = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasIntvalue() != other.hasIntvalue()) return false;
      if (hasIntvalue()) {
        if (getIntvalue()
                != other.getIntvalue()) return false;
      }
      if (hasStringvalue() != other.hasStringvalue()) return false;
      if (hasStringvalue()) {
        if (!getStringvalue()
                .equals(other.getStringvalue())) return false;
      }
      if (hasEnumtype() != other.hasEnumtype()) return false;
      if (hasEnumtype()) {
        if (!getEnumtype()
                .equals(other.getEnumtype())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasIntvalue()) {
        hash = (37 * hash) + INTVALUE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                getIntvalue());
      }
      if (hasStringvalue()) {
        hash = (37 * hash) + STRINGVALUE_FIELD_NUMBER;
        hash = (53 * hash) + getStringvalue().hashCode();
      }
      if (hasEnumtype()) {
        hash = (37 * hash) + ENUMTYPE_FIELD_NUMBER;
        hash = (53 * hash) + getEnumtype().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
              ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csvspec.NamedValueProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csvspec.NamedValueProto)
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_NamedValueProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_NamedValueProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder.class);
      }

      // Construct using org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
              com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        intvalue_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000002);
        stringvalue_ = "";
        bitField0_ = (bitField0_ & ~0x00000004);
        enumtype_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
      getDescriptorForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_NamedValueProto_descriptor;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto getDefaultInstanceForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto build() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto buildPartial() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto result = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.intvalue_ = intvalue_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          to_bitField0_ |= 0x00000004;
        }
        result.stringvalue_ = stringvalue_;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          to_bitField0_ |= 0x00000008;
        }
        result.enumtype_ = enumtype_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(
              com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(
              com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto) {
          return mergeFrom((org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto other) {
        if (other == org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.getDefaultInstance())
          return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasIntvalue()) {
          setIntvalue(other.getIntvalue());
        }
        if (other.hasStringvalue()) {
          bitField0_ |= 0x00000004;
          stringvalue_ = other.stringvalue_;
          onChanged();
        }
        if (other.hasEnumtype()) {
          bitField0_ |= 0x00000008;
          enumtype_ = other.enumtype_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasName()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * This message attaches a name to a specific constant value within various
       * contexts. Eg. "parent_station" to value "1" in the context of the
       * location_type column in stops.txt (see the GTFS spec). Exactly one of the
       * *value fields must be set, according to the type of the value. Named values
       * are intended to be used for code generation from a csv specification.
       * CsvParser and CsvParserSet do not support them.
       * For an example see the namedvalue definitions for the column location_type
       * within the stops csvspec in gtfs_spec.asciipb.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * This message attaches a name to a specific constant value within various
       * contexts. Eg. "parent_station" to value "1" in the context of the
       * location_type column in stops.txt (see the GTFS spec). Exactly one of the
       * *value fields must be set, according to the type of the value. Named values
       * are intended to be used for code generation from a csv specification.
       * CsvParser and CsvParserSet do not support them.
       * For an example see the namedvalue definitions for the column location_type
       * within the stops csvspec in gtfs_spec.asciipb.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
                  (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This message attaches a name to a specific constant value within various
       * contexts. Eg. "parent_station" to value "1" in the context of the
       * location_type column in stops.txt (see the GTFS spec). Exactly one of the
       * *value fields must be set, according to the type of the value. Named values
       * are intended to be used for code generation from a csv specification.
       * CsvParser and CsvParserSet do not support them.
       * For an example see the namedvalue definitions for the column location_type
       * within the stops csvspec in gtfs_spec.asciipb.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This message attaches a name to a specific constant value within various
       * contexts. Eg. "parent_station" to value "1" in the context of the
       * location_type column in stops.txt (see the GTFS spec). Exactly one of the
       * *value fields must be set, according to the type of the value. Named values
       * are intended to be used for code generation from a csv specification.
       * CsvParser and CsvParserSet do not support them.
       * For an example see the namedvalue definitions for the column location_type
       * within the stops csvspec in gtfs_spec.asciipb.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This message attaches a name to a specific constant value within various
       * contexts. Eg. "parent_station" to value "1" in the context of the
       * location_type column in stops.txt (see the GTFS spec). Exactly one of the
       * *value fields must be set, according to the type of the value. Named values
       * are intended to be used for code generation from a csv specification.
       * CsvParser and CsvParserSet do not support them.
       * For an example see the namedvalue definitions for the column location_type
       * within the stops csvspec in gtfs_spec.asciipb.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This message attaches a name to a specific constant value within various
       * contexts. Eg. "parent_station" to value "1" in the context of the
       * location_type column in stops.txt (see the GTFS spec). Exactly one of the
       * *value fields must be set, according to the type of the value. Named values
       * are intended to be used for code generation from a csv specification.
       * CsvParser and CsvParserSet do not support them.
       * For an example see the namedvalue definitions for the column location_type
       * within the stops csvspec in gtfs_spec.asciipb.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private long intvalue_;

      /**
       * <code>optional int64 intvalue = 2;</code>
       */
      public boolean hasIntvalue() {
        return ((bitField0_ & 0x00000002) != 0);
      }

      /**
       * <code>optional int64 intvalue = 2;</code>
       */
      public long getIntvalue() {
        return intvalue_;
      }

      /**
       * <code>optional int64 intvalue = 2;</code>
       */
      public Builder setIntvalue(long value) {
        bitField0_ |= 0x00000002;
        intvalue_ = value;
        onChanged();
        return this;
      }

      /**
       * <code>optional int64 intvalue = 2;</code>
       */
      public Builder clearIntvalue() {
        bitField0_ = (bitField0_ & ~0x00000002);
        intvalue_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object stringvalue_ = "";

      /**
       * <code>optional string stringvalue = 3;</code>
       */
      public boolean hasStringvalue() {
        return ((bitField0_ & 0x00000004) != 0);
      }

      /**
       * <code>optional string stringvalue = 3;</code>
       */
      public java.lang.String getStringvalue() {
        java.lang.Object ref = stringvalue_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            stringvalue_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }

      /**
       * <code>optional string stringvalue = 3;</code>
       */
      public com.google.protobuf.ByteString
      getStringvalueBytes() {
        java.lang.Object ref = stringvalue_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stringvalue_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string stringvalue = 3;</code>
       */
      public Builder setStringvalue(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        stringvalue_ = value;
        onChanged();
        return this;
      }

      /**
       * <code>optional string stringvalue = 3;</code>
       */
      public Builder clearStringvalue() {
        bitField0_ = (bitField0_ & ~0x00000004);
        stringvalue_ = getDefaultInstance().getStringvalue();
        onChanged();
        return this;
      }

      /**
       * <code>optional string stringvalue = 3;</code>
       */
      public Builder setStringvalueBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        stringvalue_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object enumtype_ = "";

      /**
       * <code>optional string enumtype = 4;</code>
       */
      public boolean hasEnumtype() {
        return ((bitField0_ & 0x00000008) != 0);
      }

      /**
       * <code>optional string enumtype = 4;</code>
       */
      public java.lang.String getEnumtype() {
        java.lang.Object ref = enumtype_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            enumtype_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }

      /**
       * <code>optional string enumtype = 4;</code>
       */
      public com.google.protobuf.ByteString
      getEnumtypeBytes() {
        java.lang.Object ref = enumtype_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
                  com.google.protobuf.ByteString.copyFromUtf8(
                          (java.lang.String) ref);
          enumtype_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string enumtype = 4;</code>
       */
      public Builder setEnumtype(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
  bitField0_ |= 0x00000008;
        enumtype_ = value;
        onChanged();
        return this;
      }

      /**
       * <code>optional string enumtype = 4;</code>
       */
      public Builder clearEnumtype() {
        bitField0_ = (bitField0_ & ~0x00000008);
        enumtype_ = getDefaultInstance().getEnumtype();
        onChanged();
        return this;
      }

      /**
       * <code>optional string enumtype = 4;</code>
       */
      public Builder setEnumtypeBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000008;
        enumtype_ = value;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csvspec.NamedValueProto)
    }

    // @@protoc_insertion_point(class_scope:csvspec.NamedValueProto)
    private static final org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto();
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<NamedValueProto>
        PARSER = new com.google.protobuf.AbstractParser<NamedValueProto>() {
      @java.lang.Override
      public NamedValueProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NamedValueProto(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NamedValueProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NamedValueProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ColumnCacheProtoOrBuilder extends
          // @@protoc_insertion_point(interface_extends:csvspec.ColumnCacheProto)
          com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * When enabled, numeric values for columns with INT or FLOAT types will be
     * cached, saving repeated string=&gt;number conversions.
     * </pre>
     *
     * <code>optional bool cache_numbers = 1 [default = false];</code>
     */
    boolean hasCacheNumbers();

    /**
     * <pre>
     * When enabled, numeric values for columns with INT or FLOAT types will be
     * cached, saving repeated string=&gt;number conversions.
     * </pre>
     *
     * <code>optional bool cache_numbers = 1 [default = false];</code>
     */
    boolean getCacheNumbers();

    /**
     * <pre>
     * When enabled, single-column key values will be cached, saving repeated key
     * value generation and speeding up some sort operations.
     * </pre>
     *
     * <code>optional bool cache_keys = 2 [default = false];</code>
     */
    boolean hasCacheKeys();
    /**
     * <pre>
     * When enabled, single-column key values will be cached, saving repeated key
     * value generation and speeding up some sort operations.
     * </pre>
     *
     * <code>optional bool cache_keys = 2 [default = false];</code>
     */
    boolean getCacheKeys();
  }
  /**
   * <pre>
   * Column value caching configuration.  Caching, when enabled, can speed up
   * processing for large CVS files, at the expense of higher memory
   * requirements.
   * </pre>
   *
   * Protobuf type {@code csvspec.ColumnCacheProto}
   */
  public  static final class ColumnCacheProto extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csvspec.ColumnCacheProto)
      ColumnCacheProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ColumnCacheProto.newBuilder() to construct.
    private ColumnCacheProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ColumnCacheProto() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ColumnCacheProto();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }

    private ColumnCacheProto(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              cacheNumbers_ = input.readBool();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              cacheKeys_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnCacheProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnCacheProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder.class);
    }

    private int bitField0_;
    public static final int CACHE_NUMBERS_FIELD_NUMBER = 1;
    private boolean cacheNumbers_;
    /**
     * <pre>
     * When enabled, numeric values for columns with INT or FLOAT types will be
     * cached, saving repeated string=&gt;number conversions.
     * </pre>
     *
     * <code>optional bool cache_numbers = 1 [default = false];</code>
     */
    public boolean hasCacheNumbers() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * When enabled, numeric values for columns with INT or FLOAT types will be
     * cached, saving repeated string=&gt;number conversions.
     * </pre>
     *
     * <code>optional bool cache_numbers = 1 [default = false];</code>
     */
    public boolean getCacheNumbers() {
      return cacheNumbers_;
    }

    public static final int CACHE_KEYS_FIELD_NUMBER = 2;
    private boolean cacheKeys_;
    /**
     * <pre>
     * When enabled, single-column key values will be cached, saving repeated key
     * value generation and speeding up some sort operations.
     * </pre>
     *
     * <code>optional bool cache_keys = 2 [default = false];</code>
     */
    public boolean hasCacheKeys() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     * <pre>
     * When enabled, single-column key values will be cached, saving repeated key
     * value generation and speeding up some sort operations.
     * </pre>
     *
     * <code>optional bool cache_keys = 2 [default = false];</code>
     */
    public boolean getCacheKeys() {
      return cacheKeys_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBool(1, cacheNumbers_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBool(2, cacheKeys_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, cacheNumbers_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
                .computeBoolSize(2, cacheKeys_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto)) {
        return super.equals(obj);
      }
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto other = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto) obj;

      if (hasCacheNumbers() != other.hasCacheNumbers()) return false;
      if (hasCacheNumbers()) {
        if (getCacheNumbers()
                != other.getCacheNumbers()) return false;
      }
      if (hasCacheKeys() != other.hasCacheKeys()) return false;
      if (hasCacheKeys()) {
        if (getCacheKeys()
                != other.getCacheKeys()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCacheNumbers()) {
        hash = (37 * hash) + CACHE_NUMBERS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getCacheNumbers());
      }
      if (hasCacheKeys()) {
        hash = (37 * hash) + CACHE_KEYS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getCacheKeys());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
              ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Column value caching configuration.  Caching, when enabled, can speed up
     * processing for large CVS files, at the expense of higher memory
     * requirements.
     * </pre>
     *
     * Protobuf type {@code csvspec.ColumnCacheProto}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:csvspec.ColumnCacheProto)
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnCacheProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnCacheProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder.class);
      }

      // Construct using org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
              com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        cacheNumbers_ = false;
        bitField0_ = (bitField0_ & ~0x00000001);
        cacheKeys_ = false;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
      getDescriptorForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnCacheProto_descriptor;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto getDefaultInstanceForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto build() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto buildPartial() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto result = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.cacheNumbers_ = cacheNumbers_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.cacheKeys_ = cacheKeys_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(
              com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(
              com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto) {
          return mergeFrom((org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto other) {
        if (other == org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance()) return this;
        if (other.hasCacheNumbers()) {
          setCacheNumbers(other.getCacheNumbers());
        }
        if (other.hasCacheKeys()) {
          setCacheKeys(other.getCacheKeys());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private boolean cacheNumbers_ ;
      /**
       * <pre>
       * When enabled, numeric values for columns with INT or FLOAT types will be
       * cached, saving repeated string=&gt;number conversions.
       * </pre>
       *
       * <code>optional bool cache_numbers = 1 [default = false];</code>
       */
      public boolean hasCacheNumbers() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * When enabled, numeric values for columns with INT or FLOAT types will be
       * cached, saving repeated string=&gt;number conversions.
       * </pre>
       *
       * <code>optional bool cache_numbers = 1 [default = false];</code>
       */
      public boolean getCacheNumbers() {
        return cacheNumbers_;
      }
      /**
       * <pre>
       * When enabled, numeric values for columns with INT or FLOAT types will be
       * cached, saving repeated string=&gt;number conversions.
       * </pre>
       *
       * <code>optional bool cache_numbers = 1 [default = false];</code>
       */
      public Builder setCacheNumbers(boolean value) {
        bitField0_ |= 0x00000001;
        cacheNumbers_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When enabled, numeric values for columns with INT or FLOAT types will be
       * cached, saving repeated string=&gt;number conversions.
       * </pre>
       *
       * <code>optional bool cache_numbers = 1 [default = false];</code>
       */
      public Builder clearCacheNumbers() {
        bitField0_ = (bitField0_ & ~0x00000001);
        cacheNumbers_ = false;
        onChanged();
        return this;
      }

      private boolean cacheKeys_;

      /**
       * <pre>
       * When enabled, single-column key values will be cached, saving repeated key
       * value generation and speeding up some sort operations.
       * </pre>
       *
       * <code>optional bool cache_keys = 2 [default = false];</code>
       */
      public boolean hasCacheKeys() {
        return ((bitField0_ & 0x00000002) != 0);
      }

      /**
       * <pre>
       * When enabled, single-column key values will be cached, saving repeated key
       * value generation and speeding up some sort operations.
       * </pre>
       *
       * <code>optional bool cache_keys = 2 [default = false];</code>
       */
      public boolean getCacheKeys() {
        return cacheKeys_;
      }

      /**
       * <pre>
       * When enabled, single-column key values will be cached, saving repeated key
       * value generation and speeding up some sort operations.
       * </pre>
       *
       * <code>optional bool cache_keys = 2 [default = false];</code>
       */
      public Builder setCacheKeys(boolean value) {
        bitField0_ |= 0x00000002;
        cacheKeys_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * When enabled, single-column key values will be cached, saving repeated key
       * value generation and speeding up some sort operations.
       * </pre>
       *
       * <code>optional bool cache_keys = 2 [default = false];</code>
       */
      public Builder clearCacheKeys() {
        bitField0_ = (bitField0_ & ~0x00000002);
        cacheKeys_ = false;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csvspec.ColumnCacheProto)
    }

    // @@protoc_insertion_point(class_scope:csvspec.ColumnCacheProto)
    private static final org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto();
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ColumnCacheProto>
        PARSER = new com.google.protobuf.AbstractParser<ColumnCacheProto>() {
      @java.lang.Override
      public ColumnCacheProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ColumnCacheProto(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ColumnCacheProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ColumnCacheProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ColumnSpecProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csvspec.ColumnSpecProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This is the name to be used for this column. This field can be used in two
     * ways:
     * - To reference a column name given in the first row of the csv file.
     * - To introduce a new name for the column, in that case, the original name
     *   (the name given in the first row of the csv file) or a column number
     *   (starting on 0) must be given as well.
     * Note that every column name also is a key name. See KeySpecProto.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    boolean hasName();
    /**
     * <pre>
     * This is the name to be used for this column. This field can be used in two
     * ways:
     * - To reference a column name given in the first row of the csv file.
     * - To introduce a new name for the column, in that case, the original name
     *   (the name given in the first row of the csv file) or a column number
     *   (starting on 0) must be given as well.
     * Note that every column name also is a key name. See KeySpecProto.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * This is the name to be used for this column. This field can be used in two
     * ways:
     * - To reference a column name given in the first row of the csv file.
     * - To introduce a new name for the column, in that case, the original name
     *   (the name given in the first row of the csv file) or a column number
     *   (starting on 0) must be given as well.
     * Note that every column name also is a key name. See KeySpecProto.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>optional string originalname = 2;</code>
     */
    boolean hasOriginalname();
    /**
     * <code>optional string originalname = 2;</code>
     */
    java.lang.String getOriginalname();
    /**
     * <code>optional string originalname = 2;</code>
     */
    com.google.protobuf.ByteString
        getOriginalnameBytes();

    /**
     * <code>optional int32 number = 3;</code>
     */
    boolean hasNumber();
    /**
     * <code>optional int32 number = 3;</code>
     */
    int getNumber();

    /**
     * <pre>
     * If a template is used for this spec, and this flag is set true, this column
     * spec will be merged with any corresponding column in the template. If
     * false, the template column will be ignored.
     * </pre>
     *
     * <code>optional bool inheritfields = 15 [default = false];</code>
     */
    boolean hasInheritfields();
    /**
     * <pre>
     * If a template is used for this spec, and this flag is set true, this column
     * spec will be merged with any corresponding column in the template. If
     * false, the template column will be ignored.
     * </pre>
     *
     * <code>optional bool inheritfields = 15 [default = false];</code>
     */
    boolean getInheritfields();

    /**
     * <pre>
     * This determines what will happen if this column is missing in the input
     * csv. If true, an error will be flagged, if false, this will be silently
     * ignored and all tests on this column, and any keys that includes this
     * column will be skipped.
     * </pre>
     *
     * <code>optional bool required = 4 [default = true];</code>
     */
    boolean hasRequired();
    /**
     * <pre>
     * This determines what will happen if this column is missing in the input
     * csv. If true, an error will be flagged, if false, this will be silently
     * ignored and all tests on this column, and any keys that includes this
     * column will be skipped.
     * </pre>
     *
     * <code>optional bool required = 4 [default = true];</code>
     */
    boolean getRequired();

    /**
     * <pre>
     * If specified, all cells in the column that matches this regexp are
     * considered NULL. These cells will be disregarded in tests. This includes
     * the integer and regexp tests below, as well as tests on properties of keys,
     * see KeySpecProto.
     * </pre>
     *
     * <code>optional string nullvalue = 5 [default = ""];</code>
     */
    boolean hasNullvalue();
    /**
     * <pre>
     * If specified, all cells in the column that matches this regexp are
     * considered NULL. These cells will be disregarded in tests. This includes
     * the integer and regexp tests below, as well as tests on properties of keys,
     * see KeySpecProto.
     * </pre>
     *
     * <code>optional string nullvalue = 5 [default = ""];</code>
     */
    java.lang.String getNullvalue();

    /**
     * <pre>
     * If specified, all cells in the column that matches this regexp are
     * considered NULL. These cells will be disregarded in tests. This includes
     * the integer and regexp tests below, as well as tests on properties of keys,
     * see KeySpecProto.
     * </pre>
     *
     * <code>optional string nullvalue = 5 [default = ""];</code>
     */
    com.google.protobuf.ByteString
    getNullvalueBytes();

    /**
     * <pre>
     * This determines what will happen if a row value of this column is null
     * (i.e. equal to the nullvalue field) in the input csv. If true, a
     * MISSING_VALUE error will be flagged.
     * </pre>
     *
     * <code>optional bool value_required = 17 [default = false];</code>
     */
    boolean hasValueRequired();
    /**
     * <pre>
     * This determines what will happen if a row value of this column is null
     * (i.e. equal to the nullvalue field) in the input csv. If true, a
     * MISSING_VALUE error will be flagged.
     * </pre>
     *
     * <code>optional bool value_required = 17 [default = false];</code>
     */
    boolean getValueRequired();

    /**
     * <pre>
     * The input type of the column. See enum definition for detailed requirements
     * on each format.
     * </pre>
     *
     * <code>optional .csvspec.ColumnInputType type = 6;</code>
     */
    boolean hasType();
    /**
     * <pre>
     * The input type of the column. See enum definition for detailed requirements
     * on each format.
     * </pre>
     *
     * <code>optional .csvspec.ColumnInputType type = 6;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType getType();

    /**
     * <pre>
     * The input type of the column. See enum definition for detailed requirements
     * on each format.
     * </pre>
     *
     * <code>optional .csvspec.ColumnInputType type = 6;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputTypeOrBuilder getTypeOrBuilder();

    /**
     * <pre>
     * Specifies max/min values (inclusive) for integer types.
     * </pre>
     *
     * <code>optional int32 intmin = 7;</code>
     */
    boolean hasIntmin();

    /**
     * <pre>
     * Specifies max/min values (inclusive) for integer types.
     * </pre>
     *
     * <code>optional int32 intmin = 7;</code>
     */
    int getIntmin();

    /**
     * <code>optional int32 intmax = 8;</code>
     */
    boolean hasIntmax();

    /**
     * <code>optional int32 intmax = 8;</code>
     */
    int getIntmax();

    /**
     * <pre>
     * Specifies max/min values for float types.
     * </pre>
     *
     * <code>optional float floatmin = 13;</code>
     */
    boolean hasFloatmin();

    /**
     * <pre>
     * Specifies max/min values for float types.
     * </pre>
     *
     * <code>optional float floatmin = 13;</code>
     */
    float getFloatmin();

    /**
     * <code>optional float floatmax = 14;</code>
     */
    boolean hasFloatmax();

    /**
     * <code>optional float floatmax = 14;</code>
     */
    float getFloatmax();

    /**
     * <pre>
     * Specifies names for certain values in this column, see message definition.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto>
    getNamedvalueList();

    /**
     * <pre>
     * Specifies names for certain values in this column, see message definition.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto getNamedvalue(int index);
    /**
     * <pre>
     * Specifies names for certain values in this column, see message definition.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    int getNamedvalueCount();
    /**
     * <pre>
     * Specifies names for certain values in this column, see message definition.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder>
    getNamedvalueOrBuilderList();

    /**
     * <pre>
     * Specifies names for certain values in this column, see message definition.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder getNamedvalueOrBuilder(
            int index);

    /**
     * <pre>
     * If specified, all (non-null) values of this column must match this regexp.
     * </pre>
     *
     * <code>optional string matchregexp = 9;</code>
     */
    boolean hasMatchregexp();

    /**
     * <pre>
     * If specified, all (non-null) values of this column must match this regexp.
     * </pre>
     *
     * <code>optional string matchregexp = 9;</code>
     */
    java.lang.String getMatchregexp();

    /**
     * <pre>
     * If specified, all (non-null) values of this column must match this regexp.
     * </pre>
     *
     * <code>optional string matchregexp = 9;</code>
     */
    com.google.protobuf.ByteString
        getMatchregexpBytes();

    /**
     * <pre>
     * These fields are syntactic sugar for testing properties of the key
     * consisting of only this column. See SupersetKeySpecProto for more.
     * </pre>
     *
     * <code>optional bool uniquevalues = 10 [default = false];</code>
     */
    boolean hasUniquevalues();

    /**
     * <pre>
     * These fields are syntactic sugar for testing properties of the key
     * consisting of only this column. See SupersetKeySpecProto for more.
     * </pre>
     *
     * <code>optional bool uniquevalues = 10 [default = false];</code>
     */
    boolean getUniquevalues();

    /**
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
     */
    java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto>
    getSupersetkeyList();

    /**
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto getSupersetkey(int index);
    /**
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
     */
    int getSupersetkeyCount();
    /**
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
     */
    java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder>
    getSupersetkeyOrBuilderList();

    /**
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder getSupersetkeyOrBuilder(
            int index);

    /**
     * <pre>
     * Defines the value caching strategy for this column.  This can be useful
     * for INT and FLOAT columns where repeatedly converting raw CSV string
     * values to native types carries a performance hit.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
     */
    boolean hasCache();

    /**
     * <pre>
     * Defines the value caching strategy for this column.  This can be useful
     * for INT and FLOAT columns where repeatedly converting raw CSV string
     * values to native types carries a performance hit.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto getCache();
    /**
     * <pre>
     * Defines the value caching strategy for this column.  This can be useful
     * for INT and FLOAT columns where repeatedly converting raw CSV string
     * values to native types carries a performance hit.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder getCacheOrBuilder();

    /**
     * <pre>
     * Field number for if the spec containing this column is converted to a
     * protobuf message. Must be unique within the spec and &gt;= 2.
     * </pre>
     *
     * <code>optional int32 field_number = 18;</code>
     */
    boolean hasFieldNumber();
    /**
     * <pre>
     * Field number for if the spec containing this column is converted to a
     * protobuf message. Must be unique within the spec and &gt;= 2.
     * </pre>
     *
     * <code>optional int32 field_number = 18;</code>
     */
    int getFieldNumber();
  }
  /**
   * Protobuf type {@code csvspec.ColumnSpecProto}
   */
  public  static final class ColumnSpecProto extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csvspec.ColumnSpecProto)
      ColumnSpecProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ColumnSpecProto.newBuilder() to construct.
    private ColumnSpecProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ColumnSpecProto() {
      name_ = "";
      originalname_ = "";
      required_ = true;
      nullvalue_ = "";
      namedvalue_ = java.util.Collections.emptyList();
      matchregexp_ = "";
      supersetkey_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
            UnusedPrivateParameter unused) {
      return new ColumnSpecProto();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }

    private ColumnSpecProto(
            com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              originalname_ = bs;
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              number_ = input.readInt32();
              break;
            }
            case 32: {
              bitField0_ |= 0x00000010;
              required_ = input.readBool();
              break;
            }
            case 42: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000020;
              nullvalue_ = bs;
              break;
            }
            case 50: {
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.Builder subBuilder = null;
              if (((bitField0_ & 0x00000080) != 0)) {
                subBuilder = type_.toBuilder();
              }
              type_ = input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(type_);
                type_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000080;
              break;
            }
            case 56: {
              bitField0_ |= 0x00000100;
              intmin_ = input.readInt32();
              break;
            }
            case 64: {
              bitField0_ |= 0x00000200;
              intmax_ = input.readInt32();
              break;
            }
            case 74: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00001000;
              matchregexp_ = bs;
              break;
            }
            case 80: {
              bitField0_ |= 0x00002000;
              uniquevalues_ = input.readBool();
              break;
            }
            case 90: {
              if (!((mutable_bitField0_ & 0x00008000) != 0)) {
                supersetkey_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto>();
                mutable_bitField0_ |= 0x00008000;
              }
              supersetkey_.add(
                  input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.PARSER, extensionRegistry));
              break;
            }
            case 98: {
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder subBuilder = null;
              if (((bitField0_ & 0x00004000) != 0)) {
                subBuilder = cache_.toBuilder();
              }
              cache_ = input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(cache_);
                cache_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00004000;
              break;
            }
            case 109: {
              bitField0_ |= 0x00000400;
              floatmin_ = input.readFloat();
              break;
            }
            case 117: {
              bitField0_ |= 0x00000800;
              floatmax_ = input.readFloat();
              break;
            }
            case 120: {
              bitField0_ |= 0x00000008;
              inheritfields_ = input.readBool();
              break;
            }
            case 130: {
              if (!((mutable_bitField0_ & 0x00001000) != 0)) {
                namedvalue_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto>();
                mutable_bitField0_ |= 0x00001000;
              }
              namedvalue_.add(
                      input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.PARSER, extensionRegistry));
              break;
            }
            case 136: {
              bitField0_ |= 0x00000040;
              valueRequired_ = input.readBool();
              break;
            }
            case 144: {
              bitField0_ |= 0x00008000;
              fieldNumber_ = input.readInt32();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00008000) != 0)) {
          supersetkey_ = java.util.Collections.unmodifiableList(supersetkey_);
        }
        if (((mutable_bitField0_ & 0x00001000) != 0)) {
          namedvalue_ = java.util.Collections.unmodifiableList(namedvalue_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnSpecProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnSpecProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;

    /**
     * <pre>
     * This is the name to be used for this column. This field can be used in two
     * ways:
     * - To reference a column name given in the first row of the csv file.
     * - To introduce a new name for the column, in that case, the original name
     *   (the name given in the first row of the csv file) or a column number
     *   (starting on 0) must be given as well.
     * Note that every column name also is a key name. See KeySpecProto.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This is the name to be used for this column. This field can be used in two
     * ways:
     * - To reference a column name given in the first row of the csv file.
     * - To introduce a new name for the column, in that case, the original name
     *   (the name given in the first row of the csv file) or a column number
     *   (starting on 0) must be given as well.
     * Note that every column name also is a key name. See KeySpecProto.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * This is the name to be used for this column. This field can be used in two
     * ways:
     * - To reference a column name given in the first row of the csv file.
     * - To introduce a new name for the column, in that case, the original name
     *   (the name given in the first row of the csv file) or a column number
     *   (starting on 0) must be given as well.
     * Note that every column name also is a key name. See KeySpecProto.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ORIGINALNAME_FIELD_NUMBER = 2;
    private volatile java.lang.Object originalname_;
    /**
     * <code>optional string originalname = 2;</code>
     */
    public boolean hasOriginalname() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional string originalname = 2;</code>
     */
    public java.lang.String getOriginalname() {
      java.lang.Object ref = originalname_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          originalname_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string originalname = 2;</code>
     */
    public com.google.protobuf.ByteString
        getOriginalnameBytes() {
      java.lang.Object ref = originalname_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        originalname_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NUMBER_FIELD_NUMBER = 3;
    private int number_;
    /**
     * <code>optional int32 number = 3;</code>
     */
    public boolean hasNumber() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional int32 number = 3;</code>
     */
    public int getNumber() {
      return number_;
    }

    public static final int INHERITFIELDS_FIELD_NUMBER = 15;
    private boolean inheritfields_;
    /**
     * <pre>
     * If a template is used for this spec, and this flag is set true, this column
     * spec will be merged with any corresponding column in the template. If
     * false, the template column will be ignored.
     * </pre>
     *
     * <code>optional bool inheritfields = 15 [default = false];</code>
     */
    public boolean hasInheritfields() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * If a template is used for this spec, and this flag is set true, this column
     * spec will be merged with any corresponding column in the template. If
     * false, the template column will be ignored.
     * </pre>
     *
     * <code>optional bool inheritfields = 15 [default = false];</code>
     */
    public boolean getInheritfields() {
      return inheritfields_;
    }

    public static final int REQUIRED_FIELD_NUMBER = 4;
    private boolean required_;
    /**
     * <pre>
     * This determines what will happen if this column is missing in the input
     * csv. If true, an error will be flagged, if false, this will be silently
     * ignored and all tests on this column, and any keys that includes this
     * column will be skipped.
     * </pre>
     *
     * <code>optional bool required = 4 [default = true];</code>
     */
    public boolean hasRequired() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * This determines what will happen if this column is missing in the input
     * csv. If true, an error will be flagged, if false, this will be silently
     * ignored and all tests on this column, and any keys that includes this
     * column will be skipped.
     * </pre>
     *
     * <code>optional bool required = 4 [default = true];</code>
     */
    public boolean getRequired() {
      return required_;
    }

    public static final int NULLVALUE_FIELD_NUMBER = 5;
    private volatile java.lang.Object nullvalue_;

    /**
     * <pre>
     * If specified, all cells in the column that matches this regexp are
     * considered NULL. These cells will be disregarded in tests. This includes
     * the integer and regexp tests below, as well as tests on properties of keys,
     * see KeySpecProto.
     * </pre>
     *
     * <code>optional string nullvalue = 5 [default = ""];</code>
     */
    public boolean hasNullvalue() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * If specified, all cells in the column that matches this regexp are
     * considered NULL. These cells will be disregarded in tests. This includes
     * the integer and regexp tests below, as well as tests on properties of keys,
     * see KeySpecProto.
     * </pre>
     *
     * <code>optional string nullvalue = 5 [default = ""];</code>
     */
    public java.lang.String getNullvalue() {
      java.lang.Object ref = nullvalue_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          nullvalue_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * If specified, all cells in the column that matches this regexp are
     * considered NULL. These cells will be disregarded in tests. This includes
     * the integer and regexp tests below, as well as tests on properties of keys,
     * see KeySpecProto.
     * </pre>
     *
     * <code>optional string nullvalue = 5 [default = ""];</code>
     */
    public com.google.protobuf.ByteString
    getNullvalueBytes() {
      java.lang.Object ref = nullvalue_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
                com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
        nullvalue_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VALUE_REQUIRED_FIELD_NUMBER = 17;
    private boolean valueRequired_;

    /**
     * <pre>
     * This determines what will happen if a row value of this column is null
     * (i.e. equal to the nullvalue field) in the input csv. If true, a
     * MISSING_VALUE error will be flagged.
     * </pre>
     *
     * <code>optional bool value_required = 17 [default = false];</code>
     */
    public boolean hasValueRequired() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * This determines what will happen if a row value of this column is null
     * (i.e. equal to the nullvalue field) in the input csv. If true, a
     * MISSING_VALUE error will be flagged.
     * </pre>
     *
     * <code>optional bool value_required = 17 [default = false];</code>
     */
    public boolean getValueRequired() {
      return valueRequired_;
    }

    public static final int TYPE_FIELD_NUMBER = 6;
    private org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType type_;
    /**
     * <pre>
     * The input type of the column. See enum definition for detailed requirements
     * on each format.
     * </pre>
     *
     * <code>optional .csvspec.ColumnInputType type = 6;</code>
     */
    public boolean hasType() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * The input type of the column. See enum definition for detailed requirements
     * on each format.
     * </pre>
     *
     * <code>optional .csvspec.ColumnInputType type = 6;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType getType() {
      return type_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.getDefaultInstance() : type_;
    }
    /**
     * <pre>
     * The input type of the column. See enum definition for detailed requirements
     * on each format.
     * </pre>
     *
     * <code>optional .csvspec.ColumnInputType type = 6;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputTypeOrBuilder getTypeOrBuilder() {
      return type_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.getDefaultInstance() : type_;
    }

    public static final int INTMIN_FIELD_NUMBER = 7;
    private int intmin_;

    /**
     * <pre>
     * Specifies max/min values (inclusive) for integer types.
     * </pre>
     *
     * <code>optional int32 intmin = 7;</code>
     */
    public boolean hasIntmin() {
      return ((bitField0_ & 0x00000100) != 0);
    }

    /**
     * <pre>
     * Specifies max/min values (inclusive) for integer types.
     * </pre>
     *
     * <code>optional int32 intmin = 7;</code>
     */
    public int getIntmin() {
      return intmin_;
    }

    public static final int INTMAX_FIELD_NUMBER = 8;
    private int intmax_;

    /**
     * <code>optional int32 intmax = 8;</code>
     */
    public boolean hasIntmax() {
      return ((bitField0_ & 0x00000200) != 0);
    }

    /**
     * <code>optional int32 intmax = 8;</code>
     */
    public int getIntmax() {
      return intmax_;
    }

    public static final int FLOATMIN_FIELD_NUMBER = 13;
    private float floatmin_;

    /**
     * <pre>
     * Specifies max/min values for float types.
     * </pre>
     *
     * <code>optional float floatmin = 13;</code>
     */
    public boolean hasFloatmin() {
      return ((bitField0_ & 0x00000400) != 0);
    }

    /**
     * <pre>
     * Specifies max/min values for float types.
     * </pre>
     *
     * <code>optional float floatmin = 13;</code>
     */
    public float getFloatmin() {
      return floatmin_;
    }

    public static final int FLOATMAX_FIELD_NUMBER = 14;
    private float floatmax_;

    /**
     * <code>optional float floatmax = 14;</code>
     */
    public boolean hasFloatmax() {
      return ((bitField0_ & 0x00000800) != 0);
    }

    /**
     * <code>optional float floatmax = 14;</code>
     */
    public float getFloatmax() {
      return floatmax_;
    }

    public static final int NAMEDVALUE_FIELD_NUMBER = 16;
    private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> namedvalue_;
    /**
     * <pre>
     * Specifies names for certain values in this column, see message definition.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> getNamedvalueList() {
      return namedvalue_;
    }
    /**
     * <pre>
     * Specifies names for certain values in this column, see message definition.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder>
    getNamedvalueOrBuilderList() {
      return namedvalue_;
    }

    /**
     * <pre>
     * Specifies names for certain values in this column, see message definition.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    public int getNamedvalueCount() {
      return namedvalue_.size();
    }

    /**
     * <pre>
     * Specifies names for certain values in this column, see message definition.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto getNamedvalue(int index) {
      return namedvalue_.get(index);
    }
    /**
     * <pre>
     * Specifies names for certain values in this column, see message definition.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder getNamedvalueOrBuilder(
        int index) {
      return namedvalue_.get(index);
    }

    public static final int MATCHREGEXP_FIELD_NUMBER = 9;
    private volatile java.lang.Object matchregexp_;
    /**
     * <pre>
     * If specified, all (non-null) values of this column must match this regexp.
     * </pre>
     *
     * <code>optional string matchregexp = 9;</code>
     */
    public boolean hasMatchregexp() {
      return ((bitField0_ & 0x00001000) != 0);
    }

    /**
     * <pre>
     * If specified, all (non-null) values of this column must match this regexp.
     * </pre>
     *
     * <code>optional string matchregexp = 9;</code>
     */
    public java.lang.String getMatchregexp() {
      java.lang.Object ref = matchregexp_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          matchregexp_ = s;
        }
        return s;
      }
    }

    /**
     * <pre>
     * If specified, all (non-null) values of this column must match this regexp.
     * </pre>
     *
     * <code>optional string matchregexp = 9;</code>
     */
    public com.google.protobuf.ByteString
    getMatchregexpBytes() {
      java.lang.Object ref = matchregexp_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
                com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
        matchregexp_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UNIQUEVALUES_FIELD_NUMBER = 10;
    private boolean uniquevalues_;

    /**
     * <pre>
     * These fields are syntactic sugar for testing properties of the key
     * consisting of only this column. See SupersetKeySpecProto for more.
     * </pre>
     *
     * <code>optional bool uniquevalues = 10 [default = false];</code>
     */
    public boolean hasUniquevalues() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * These fields are syntactic sugar for testing properties of the key
     * consisting of only this column. See SupersetKeySpecProto for more.
     * </pre>
     *
     * <code>optional bool uniquevalues = 10 [default = false];</code>
     */
    public boolean getUniquevalues() {
      return uniquevalues_;
    }

    public static final int SUPERSETKEY_FIELD_NUMBER = 11;
    private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto> supersetkey_;

    /**
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
     */
    public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto> getSupersetkeyList() {
      return supersetkey_;
    }

    /**
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
     */
    public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder>
    getSupersetkeyOrBuilderList() {
      return supersetkey_;
    }

    /**
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
     */
    public int getSupersetkeyCount() {
      return supersetkey_.size();
    }

    /**
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto getSupersetkey(int index) {
      return supersetkey_.get(index);
    }
    /**
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder getSupersetkeyOrBuilder(
        int index) {
      return supersetkey_.get(index);
    }

    public static final int CACHE_FIELD_NUMBER = 12;
    private org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto cache_;
    /**
     * <pre>
     * Defines the value caching strategy for this column.  This can be useful
     * for INT and FLOAT columns where repeatedly converting raw CSV string
     * values to native types carries a performance hit.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
     */
    public boolean hasCache() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * Defines the value caching strategy for this column.  This can be useful
     * for INT and FLOAT columns where repeatedly converting raw CSV string
     * values to native types carries a performance hit.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto getCache() {
      return cache_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance() : cache_;
    }
    /**
     * <pre>
     * Defines the value caching strategy for this column.  This can be useful
     * for INT and FLOAT columns where repeatedly converting raw CSV string
     * values to native types carries a performance hit.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder getCacheOrBuilder() {
      return cache_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance() : cache_;
    }

    public static final int FIELD_NUMBER_FIELD_NUMBER = 18;
    private int fieldNumber_;
    /**
     * <pre>
     * Field number for if the spec containing this column is converted to a
     * protobuf message. Must be unique within the spec and &gt;= 2.
     * </pre>
     *
     * <code>optional int32 field_number = 18;</code>
     */
    public boolean hasFieldNumber() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * Field number for if the spec containing this column is converted to a
     * protobuf message. Must be unique within the spec and &gt;= 2.
     * </pre>
     *
     * <code>optional int32 field_number = 18;</code>
     */
    public int getFieldNumber() {
      return fieldNumber_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasName()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (hasType()) {
        if (!getType().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getNamedvalueCount(); i++) {
        if (!getNamedvalue(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getSupersetkeyCount(); i++) {
        if (!getSupersetkey(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, originalname_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeInt32(3, number_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeBool(4, required_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, nullvalue_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeMessage(6, getType());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeInt32(7, intmin_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeInt32(8, intmax_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 9, matchregexp_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeBool(10, uniquevalues_);
      }
      for (int i = 0; i < supersetkey_.size(); i++) {
        output.writeMessage(11, supersetkey_.get(i));
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        output.writeMessage(12, getCache());
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeFloat(13, floatmin_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeFloat(14, floatmax_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeBool(15, inheritfields_);
      }
      for (int i = 0; i < namedvalue_.size(); i++) {
        output.writeMessage(16, namedvalue_.get(i));
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBool(17, valueRequired_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        output.writeInt32(18, fieldNumber_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, originalname_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, number_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, required_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, nullvalue_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(6, getType());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
                .computeInt32Size(7, intmin_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(8, intmax_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, matchregexp_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(10, uniquevalues_);
      }
      for (int i = 0; i < supersetkey_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, supersetkey_.get(i));
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(12, getCache());
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(13, floatmin_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(14, floatmax_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(15, inheritfields_);
      }
      for (int i = 0; i < namedvalue_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(16, namedvalue_.get(i));
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(17, valueRequired_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(18, fieldNumber_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto)) {
        return super.equals(obj);
      }
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto other = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasOriginalname() != other.hasOriginalname()) return false;
      if (hasOriginalname()) {
        if (!getOriginalname()
                .equals(other.getOriginalname())) return false;
      }
      if (hasNumber() != other.hasNumber()) return false;
      if (hasNumber()) {
        if (getNumber()
                != other.getNumber()) return false;
      }
      if (hasInheritfields() != other.hasInheritfields()) return false;
      if (hasInheritfields()) {
        if (getInheritfields()
            != other.getInheritfields()) return false;
      }
      if (hasRequired() != other.hasRequired()) return false;
      if (hasRequired()) {
        if (getRequired()
            != other.getRequired()) return false;
      }
      if (hasNullvalue() != other.hasNullvalue()) return false;
      if (hasNullvalue()) {
        if (!getNullvalue()
            .equals(other.getNullvalue())) return false;
      }
      if (hasValueRequired() != other.hasValueRequired()) return false;
      if (hasValueRequired()) {
        if (getValueRequired()
            != other.getValueRequired()) return false;
      }
      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (hasIntmin() != other.hasIntmin()) return false;
      if (hasIntmin()) {
        if (getIntmin()
            != other.getIntmin()) return false;
      }
      if (hasIntmax() != other.hasIntmax()) return false;
      if (hasIntmax()) {
        if (getIntmax()
            != other.getIntmax()) return false;
      }
      if (hasFloatmin() != other.hasFloatmin()) return false;
      if (hasFloatmin()) {
        if (java.lang.Float.floatToIntBits(getFloatmin())
            != java.lang.Float.floatToIntBits(
                other.getFloatmin())) return false;
      }
      if (hasFloatmax() != other.hasFloatmax()) return false;
      if (hasFloatmax()) {
        if (java.lang.Float.floatToIntBits(getFloatmax())
            != java.lang.Float.floatToIntBits(
                other.getFloatmax())) return false;
      }
      if (!getNamedvalueList()
          .equals(other.getNamedvalueList())) return false;
      if (hasMatchregexp() != other.hasMatchregexp()) return false;
      if (hasMatchregexp()) {
        if (!getMatchregexp()
            .equals(other.getMatchregexp())) return false;
      }
      if (hasUniquevalues() != other.hasUniquevalues()) return false;
      if (hasUniquevalues()) {
        if (getUniquevalues()
            != other.getUniquevalues()) return false;
      }
      if (!getSupersetkeyList()
          .equals(other.getSupersetkeyList())) return false;
      if (hasCache() != other.hasCache()) return false;
      if (hasCache()) {
        if (!getCache()
                .equals(other.getCache())) return false;
      }
      if (hasFieldNumber() != other.hasFieldNumber()) return false;
      if (hasFieldNumber()) {
        if (getFieldNumber()
                != other.getFieldNumber()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasOriginalname()) {
        hash = (37 * hash) + ORIGINALNAME_FIELD_NUMBER;
        hash = (53 * hash) + getOriginalname().hashCode();
      }
      if (hasNumber()) {
        hash = (37 * hash) + NUMBER_FIELD_NUMBER;
        hash = (53 * hash) + getNumber();
      }
      if (hasInheritfields()) {
        hash = (37 * hash) + INHERITFIELDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getInheritfields());
      }
      if (hasRequired()) {
        hash = (37 * hash) + REQUIRED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getRequired());
      }
      if (hasNullvalue()) {
        hash = (37 * hash) + NULLVALUE_FIELD_NUMBER;
        hash = (53 * hash) + getNullvalue().hashCode();
      }
      if (hasValueRequired()) {
        hash = (37 * hash) + VALUE_REQUIRED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getValueRequired());
      }
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasIntmin()) {
        hash = (37 * hash) + INTMIN_FIELD_NUMBER;
        hash = (53 * hash) + getIntmin();
      }
      if (hasIntmax()) {
        hash = (37 * hash) + INTMAX_FIELD_NUMBER;
        hash = (53 * hash) + getIntmax();
      }
      if (hasFloatmin()) {
        hash = (37 * hash) + FLOATMIN_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
                getFloatmin());
      }
      if (hasFloatmax()) {
        hash = (37 * hash) + FLOATMAX_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
                getFloatmax());
      }
      if (getNamedvalueCount() > 0) {
        hash = (37 * hash) + NAMEDVALUE_FIELD_NUMBER;
        hash = (53 * hash) + getNamedvalueList().hashCode();
      }
      if (hasMatchregexp()) {
        hash = (37 * hash) + MATCHREGEXP_FIELD_NUMBER;
        hash = (53 * hash) + getMatchregexp().hashCode();
      }
      if (hasUniquevalues()) {
        hash = (37 * hash) + UNIQUEVALUES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getUniquevalues());
      }
      if (getSupersetkeyCount() > 0) {
        hash = (37 * hash) + SUPERSETKEY_FIELD_NUMBER;
        hash = (53 * hash) + getSupersetkeyList().hashCode();
      }
      if (hasCache()) {
        hash = (37 * hash) + CACHE_FIELD_NUMBER;
        hash = (53 * hash) + getCache().hashCode();
      }
      if (hasFieldNumber()) {
        hash = (37 * hash) + FIELD_NUMBER_FIELD_NUMBER;
        hash = (53 * hash) + getFieldNumber();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csvspec.ColumnSpecProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csvspec.ColumnSpecProto)
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnSpecProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnSpecProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder.class);
      }

      // Construct using org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getTypeFieldBuilder();
          getNamedvalueFieldBuilder();
          getSupersetkeyFieldBuilder();
          getCacheFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        originalname_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        number_ = 0;
        bitField0_ = (bitField0_ & ~0x00000004);
        inheritfields_ = false;
        bitField0_ = (bitField0_ & ~0x00000008);
        required_ = true;
        bitField0_ = (bitField0_ & ~0x00000010);
        nullvalue_ = "";
        bitField0_ = (bitField0_ & ~0x00000020);
        valueRequired_ = false;
        bitField0_ = (bitField0_ & ~0x00000040);
        if (typeBuilder_ == null) {
          type_ = null;
        } else {
          typeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        intmin_ = 0;
        bitField0_ = (bitField0_ & ~0x00000100);
        intmax_ = 0;
        bitField0_ = (bitField0_ & ~0x00000200);
        floatmin_ = 0F;
        bitField0_ = (bitField0_ & ~0x00000400);
        floatmax_ = 0F;
        bitField0_ = (bitField0_ & ~0x00000800);
        if (namedvalueBuilder_ == null) {
          namedvalue_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00001000);
        } else {
          namedvalueBuilder_.clear();
        }
        matchregexp_ = "";
        bitField0_ = (bitField0_ & ~0x00002000);
        uniquevalues_ = false;
        bitField0_ = (bitField0_ & ~0x00004000);
        if (supersetkeyBuilder_ == null) {
          supersetkey_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00008000);
        } else {
          supersetkeyBuilder_.clear();
        }
        if (cacheBuilder_ == null) {
          cache_ = null;
        } else {
          cacheBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00010000);
        fieldNumber_ = 0;
        bitField0_ = (bitField0_ & ~0x00020000);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_ColumnSpecProto_descriptor;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto getDefaultInstanceForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto build() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto buildPartial() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto result = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          to_bitField0_ |= 0x00000002;
        }
        result.originalname_ = originalname_;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.number_ = number_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.inheritfields_ = inheritfields_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          to_bitField0_ |= 0x00000010;
        }
        result.required_ = required_;
        if (((from_bitField0_ & 0x00000020) != 0)) {
          to_bitField0_ |= 0x00000020;
        }
        result.nullvalue_ = nullvalue_;
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.valueRequired_ = valueRequired_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          if (typeBuilder_ == null) {
            result.type_ = type_;
          } else {
            result.type_ = typeBuilder_.build();
          }
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.intmin_ = intmin_;
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.intmax_ = intmax_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.floatmin_ = floatmin_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.floatmax_ = floatmax_;
          to_bitField0_ |= 0x00000800;
        }
        if (namedvalueBuilder_ == null) {
          if (((bitField0_ & 0x00001000) != 0)) {
            namedvalue_ = java.util.Collections.unmodifiableList(namedvalue_);
            bitField0_ = (bitField0_ & ~0x00001000);
          }
          result.namedvalue_ = namedvalue_;
        } else {
          result.namedvalue_ = namedvalueBuilder_.build();
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          to_bitField0_ |= 0x00001000;
        }
        result.matchregexp_ = matchregexp_;
        if (((from_bitField0_ & 0x00004000) != 0)) {
          result.uniquevalues_ = uniquevalues_;
          to_bitField0_ |= 0x00002000;
        }
        if (supersetkeyBuilder_ == null) {
          if (((bitField0_ & 0x00008000) != 0)) {
            supersetkey_ = java.util.Collections.unmodifiableList(supersetkey_);
            bitField0_ = (bitField0_ & ~0x00008000);
          }
          result.supersetkey_ = supersetkey_;
        } else {
          result.supersetkey_ = supersetkeyBuilder_.build();
        }
        if (((from_bitField0_ & 0x00010000) != 0)) {
          if (cacheBuilder_ == null) {
            result.cache_ = cache_;
          } else {
            result.cache_ = cacheBuilder_.build();
          }
          to_bitField0_ |= 0x00004000;
        }
        if (((from_bitField0_ & 0x00020000) != 0)) {
          result.fieldNumber_ = fieldNumber_;
          to_bitField0_ |= 0x00008000;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto) {
          return mergeFrom((org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto other) {
        if (other == org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasOriginalname()) {
          bitField0_ |= 0x00000002;
          originalname_ = other.originalname_;
          onChanged();
        }
        if (other.hasNumber()) {
          setNumber(other.getNumber());
        }
        if (other.hasInheritfields()) {
          setInheritfields(other.getInheritfields());
        }
        if (other.hasRequired()) {
          setRequired(other.getRequired());
        }
        if (other.hasNullvalue()) {
          bitField0_ |= 0x00000020;
          nullvalue_ = other.nullvalue_;
          onChanged();
        }
        if (other.hasValueRequired()) {
          setValueRequired(other.getValueRequired());
        }
        if (other.hasType()) {
          mergeType(other.getType());
        }
        if (other.hasIntmin()) {
          setIntmin(other.getIntmin());
        }
        if (other.hasIntmax()) {
          setIntmax(other.getIntmax());
        }
        if (other.hasFloatmin()) {
          setFloatmin(other.getFloatmin());
        }
        if (other.hasFloatmax()) {
          setFloatmax(other.getFloatmax());
        }
        if (namedvalueBuilder_ == null) {
          if (!other.namedvalue_.isEmpty()) {
            if (namedvalue_.isEmpty()) {
              namedvalue_ = other.namedvalue_;
              bitField0_ = (bitField0_ & ~0x00001000);
            } else {
              ensureNamedvalueIsMutable();
              namedvalue_.addAll(other.namedvalue_);
            }
            onChanged();
          }
        } else {
          if (!other.namedvalue_.isEmpty()) {
            if (namedvalueBuilder_.isEmpty()) {
              namedvalueBuilder_.dispose();
              namedvalueBuilder_ = null;
              namedvalue_ = other.namedvalue_;
              bitField0_ = (bitField0_ & ~0x00001000);
              namedvalueBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getNamedvalueFieldBuilder() : null;
            } else {
              namedvalueBuilder_.addAllMessages(other.namedvalue_);
            }
          }
        }
        if (other.hasMatchregexp()) {
          bitField0_ |= 0x00002000;
          matchregexp_ = other.matchregexp_;
          onChanged();
        }
        if (other.hasUniquevalues()) {
          setUniquevalues(other.getUniquevalues());
        }
        if (supersetkeyBuilder_ == null) {
          if (!other.supersetkey_.isEmpty()) {
            if (supersetkey_.isEmpty()) {
              supersetkey_ = other.supersetkey_;
              bitField0_ = (bitField0_ & ~0x00008000);
            } else {
              ensureSupersetkeyIsMutable();
              supersetkey_.addAll(other.supersetkey_);
            }
            onChanged();
          }
        } else {
          if (!other.supersetkey_.isEmpty()) {
            if (supersetkeyBuilder_.isEmpty()) {
              supersetkeyBuilder_.dispose();
              supersetkeyBuilder_ = null;
              supersetkey_ = other.supersetkey_;
              bitField0_ = (bitField0_ & ~0x00008000);
              supersetkeyBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSupersetkeyFieldBuilder() : null;
            } else {
              supersetkeyBuilder_.addAllMessages(other.supersetkey_);
            }
          }
        }
        if (other.hasCache()) {
          mergeCache(other.getCache());
        }
        if (other.hasFieldNumber()) {
          setFieldNumber(other.getFieldNumber());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasName()) {
          return false;
        }
        if (hasType()) {
          if (!getType().isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getNamedvalueCount(); i++) {
          if (!getNamedvalue(i).isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getSupersetkeyCount(); i++) {
          if (!getSupersetkey(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * This is the name to be used for this column. This field can be used in two
       * ways:
       * - To reference a column name given in the first row of the csv file.
       * - To introduce a new name for the column, in that case, the original name
       *   (the name given in the first row of the csv file) or a column number
       *   (starting on 0) must be given as well.
       * Note that every column name also is a key name. See KeySpecProto.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }

      /**
       * <pre>
       * This is the name to be used for this column. This field can be used in two
       * ways:
       * - To reference a column name given in the first row of the csv file.
       * - To introduce a new name for the column, in that case, the original name
       *   (the name given in the first row of the csv file) or a column number
       *   (starting on 0) must be given as well.
       * Note that every column name also is a key name. See KeySpecProto.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This is the name to be used for this column. This field can be used in two
       * ways:
       * - To reference a column name given in the first row of the csv file.
       * - To introduce a new name for the column, in that case, the original name
       *   (the name given in the first row of the csv file) or a column number
       *   (starting on 0) must be given as well.
       * Note that every column name also is a key name. See KeySpecProto.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public com.google.protobuf.ByteString
      getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
                  com.google.protobuf.ByteString.copyFromUtf8(
                          (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       * <pre>
       * This is the name to be used for this column. This field can be used in two
       * ways:
       * - To reference a column name given in the first row of the csv file.
       * - To introduce a new name for the column, in that case, the original name
       *   (the name given in the first row of the csv file) or a column number
       *   (starting on 0) must be given as well.
       * Note that every column name also is a key name. See KeySpecProto.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public Builder setName(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is the name to be used for this column. This field can be used in two
       * ways:
       * - To reference a column name given in the first row of the csv file.
       * - To introduce a new name for the column, in that case, the original name
       *   (the name given in the first row of the csv file) or a column number
       *   (starting on 0) must be given as well.
       * Note that every column name also is a key name. See KeySpecProto.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }

      /**
       * <pre>
       * This is the name to be used for this column. This field can be used in two
       * ways:
       * - To reference a column name given in the first row of the csv file.
       * - To introduce a new name for the column, in that case, the original name
       *   (the name given in the first row of the csv file) or a column number
       *   (starting on 0) must be given as well.
       * Note that every column name also is a key name. See KeySpecProto.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object originalname_ = "";
      /**
       * <code>optional string originalname = 2;</code>
       */
      public boolean hasOriginalname() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional string originalname = 2;</code>
       */
      public java.lang.String getOriginalname() {
        java.lang.Object ref = originalname_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            originalname_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string originalname = 2;</code>
       */
      public com.google.protobuf.ByteString
          getOriginalnameBytes() {
        java.lang.Object ref = originalname_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          originalname_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string originalname = 2;</code>
       */
      public Builder setOriginalname(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        originalname_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string originalname = 2;</code>
       */
      public Builder clearOriginalname() {
        bitField0_ = (bitField0_ & ~0x00000002);
        originalname_ = getDefaultInstance().getOriginalname();
        onChanged();
        return this;
      }
      /**
       * <code>optional string originalname = 2;</code>
       */
      public Builder setOriginalnameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        originalname_ = value;
        onChanged();
        return this;
      }

      private int number_ ;
      /**
       * <code>optional int32 number = 3;</code>
       */
      public boolean hasNumber() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional int32 number = 3;</code>
       */
      public int getNumber() {
        return number_;
      }
      /**
       * <code>optional int32 number = 3;</code>
       */
      public Builder setNumber(int value) {
        bitField0_ |= 0x00000004;
        number_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 number = 3;</code>
       */
      public Builder clearNumber() {
        bitField0_ = (bitField0_ & ~0x00000004);
        number_ = 0;
        onChanged();
        return this;
      }

      private boolean inheritfields_ ;
      /**
       * <pre>
       * If a template is used for this spec, and this flag is set true, this column
       * spec will be merged with any corresponding column in the template. If
       * false, the template column will be ignored.
       * </pre>
       *
       * <code>optional bool inheritfields = 15 [default = false];</code>
       */
      public boolean hasInheritfields() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * If a template is used for this spec, and this flag is set true, this column
       * spec will be merged with any corresponding column in the template. If
       * false, the template column will be ignored.
       * </pre>
       *
       * <code>optional bool inheritfields = 15 [default = false];</code>
       */
      public boolean getInheritfields() {
        return inheritfields_;
      }
      /**
       * <pre>
       * If a template is used for this spec, and this flag is set true, this column
       * spec will be merged with any corresponding column in the template. If
       * false, the template column will be ignored.
       * </pre>
       *
       * <code>optional bool inheritfields = 15 [default = false];</code>
       */
      public Builder setInheritfields(boolean value) {
        bitField0_ |= 0x00000008;
        inheritfields_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If a template is used for this spec, and this flag is set true, this column
       * spec will be merged with any corresponding column in the template. If
       * false, the template column will be ignored.
       * </pre>
       *
       * <code>optional bool inheritfields = 15 [default = false];</code>
       */
      public Builder clearInheritfields() {
        bitField0_ = (bitField0_ & ~0x00000008);
        inheritfields_ = false;
        onChanged();
        return this;
      }

      private boolean required_ = true;
      /**
       * <pre>
       * This determines what will happen if this column is missing in the input
       * csv. If true, an error will be flagged, if false, this will be silently
       * ignored and all tests on this column, and any keys that includes this
       * column will be skipped.
       * </pre>
       *
       * <code>optional bool required = 4 [default = true];</code>
       */
      public boolean hasRequired() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * This determines what will happen if this column is missing in the input
       * csv. If true, an error will be flagged, if false, this will be silently
       * ignored and all tests on this column, and any keys that includes this
       * column will be skipped.
       * </pre>
       *
       * <code>optional bool required = 4 [default = true];</code>
       */
      public boolean getRequired() {
        return required_;
      }

      /**
       * <pre>
       * This determines what will happen if this column is missing in the input
       * csv. If true, an error will be flagged, if false, this will be silently
       * ignored and all tests on this column, and any keys that includes this
       * column will be skipped.
       * </pre>
       *
       * <code>optional bool required = 4 [default = true];</code>
       */
      public Builder setRequired(boolean value) {
        bitField0_ |= 0x00000010;
        required_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * This determines what will happen if this column is missing in the input
       * csv. If true, an error will be flagged, if false, this will be silently
       * ignored and all tests on this column, and any keys that includes this
       * column will be skipped.
       * </pre>
       *
       * <code>optional bool required = 4 [default = true];</code>
       */
      public Builder clearRequired() {
        bitField0_ = (bitField0_ & ~0x00000010);
        required_ = true;
        onChanged();
        return this;
      }

      private java.lang.Object nullvalue_ = "";
      /**
       * <pre>
       * If specified, all cells in the column that matches this regexp are
       * considered NULL. These cells will be disregarded in tests. This includes
       * the integer and regexp tests below, as well as tests on properties of keys,
       * see KeySpecProto.
       * </pre>
       *
       * <code>optional string nullvalue = 5 [default = ""];</code>
       */
      public boolean hasNullvalue() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * If specified, all cells in the column that matches this regexp are
       * considered NULL. These cells will be disregarded in tests. This includes
       * the integer and regexp tests below, as well as tests on properties of keys,
       * see KeySpecProto.
       * </pre>
       *
       * <code>optional string nullvalue = 5 [default = ""];</code>
       */
      public java.lang.String getNullvalue() {
        java.lang.Object ref = nullvalue_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            nullvalue_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * If specified, all cells in the column that matches this regexp are
       * considered NULL. These cells will be disregarded in tests. This includes
       * the integer and regexp tests below, as well as tests on properties of keys,
       * see KeySpecProto.
       * </pre>
       *
       * <code>optional string nullvalue = 5 [default = ""];</code>
       */
      public com.google.protobuf.ByteString
          getNullvalueBytes() {
        java.lang.Object ref = nullvalue_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nullvalue_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * If specified, all cells in the column that matches this regexp are
       * considered NULL. These cells will be disregarded in tests. This includes
       * the integer and regexp tests below, as well as tests on properties of keys,
       * see KeySpecProto.
       * </pre>
       *
       * <code>optional string nullvalue = 5 [default = ""];</code>
       */
      public Builder setNullvalue(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000020;
        nullvalue_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, all cells in the column that matches this regexp are
       * considered NULL. These cells will be disregarded in tests. This includes
       * the integer and regexp tests below, as well as tests on properties of keys,
       * see KeySpecProto.
       * </pre>
       *
       * <code>optional string nullvalue = 5 [default = ""];</code>
       */
      public Builder clearNullvalue() {
        bitField0_ = (bitField0_ & ~0x00000020);
        nullvalue_ = getDefaultInstance().getNullvalue();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, all cells in the column that matches this regexp are
       * considered NULL. These cells will be disregarded in tests. This includes
       * the integer and regexp tests below, as well as tests on properties of keys,
       * see KeySpecProto.
       * </pre>
       *
       * <code>optional string nullvalue = 5 [default = ""];</code>
       */
      public Builder setNullvalueBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000020;
        nullvalue_ = value;
        onChanged();
        return this;
      }

      private boolean valueRequired_ ;
      /**
       * <pre>
       * This determines what will happen if a row value of this column is null
       * (i.e. equal to the nullvalue field) in the input csv. If true, a
       * MISSING_VALUE error will be flagged.
       * </pre>
       *
       * <code>optional bool value_required = 17 [default = false];</code>
       */
      public boolean hasValueRequired() {
        return ((bitField0_ & 0x00000040) != 0);
      }

      /**
       * <pre>
       * This determines what will happen if a row value of this column is null
       * (i.e. equal to the nullvalue field) in the input csv. If true, a
       * MISSING_VALUE error will be flagged.
       * </pre>
       *
       * <code>optional bool value_required = 17 [default = false];</code>
       */
      public boolean getValueRequired() {
        return valueRequired_;
      }

      /**
       * <pre>
       * This determines what will happen if a row value of this column is null
       * (i.e. equal to the nullvalue field) in the input csv. If true, a
       * MISSING_VALUE error will be flagged.
       * </pre>
       *
       * <code>optional bool value_required = 17 [default = false];</code>
       */
      public Builder setValueRequired(boolean value) {
        bitField0_ |= 0x00000040;
        valueRequired_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * This determines what will happen if a row value of this column is null
       * (i.e. equal to the nullvalue field) in the input csv. If true, a
       * MISSING_VALUE error will be flagged.
       * </pre>
       *
       * <code>optional bool value_required = 17 [default = false];</code>
       */
      public Builder clearValueRequired() {
        bitField0_ = (bitField0_ & ~0x00000040);
        valueRequired_ = false;
        onChanged();
        return this;
      }

      private org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType type_;
      private com.google.protobuf.SingleFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputTypeOrBuilder> typeBuilder_;

      /**
       * <pre>
       * The input type of the column. See enum definition for detailed requirements
       * on each format.
       * </pre>
       *
       * <code>optional .csvspec.ColumnInputType type = 6;</code>
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000080) != 0);
      }

      /**
       * <pre>
       * The input type of the column. See enum definition for detailed requirements
       * on each format.
       * </pre>
       *
       * <code>optional .csvspec.ColumnInputType type = 6;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType getType() {
        if (typeBuilder_ == null) {
          return type_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.getDefaultInstance() : type_;
        } else {
          return typeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The input type of the column. See enum definition for detailed requirements
       * on each format.
       * </pre>
       *
       * <code>optional .csvspec.ColumnInputType type = 6;</code>
       */
      public Builder setType(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType value) {
        if (typeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          typeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        return this;
      }

      /**
       * <pre>
       * The input type of the column. See enum definition for detailed requirements
       * on each format.
       * </pre>
       *
       * <code>optional .csvspec.ColumnInputType type = 6;</code>
       */
      public Builder setType(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.Builder builderForValue) {
        if (typeBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          typeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        return this;
      }

      /**
       * <pre>
       * The input type of the column. See enum definition for detailed requirements
       * on each format.
       * </pre>
       *
       * <code>optional .csvspec.ColumnInputType type = 6;</code>
       */
      public Builder mergeType(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType value) {
        if (typeBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0) &&
                  type_ != null &&
                  type_ != org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.getDefaultInstance()) {
            type_ =
                    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.newBuilder(type_).mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          typeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000080;
        return this;
      }

      /**
       * <pre>
       * The input type of the column. See enum definition for detailed requirements
       * on each format.
       * </pre>
       *
       * <code>optional .csvspec.ColumnInputType type = 6;</code>
       */
      public Builder clearType() {
        if (typeBuilder_ == null) {
          type_ = null;
          onChanged();
        } else {
          typeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        return this;
      }
      /**
       * <pre>
       * The input type of the column. See enum definition for detailed requirements
       * on each format.
       * </pre>
       *
       * <code>optional .csvspec.ColumnInputType type = 6;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.Builder getTypeBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return getTypeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The input type of the column. See enum definition for detailed requirements
       * on each format.
       * </pre>
       *
       * <code>optional .csvspec.ColumnInputType type = 6;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputTypeOrBuilder getTypeOrBuilder() {
        if (typeBuilder_ != null) {
          return typeBuilder_.getMessageOrBuilder();
        } else {
          return type_ == null ?
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.getDefaultInstance() : type_;
        }
      }
      /**
       * <pre>
       * The input type of the column. See enum definition for detailed requirements
       * on each format.
       * </pre>
       *
       * <code>optional .csvspec.ColumnInputType type = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputTypeOrBuilder> 
          getTypeFieldBuilder() {
        if (typeBuilder_ == null) {
          typeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputType.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnInputTypeOrBuilder>(
                  getType(),
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        return typeBuilder_;
      }

      private int intmin_ ;
      /**
       * <pre>
       * Specifies max/min values (inclusive) for integer types.
       * </pre>
       *
       * <code>optional int32 intmin = 7;</code>
       */
      public boolean hasIntmin() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Specifies max/min values (inclusive) for integer types.
       * </pre>
       *
       * <code>optional int32 intmin = 7;</code>
       */
      public int getIntmin() {
        return intmin_;
      }
      /**
       * <pre>
       * Specifies max/min values (inclusive) for integer types.
       * </pre>
       *
       * <code>optional int32 intmin = 7;</code>
       */
      public Builder setIntmin(int value) {
        bitField0_ |= 0x00000100;
        intmin_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies max/min values (inclusive) for integer types.
       * </pre>
       *
       * <code>optional int32 intmin = 7;</code>
       */
      public Builder clearIntmin() {
        bitField0_ = (bitField0_ & ~0x00000100);
        intmin_ = 0;
        onChanged();
        return this;
      }

      private int intmax_;

      /**
       * <code>optional int32 intmax = 8;</code>
       */
      public boolean hasIntmax() {
        return ((bitField0_ & 0x00000200) != 0);
      }

      /**
       * <code>optional int32 intmax = 8;</code>
       */
      public int getIntmax() {
        return intmax_;
      }

      /**
       * <code>optional int32 intmax = 8;</code>
       */
      public Builder setIntmax(int value) {
        bitField0_ |= 0x00000200;
        intmax_ = value;
        onChanged();
        return this;
      }

      /**
       * <code>optional int32 intmax = 8;</code>
       */
      public Builder clearIntmax() {
        bitField0_ = (bitField0_ & ~0x00000200);
        intmax_ = 0;
        onChanged();
        return this;
      }

      private float floatmin_;

      /**
       * <pre>
       * Specifies max/min values for float types.
       * </pre>
       *
       * <code>optional float floatmin = 13;</code>
       */
      public boolean hasFloatmin() {
        return ((bitField0_ & 0x00000400) != 0);
      }

      /**
       * <pre>
       * Specifies max/min values for float types.
       * </pre>
       *
       * <code>optional float floatmin = 13;</code>
       */
      public float getFloatmin() {
        return floatmin_;
      }

      /**
       * <pre>
       * Specifies max/min values for float types.
       * </pre>
       *
       * <code>optional float floatmin = 13;</code>
       */
      public Builder setFloatmin(float value) {
        bitField0_ |= 0x00000400;
        floatmin_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies max/min values for float types.
       * </pre>
       *
       * <code>optional float floatmin = 13;</code>
       */
      public Builder clearFloatmin() {
        bitField0_ = (bitField0_ & ~0x00000400);
        floatmin_ = 0F;
        onChanged();
        return this;
      }

      private float floatmax_;

      /**
       * <code>optional float floatmax = 14;</code>
       */
      public boolean hasFloatmax() {
        return ((bitField0_ & 0x00000800) != 0);
      }

      /**
       * <code>optional float floatmax = 14;</code>
       */
      public float getFloatmax() {
        return floatmax_;
      }

      /**
       * <code>optional float floatmax = 14;</code>
       */
      public Builder setFloatmax(float value) {
        bitField0_ |= 0x00000800;
        floatmax_ = value;
        onChanged();
        return this;
      }

      /**
       * <code>optional float floatmax = 14;</code>
       */
      public Builder clearFloatmax() {
        bitField0_ = (bitField0_ & ~0x00000800);
        floatmax_ = 0F;
        onChanged();
        return this;
      }

      private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> namedvalue_ =
              java.util.Collections.emptyList();

      private void ensureNamedvalueIsMutable() {
        if (!((bitField0_ & 0x00001000) != 0)) {
          namedvalue_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto>(namedvalue_);
          bitField0_ |= 0x00001000;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder> namedvalueBuilder_;

      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> getNamedvalueList() {
        if (namedvalueBuilder_ == null) {
          return java.util.Collections.unmodifiableList(namedvalue_);
        } else {
          return namedvalueBuilder_.getMessageList();
        }
      }

      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public int getNamedvalueCount() {
        if (namedvalueBuilder_ == null) {
          return namedvalue_.size();
        } else {
          return namedvalueBuilder_.getCount();
        }
      }

      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto getNamedvalue(int index) {
        if (namedvalueBuilder_ == null) {
          return namedvalue_.get(index);
        } else {
          return namedvalueBuilder_.getMessage(index);
        }
      }

      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder setNamedvalue(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto value) {
        if (namedvalueBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNamedvalueIsMutable();
          namedvalue_.set(index, value);
          onChanged();
        } else {
          namedvalueBuilder_.setMessage(index, value);
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder setNamedvalue(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder builderForValue) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          namedvalue_.set(index, builderForValue.build());
          onChanged();
        } else {
          namedvalueBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder addNamedvalue(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto value) {
        if (namedvalueBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNamedvalueIsMutable();
          namedvalue_.add(value);
          onChanged();
        } else {
          namedvalueBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder addNamedvalue(
          int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto value) {
        if (namedvalueBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNamedvalueIsMutable();
          namedvalue_.add(index, value);
          onChanged();
        } else {
          namedvalueBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder addNamedvalue(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder builderForValue) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          namedvalue_.add(builderForValue.build());
          onChanged();
        } else {
          namedvalueBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder addNamedvalue(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder builderForValue) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          namedvalue_.add(index, builderForValue.build());
          onChanged();
        } else {
          namedvalueBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder addAllNamedvalue(
              java.lang.Iterable<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> values) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
                  values, namedvalue_);
          onChanged();
        } else {
          namedvalueBuilder_.addAllMessages(values);
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder clearNamedvalue() {
        if (namedvalueBuilder_ == null) {
          namedvalue_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00001000);
          onChanged();
        } else {
          namedvalueBuilder_.clear();
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder removeNamedvalue(int index) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          namedvalue_.remove(index);
          onChanged();
        } else {
          namedvalueBuilder_.remove(index);
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder getNamedvalueBuilder(
              int index) {
        return getNamedvalueFieldBuilder().getBuilder(index);
      }

      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder getNamedvalueOrBuilder(
              int index) {
        if (namedvalueBuilder_ == null) {
          return namedvalue_.get(index);
        } else {
          return namedvalueBuilder_.getMessageOrBuilder(index);
        }
      }

      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder> 
           getNamedvalueOrBuilderList() {
        if (namedvalueBuilder_ != null) {
          return namedvalueBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(namedvalue_);
        }
      }
      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder addNamedvalueBuilder() {
        return getNamedvalueFieldBuilder().addBuilder(
            org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder addNamedvalueBuilder(
          int index) {
        return getNamedvalueFieldBuilder().addBuilder(
            index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.getDefaultInstance());
      }

      /**
       * <pre>
       * Specifies names for certain values in this column, see message definition.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder>
      getNamedvalueBuilderList() {
        return getNamedvalueFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder>
      getNamedvalueFieldBuilder() {
        if (namedvalueBuilder_ == null) {
          namedvalueBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder>(
                  namedvalue_,
                  ((bitField0_ & 0x00001000) != 0),
                  getParentForChildren(),
                  isClean());
          namedvalue_ = null;
        }
        return namedvalueBuilder_;
      }

      private java.lang.Object matchregexp_ = "";
      /**
       * <pre>
       * If specified, all (non-null) values of this column must match this regexp.
       * </pre>
       *
       * <code>optional string matchregexp = 9;</code>
       */
      public boolean hasMatchregexp() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * If specified, all (non-null) values of this column must match this regexp.
       * </pre>
       *
       * <code>optional string matchregexp = 9;</code>
       */
      public java.lang.String getMatchregexp() {
        java.lang.Object ref = matchregexp_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            matchregexp_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * If specified, all (non-null) values of this column must match this regexp.
       * </pre>
       *
       * <code>optional string matchregexp = 9;</code>
       */
      public com.google.protobuf.ByteString
      getMatchregexpBytes() {
        java.lang.Object ref = matchregexp_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
                  com.google.protobuf.ByteString.copyFromUtf8(
                          (java.lang.String) ref);
          matchregexp_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       * <pre>
       * If specified, all (non-null) values of this column must match this regexp.
       * </pre>
       *
       * <code>optional string matchregexp = 9;</code>
       */
      public Builder setMatchregexp(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00002000;
        matchregexp_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * If specified, all (non-null) values of this column must match this regexp.
       * </pre>
       *
       * <code>optional string matchregexp = 9;</code>
       */
      public Builder clearMatchregexp() {
        bitField0_ = (bitField0_ & ~0x00002000);
        matchregexp_ = getDefaultInstance().getMatchregexp();
        onChanged();
        return this;
      }

      /**
       * <pre>
       * If specified, all (non-null) values of this column must match this regexp.
       * </pre>
       *
       * <code>optional string matchregexp = 9;</code>
       */
      public Builder setMatchregexpBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00002000;
        matchregexp_ = value;
        onChanged();
        return this;
      }

      private boolean uniquevalues_;

      /**
       * <pre>
       * These fields are syntactic sugar for testing properties of the key
       * consisting of only this column. See SupersetKeySpecProto for more.
       * </pre>
       *
       * <code>optional bool uniquevalues = 10 [default = false];</code>
       */
      public boolean hasUniquevalues() {
        return ((bitField0_ & 0x00004000) != 0);
      }

      /**
       * <pre>
       * These fields are syntactic sugar for testing properties of the key
       * consisting of only this column. See SupersetKeySpecProto for more.
       * </pre>
       *
       * <code>optional bool uniquevalues = 10 [default = false];</code>
       */
      public boolean getUniquevalues() {
        return uniquevalues_;
      }

      /**
       * <pre>
       * These fields are syntactic sugar for testing properties of the key
       * consisting of only this column. See SupersetKeySpecProto for more.
       * </pre>
       *
       * <code>optional bool uniquevalues = 10 [default = false];</code>
       */
      public Builder setUniquevalues(boolean value) {
        bitField0_ |= 0x00004000;
        uniquevalues_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * These fields are syntactic sugar for testing properties of the key
       * consisting of only this column. See SupersetKeySpecProto for more.
       * </pre>
       *
       * <code>optional bool uniquevalues = 10 [default = false];</code>
       */
      public Builder clearUniquevalues() {
        bitField0_ = (bitField0_ & ~0x00004000);
        uniquevalues_ = false;
        onChanged();
        return this;
      }

      private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto> supersetkey_ =
              java.util.Collections.emptyList();

      private void ensureSupersetkeyIsMutable() {
        if (!((bitField0_ & 0x00008000) != 0)) {
          supersetkey_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto>(supersetkey_);
          bitField0_ |= 0x00008000;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder> supersetkeyBuilder_;

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto> getSupersetkeyList() {
        if (supersetkeyBuilder_ == null) {
          return java.util.Collections.unmodifiableList(supersetkey_);
        } else {
          return supersetkeyBuilder_.getMessageList();
        }
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public int getSupersetkeyCount() {
        if (supersetkeyBuilder_ == null) {
          return supersetkey_.size();
        } else {
          return supersetkeyBuilder_.getCount();
        }
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto getSupersetkey(int index) {
        if (supersetkeyBuilder_ == null) {
          return supersetkey_.get(index);
        } else {
          return supersetkeyBuilder_.getMessage(index);
        }
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public Builder setSupersetkey(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto value) {
        if (supersetkeyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSupersetkeyIsMutable();
          supersetkey_.set(index, value);
          onChanged();
        } else {
          supersetkeyBuilder_.setMessage(index, value);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public Builder setSupersetkey(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder builderForValue) {
        if (supersetkeyBuilder_ == null) {
          ensureSupersetkeyIsMutable();
          supersetkey_.set(index, builderForValue.build());
          onChanged();
        } else {
          supersetkeyBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public Builder addSupersetkey(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto value) {
        if (supersetkeyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSupersetkeyIsMutable();
          supersetkey_.add(value);
          onChanged();
        } else {
          supersetkeyBuilder_.addMessage(value);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public Builder addSupersetkey(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto value) {
        if (supersetkeyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSupersetkeyIsMutable();
          supersetkey_.add(index, value);
          onChanged();
        } else {
          supersetkeyBuilder_.addMessage(index, value);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public Builder addSupersetkey(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder builderForValue) {
        if (supersetkeyBuilder_ == null) {
          ensureSupersetkeyIsMutable();
          supersetkey_.add(builderForValue.build());
          onChanged();
        } else {
          supersetkeyBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public Builder addSupersetkey(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder builderForValue) {
        if (supersetkeyBuilder_ == null) {
          ensureSupersetkeyIsMutable();
          supersetkey_.add(index, builderForValue.build());
          onChanged();
        } else {
          supersetkeyBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public Builder addAllSupersetkey(
              java.lang.Iterable<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto> values) {
        if (supersetkeyBuilder_ == null) {
          ensureSupersetkeyIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
                  values, supersetkey_);
          onChanged();
        } else {
          supersetkeyBuilder_.addAllMessages(values);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public Builder clearSupersetkey() {
        if (supersetkeyBuilder_ == null) {
          supersetkey_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00008000);
          onChanged();
        } else {
          supersetkeyBuilder_.clear();
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public Builder removeSupersetkey(int index) {
        if (supersetkeyBuilder_ == null) {
          ensureSupersetkeyIsMutable();
          supersetkey_.remove(index);
          onChanged();
        } else {
          supersetkeyBuilder_.remove(index);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder getSupersetkeyBuilder(
              int index) {
        return getSupersetkeyFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder getSupersetkeyOrBuilder(
          int index) {
        if (supersetkeyBuilder_ == null) {
          return supersetkey_.get(index);  } else {
          return supersetkeyBuilder_.getMessageOrBuilder(index);
        }
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder>
      getSupersetkeyOrBuilderList() {
        if (supersetkeyBuilder_ != null) {
          return supersetkeyBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(supersetkey_);
        }
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder addSupersetkeyBuilder() {
        return getSupersetkeyFieldBuilder().addBuilder(
                org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.getDefaultInstance());
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder addSupersetkeyBuilder(
              int index) {
        return getSupersetkeyFieldBuilder().addBuilder(
                index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.getDefaultInstance());
      }

      /**
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 11;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder>
      getSupersetkeyBuilderList() {
        return getSupersetkeyFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder>
      getSupersetkeyFieldBuilder() {
        if (supersetkeyBuilder_ == null) {
          supersetkeyBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder>(
                  supersetkey_,
                  ((bitField0_ & 0x00008000) != 0),
                  getParentForChildren(),
                  isClean());
          supersetkey_ = null;
        }
        return supersetkeyBuilder_;
      }

      private org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto cache_;
      private com.google.protobuf.SingleFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder> cacheBuilder_;
      /**
       * <pre>
       * Defines the value caching strategy for this column.  This can be useful
       * for INT and FLOAT columns where repeatedly converting raw CSV string
       * values to native types carries a performance hit.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
       */
      public boolean hasCache() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <pre>
       * Defines the value caching strategy for this column.  This can be useful
       * for INT and FLOAT columns where repeatedly converting raw CSV string
       * values to native types carries a performance hit.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto getCache() {
        if (cacheBuilder_ == null) {
          return cache_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance() : cache_;
        } else {
          return cacheBuilder_.getMessage();
        }
      }

      /**
       * <pre>
       * Defines the value caching strategy for this column.  This can be useful
       * for INT and FLOAT columns where repeatedly converting raw CSV string
       * values to native types carries a performance hit.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
       */
      public Builder setCache(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto value) {
        if (cacheBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          cache_ = value;
          onChanged();
        } else {
          cacheBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00010000;
        return this;
      }

      /**
       * <pre>
       * Defines the value caching strategy for this column.  This can be useful
       * for INT and FLOAT columns where repeatedly converting raw CSV string
       * values to native types carries a performance hit.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
       */
      public Builder setCache(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder builderForValue) {
        if (cacheBuilder_ == null) {
          cache_ = builderForValue.build();
          onChanged();
        } else {
          cacheBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00010000;
        return this;
      }

      /**
       * <pre>
       * Defines the value caching strategy for this column.  This can be useful
       * for INT and FLOAT columns where repeatedly converting raw CSV string
       * values to native types carries a performance hit.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
       */
      public Builder mergeCache(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto value) {
        if (cacheBuilder_ == null) {
          if (((bitField0_ & 0x00010000) != 0) &&
                  cache_ != null &&
                  cache_ != org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance()) {
            cache_ =
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.newBuilder(cache_).mergeFrom(value).buildPartial();
          } else {
            cache_ = value;
          }
          onChanged();
        } else {
          cacheBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00010000;
        return this;
      }
      /**
       * <pre>
       * Defines the value caching strategy for this column.  This can be useful
       * for INT and FLOAT columns where repeatedly converting raw CSV string
       * values to native types carries a performance hit.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
       */
      public Builder clearCache() {
        if (cacheBuilder_ == null) {
          cache_ = null;
          onChanged();
        } else {
          cacheBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00010000);
        return this;
      }
      /**
       * <pre>
       * Defines the value caching strategy for this column.  This can be useful
       * for INT and FLOAT columns where repeatedly converting raw CSV string
       * values to native types carries a performance hit.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder getCacheBuilder() {
        bitField0_ |= 0x00010000;
        onChanged();
        return getCacheFieldBuilder().getBuilder();
      }

      /**
       * <pre>
       * Defines the value caching strategy for this column.  This can be useful
       * for INT and FLOAT columns where repeatedly converting raw CSV string
       * values to native types carries a performance hit.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder getCacheOrBuilder() {
        if (cacheBuilder_ != null) {
          return cacheBuilder_.getMessageOrBuilder();
        } else {
          return cache_ == null ?
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance() : cache_;
        }
      }

      /**
       * <pre>
       * Defines the value caching strategy for this column.  This can be useful
       * for INT and FLOAT columns where repeatedly converting raw CSV string
       * values to native types carries a performance hit.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto cache = 12;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder>
          getCacheFieldBuilder() {
        if (cacheBuilder_ == null) {
          cacheBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder>(
                  getCache(),
                  getParentForChildren(),
                  isClean());
          cache_ = null;
        }
        return cacheBuilder_;
      }

      private int fieldNumber_ ;
      /**
       * <pre>
       * Field number for if the spec containing this column is converted to a
       * protobuf message. Must be unique within the spec and &gt;= 2.
       * </pre>
       *
       * <code>optional int32 field_number = 18;</code>
       */
      public boolean hasFieldNumber() {
        return ((bitField0_ & 0x00020000) != 0);
      }
      /**
       * <pre>
       * Field number for if the spec containing this column is converted to a
       * protobuf message. Must be unique within the spec and &gt;= 2.
       * </pre>
       *
       * <code>optional int32 field_number = 18;</code>
       */
      public int getFieldNumber() {
        return fieldNumber_;
      }
      /**
       * <pre>
       * Field number for if the spec containing this column is converted to a
       * protobuf message. Must be unique within the spec and &gt;= 2.
       * </pre>
       *
       * <code>optional int32 field_number = 18;</code>
       */
      public Builder setFieldNumber(int value) {
        bitField0_ |= 0x00020000;
        fieldNumber_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * Field number for if the spec containing this column is converted to a
       * protobuf message. Must be unique within the spec and &gt;= 2.
       * </pre>
       *
       * <code>optional int32 field_number = 18;</code>
       */
      public Builder clearFieldNumber() {
        bitField0_ = (bitField0_ & ~0x00020000);
        fieldNumber_ = 0;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csvspec.ColumnSpecProto)
    }

    // @@protoc_insertion_point(class_scope:csvspec.ColumnSpecProto)
    private static final org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto();
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ColumnSpecProto>
            PARSER = new com.google.protobuf.AbstractParser<ColumnSpecProto>() {
      @java.lang.Override
      public ColumnSpecProto parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return new ColumnSpecProto(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ColumnSpecProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ColumnSpecProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface KeySpecProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csvspec.KeySpecProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name of this key. Note that each column by default has a 1-column key
     * with the same name. Properties of 1-column keys may be defined directly in
     * the ColumnSpecProto. Key names may not overlap with column names declared
     * in the same CsvSpecProto (this does not apply to column names provided in
     * the input csv header line, that are only used for the originalname field
     * in ColumnSpecProto).
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    boolean hasName();

    /**
     * <pre>
     * The name of this key. Note that each column by default has a 1-column key
     * with the same name. Properties of 1-column keys may be defined directly in
     * the ColumnSpecProto. Key names may not overlap with column names declared
     * in the same CsvSpecProto (this does not apply to column names provided in
     * the input csv header line, that are only used for the originalname field
     * in ColumnSpecProto).
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    java.lang.String getName();

    /**
     * <pre>
     * The name of this key. Note that each column by default has a 1-column key
     * with the same name. Properties of 1-column keys may be defined directly in
     * the ColumnSpecProto. Key names may not overlap with column names declared
     * in the same CsvSpecProto (this does not apply to column names provided in
     * the input csv header line, that are only used for the originalname field
     * in ColumnSpecProto).
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    com.google.protobuf.ByteString
    getNameBytes();

    /**
     * <pre>
     * The tuple of columns that form this key. There must be at least one column.
     * Note that order is significant. All columns listed here must also appear
     * as ColunmSpecProtos in the same CsvSpecProto.
     * </pre>
     *
     * <code>repeated string columnname = 2;</code>
     */
    java.util.List<java.lang.String>
    getColumnnameList();

    /**
     * <pre>
     * The tuple of columns that form this key. There must be at least one column.
     * Note that order is significant. All columns listed here must also appear
     * as ColunmSpecProtos in the same CsvSpecProto.
     * </pre>
     *
     * <code>repeated string columnname = 2;</code>
     */
    int getColumnnameCount();

    /**
     * <pre>
     * The tuple of columns that form this key. There must be at least one column.
     * Note that order is significant. All columns listed here must also appear
     * as ColunmSpecProtos in the same CsvSpecProto.
     * </pre>
     *
     * <code>repeated string columnname = 2;</code>
     */
    java.lang.String getColumnname(int index);

    /**
     * <pre>
     * The tuple of columns that form this key. There must be at least one column.
     * Note that order is significant. All columns listed here must also appear
     * as ColunmSpecProtos in the same CsvSpecProto.
     * </pre>
     *
     * <code>repeated string columnname = 2;</code>
     */
    com.google.protobuf.ByteString
        getColumnnameBytes(int index);

    /**
     * <pre>
     * If true, all value tuples defined by this table and key must be distinct.
     * Rows where some column is null (see CsvColumnSpec) are disregarded.
     * </pre>
     *
     * <code>optional bool uniquevalues = 3 [default = false];</code>
     */
    boolean hasUniquevalues();
    /**
     * <pre>
     * If true, all value tuples defined by this table and key must be distinct.
     * Rows where some column is null (see CsvColumnSpec) are disregarded.
     * </pre>
     *
     * <code>optional bool uniquevalues = 3 [default = false];</code>
     */
    boolean getUniquevalues();

    /**
     * <pre>
     * The set of value tuples defined by the KeySpecProto must be a subset of
     * each of the value sets defined by the keys listed here. This can be used
     * to verify references between two tables.
     * See SupersetKeySpecProto for more information.
     * </pre>
     *
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
     */
    java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto> 
        getSupersetkeyList();
    /**
     * <pre>
     * The set of value tuples defined by the KeySpecProto must be a subset of
     * each of the value sets defined by the keys listed here. This can be used
     * to verify references between two tables.
     * See SupersetKeySpecProto for more information.
     * </pre>
     *
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto getSupersetkey(int index);

    /**
     * <pre>
     * The set of value tuples defined by the KeySpecProto must be a subset of
     * each of the value sets defined by the keys listed here. This can be used
     * to verify references between two tables.
     * See SupersetKeySpecProto for more information.
     * </pre>
     *
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
     */
    int getSupersetkeyCount();

    /**
     * <pre>
     * The set of value tuples defined by the KeySpecProto must be a subset of
     * each of the value sets defined by the keys listed here. This can be used
     * to verify references between two tables.
     * See SupersetKeySpecProto for more information.
     * </pre>
     *
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
     */
    java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder>
    getSupersetkeyOrBuilderList();

    /**
     * <pre>
     * The set of value tuples defined by the KeySpecProto must be a subset of
     * each of the value sets defined by the keys listed here. This can be used
     * to verify references between two tables.
     * See SupersetKeySpecProto for more information.
     * </pre>
     *
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder getSupersetkeyOrBuilder(
            int index);
  }

  /**
   * Protobuf type {@code csvspec.KeySpecProto}
   */
  public static final class KeySpecProto extends
          com.google.protobuf.GeneratedMessageV3 implements
          // @@protoc_insertion_point(message_implements:csvspec.KeySpecProto)
          KeySpecProtoOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use KeySpecProto.newBuilder() to construct.
    private KeySpecProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private KeySpecProto() {
      name_ = "";
      columnname_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      supersetkey_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new KeySpecProto();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private KeySpecProto(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                columnname_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000002;
              }
              columnname_.add(bs);
              break;
            }
            case 24: {
              bitField0_ |= 0x00000002;
              uniquevalues_ = input.readBool();
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) != 0)) {
                supersetkey_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto>();
                mutable_bitField0_ |= 0x00000008;
              }
              supersetkey_.add(
                      input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                      input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
                e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) != 0)) {
          columnname_ = columnname_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000008) != 0)) {
          supersetkey_ = java.util.Collections.unmodifiableList(supersetkey_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor
    getDescriptor() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_KeySpecProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_KeySpecProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;

    /**
     * <pre>
     * The name of this key. Note that each column by default has a 1-column key
     * with the same name. Properties of 1-column keys may be defined directly in
     * the ColumnSpecProto. Key names may not overlap with column names declared
     * in the same CsvSpecProto (this does not apply to column names provided in
     * the input csv header line, that are only used for the originalname field
     * in ColumnSpecProto).
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The name of this key. Note that each column by default has a 1-column key
     * with the same name. Properties of 1-column keys may be defined directly in
     * the ColumnSpecProto. Key names may not overlap with column names declared
     * in the same CsvSpecProto (this does not apply to column names provided in
     * the input csv header line, that are only used for the originalname field
     * in ColumnSpecProto).
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }

    /**
     * <pre>
     * The name of this key. Note that each column by default has a 1-column key
     * with the same name. Properties of 1-column keys may be defined directly in
     * the ColumnSpecProto. Key names may not overlap with column names declared
     * in the same CsvSpecProto (this does not apply to column names provided in
     * the input csv header line, that are only used for the originalname field
     * in ColumnSpecProto).
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    public com.google.protobuf.ByteString
    getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
                com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int COLUMNNAME_FIELD_NUMBER = 2;
    private com.google.protobuf.LazyStringList columnname_;

    /**
     * <pre>
     * The tuple of columns that form this key. There must be at least one column.
     * Note that order is significant. All columns listed here must also appear
     * as ColunmSpecProtos in the same CsvSpecProto.
     * </pre>
     *
     * <code>repeated string columnname = 2;</code>
     */
    public com.google.protobuf.ProtocolStringList
    getColumnnameList() {
      return columnname_;
    }

    /**
     * <pre>
     * The tuple of columns that form this key. There must be at least one column.
     * Note that order is significant. All columns listed here must also appear
     * as ColunmSpecProtos in the same CsvSpecProto.
     * </pre>
     *
     * <code>repeated string columnname = 2;</code>
     */
    public int getColumnnameCount() {
      return columnname_.size();
    }

    /**
     * <pre>
     * The tuple of columns that form this key. There must be at least one column.
     * Note that order is significant. All columns listed here must also appear
     * as ColunmSpecProtos in the same CsvSpecProto.
     * </pre>
     *
     * <code>repeated string columnname = 2;</code>
     */
    public java.lang.String getColumnname(int index) {
      return columnname_.get(index);
    }

    /**
     * <pre>
     * The tuple of columns that form this key. There must be at least one column.
     * Note that order is significant. All columns listed here must also appear
     * as ColunmSpecProtos in the same CsvSpecProto.
     * </pre>
     *
     * <code>repeated string columnname = 2;</code>
     */
    public com.google.protobuf.ByteString
        getColumnnameBytes(int index) {
      return columnname_.getByteString(index);
    }

    public static final int UNIQUEVALUES_FIELD_NUMBER = 3;
    private boolean uniquevalues_;
    /**
     * <pre>
     * If true, all value tuples defined by this table and key must be distinct.
     * Rows where some column is null (see CsvColumnSpec) are disregarded.
     * </pre>
     *
     * <code>optional bool uniquevalues = 3 [default = false];</code>
     */
    public boolean hasUniquevalues() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     * <pre>
     * If true, all value tuples defined by this table and key must be distinct.
     * Rows where some column is null (see CsvColumnSpec) are disregarded.
     * </pre>
     *
     * <code>optional bool uniquevalues = 3 [default = false];</code>
     */
    public boolean getUniquevalues() {
      return uniquevalues_;
    }

    public static final int SUPERSETKEY_FIELD_NUMBER = 4;
    private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto> supersetkey_;
    /**
     * <pre>
     * The set of value tuples defined by the KeySpecProto must be a subset of
     * each of the value sets defined by the keys listed here. This can be used
     * to verify references between two tables.
     * See SupersetKeySpecProto for more information.
     * </pre>
     *
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
     */
    public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto> getSupersetkeyList() {
      return supersetkey_;
    }
    /**
     * <pre>
     * The set of value tuples defined by the KeySpecProto must be a subset of
     * each of the value sets defined by the keys listed here. This can be used
     * to verify references between two tables.
     * See SupersetKeySpecProto for more information.
     * </pre>
     *
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
     */
    public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder>
    getSupersetkeyOrBuilderList() {
      return supersetkey_;
    }

    /**
     * <pre>
     * The set of value tuples defined by the KeySpecProto must be a subset of
     * each of the value sets defined by the keys listed here. This can be used
     * to verify references between two tables.
     * See SupersetKeySpecProto for more information.
     * </pre>
     *
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
     */
    public int getSupersetkeyCount() {
      return supersetkey_.size();
    }

    /**
     * <pre>
     * The set of value tuples defined by the KeySpecProto must be a subset of
     * each of the value sets defined by the keys listed here. This can be used
     * to verify references between two tables.
     * See SupersetKeySpecProto for more information.
     * </pre>
     *
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto getSupersetkey(int index) {
      return supersetkey_.get(index);
    }
    /**
     * <pre>
     * The set of value tuples defined by the KeySpecProto must be a subset of
     * each of the value sets defined by the keys listed here. This can be used
     * to verify references between two tables.
     * See SupersetKeySpecProto for more information.
     * </pre>
     *
     * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder getSupersetkeyOrBuilder(
            int index) {
      return supersetkey_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasName()) {
        memoizedIsInitialized = 0;
        return false;
      }
      for (int i = 0; i < getSupersetkeyCount(); i++) {
        if (!getSupersetkey(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      for (int i = 0; i < columnname_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, columnname_.getRaw(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBool(3, uniquevalues_);
      }
      for (int i = 0; i < supersetkey_.size(); i++) {
        output.writeMessage(4, supersetkey_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < columnname_.size(); i++) {
          dataSize += computeStringSizeNoTag(columnname_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getColumnnameList().size();
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
                .computeBoolSize(3, uniquevalues_);
      }
      for (int i = 0; i < supersetkey_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(4, supersetkey_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto)) {
        return super.equals(obj);
      }
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto other = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
                .equals(other.getName())) return false;
      }
      if (!getColumnnameList()
              .equals(other.getColumnnameList())) return false;
      if (hasUniquevalues() != other.hasUniquevalues()) return false;
      if (hasUniquevalues()) {
        if (getUniquevalues()
                != other.getUniquevalues()) return false;
      }
      if (!getSupersetkeyList()
              .equals(other.getSupersetkeyList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (getColumnnameCount() > 0) {
        hash = (37 * hash) + COLUMNNAME_FIELD_NUMBER;
        hash = (53 * hash) + getColumnnameList().hashCode();
      }
      if (hasUniquevalues()) {
        hash = (37 * hash) + UNIQUEVALUES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getUniquevalues());
      }
      if (getSupersetkeyCount() > 0) {
        hash = (37 * hash) + SUPERSETKEY_FIELD_NUMBER;
        hash = (53 * hash) + getSupersetkeyList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto parseFrom(
            byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csvspec.KeySpecProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csvspec.KeySpecProto)
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_KeySpecProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_KeySpecProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.Builder.class);
      }

      // Construct using org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSupersetkeyFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        columnname_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        uniquevalues_ = false;
        bitField0_ = (bitField0_ & ~0x00000004);
        if (supersetkeyBuilder_ == null) {
          supersetkey_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
        } else {
          supersetkeyBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
      getDescriptorForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_KeySpecProto_descriptor;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto getDefaultInstanceForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto build() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto buildPartial() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto result = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((bitField0_ & 0x00000002) != 0)) {
          columnname_ = columnname_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.columnname_ = columnname_;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.uniquevalues_ = uniquevalues_;
          to_bitField0_ |= 0x00000002;
        }
        if (supersetkeyBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            supersetkey_ = java.util.Collections.unmodifiableList(supersetkey_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.supersetkey_ = supersetkey_;
        } else {
          result.supersetkey_ = supersetkeyBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(
              com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto) {
          return mergeFrom((org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto other) {
        if (other == org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (!other.columnname_.isEmpty()) {
          if (columnname_.isEmpty()) {
            columnname_ = other.columnname_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureColumnnameIsMutable();
            columnname_.addAll(other.columnname_);
          }
          onChanged();
        }
        if (other.hasUniquevalues()) {
          setUniquevalues(other.getUniquevalues());
        }
        if (supersetkeyBuilder_ == null) {
          if (!other.supersetkey_.isEmpty()) {
            if (supersetkey_.isEmpty()) {
              supersetkey_ = other.supersetkey_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureSupersetkeyIsMutable();
              supersetkey_.addAll(other.supersetkey_);
            }
            onChanged();
          }
        } else {
          if (!other.supersetkey_.isEmpty()) {
            if (supersetkeyBuilder_.isEmpty()) {
              supersetkeyBuilder_.dispose();
              supersetkeyBuilder_ = null;
              supersetkey_ = other.supersetkey_;
              bitField0_ = (bitField0_ & ~0x00000008);
              supersetkeyBuilder_ =
                      com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSupersetkeyFieldBuilder() : null;
            } else {
              supersetkeyBuilder_.addAllMessages(other.supersetkey_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasName()) {
          return false;
        }
        for (int i = 0; i < getSupersetkeyCount(); i++) {
          if (!getSupersetkey(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name of this key. Note that each column by default has a 1-column key
       * with the same name. Properties of 1-column keys may be defined directly in
       * the ColumnSpecProto. Key names may not overlap with column names declared
       * in the same CsvSpecProto (this does not apply to column names provided in
       * the input csv header line, that are only used for the originalname field
       * in ColumnSpecProto).
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }

      /**
       * <pre>
       * The name of this key. Note that each column by default has a 1-column key
       * with the same name. Properties of 1-column keys may be defined directly in
       * the ColumnSpecProto. Key names may not overlap with column names declared
       * in the same CsvSpecProto (this does not apply to column names provided in
       * the input csv header line, that are only used for the originalname field
       * in ColumnSpecProto).
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
                  (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }

      /**
       * <pre>
       * The name of this key. Note that each column by default has a 1-column key
       * with the same name. Properties of 1-column keys may be defined directly in
       * the ColumnSpecProto. Key names may not overlap with column names declared
       * in the same CsvSpecProto (this does not apply to column names provided in
       * the input csv header line, that are only used for the originalname field
       * in ColumnSpecProto).
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name of this key. Note that each column by default has a 1-column key
       * with the same name. Properties of 1-column keys may be defined directly in
       * the ColumnSpecProto. Key names may not overlap with column names declared
       * in the same CsvSpecProto (this does not apply to column names provided in
       * the input csv header line, that are only used for the originalname field
       * in ColumnSpecProto).
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public Builder setName(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The name of this key. Note that each column by default has a 1-column key
       * with the same name. Properties of 1-column keys may be defined directly in
       * the ColumnSpecProto. Key names may not overlap with column names declared
       * in the same CsvSpecProto (this does not apply to column names provided in
       * the input csv header line, that are only used for the originalname field
       * in ColumnSpecProto).
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The name of this key. Note that each column by default has a 1-column key
       * with the same name. Properties of 1-column keys may be defined directly in
       * the ColumnSpecProto. Key names may not overlap with column names declared
       * in the same CsvSpecProto (this does not apply to column names provided in
       * the input csv header line, that are only used for the originalname field
       * in ColumnSpecProto).
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public Builder setNameBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList columnname_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureColumnnameIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          columnname_ = new com.google.protobuf.LazyStringArrayList(columnname_);
          bitField0_ |= 0x00000002;
         }
      }
      /**
       * <pre>
       * The tuple of columns that form this key. There must be at least one column.
       * Note that order is significant. All columns listed here must also appear
       * as ColunmSpecProtos in the same CsvSpecProto.
       * </pre>
       *
       * <code>repeated string columnname = 2;</code>
       */
      public com.google.protobuf.ProtocolStringList
      getColumnnameList() {
        return columnname_.getUnmodifiableView();
      }

      /**
       * <pre>
       * The tuple of columns that form this key. There must be at least one column.
       * Note that order is significant. All columns listed here must also appear
       * as ColunmSpecProtos in the same CsvSpecProto.
       * </pre>
       *
       * <code>repeated string columnname = 2;</code>
       */
      public int getColumnnameCount() {
        return columnname_.size();
      }
      /**
       * <pre>
       * The tuple of columns that form this key. There must be at least one column.
       * Note that order is significant. All columns listed here must also appear
       * as ColunmSpecProtos in the same CsvSpecProto.
       * </pre>
       *
       * <code>repeated string columnname = 2;</code>
       */
      public java.lang.String getColumnname(int index) {
        return columnname_.get(index);
      }
      /**
       * <pre>
       * The tuple of columns that form this key. There must be at least one column.
       * Note that order is significant. All columns listed here must also appear
       * as ColunmSpecProtos in the same CsvSpecProto.
       * </pre>
       *
       * <code>repeated string columnname = 2;</code>
       */
      public com.google.protobuf.ByteString
          getColumnnameBytes(int index) {
        return columnname_.getByteString(index);
      }
      /**
       * <pre>
       * The tuple of columns that form this key. There must be at least one column.
       * Note that order is significant. All columns listed here must also appear
       * as ColunmSpecProtos in the same CsvSpecProto.
       * </pre>
       *
       * <code>repeated string columnname = 2;</code>
       */
      public Builder setColumnname(
              int index, java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureColumnnameIsMutable();
        columnname_.set(index, value);
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The tuple of columns that form this key. There must be at least one column.
       * Note that order is significant. All columns listed here must also appear
       * as ColunmSpecProtos in the same CsvSpecProto.
       * </pre>
       *
       * <code>repeated string columnname = 2;</code>
       */
      public Builder addColumnname(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureColumnnameIsMutable();
        columnname_.add(value);
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The tuple of columns that form this key. There must be at least one column.
       * Note that order is significant. All columns listed here must also appear
       * as ColunmSpecProtos in the same CsvSpecProto.
       * </pre>
       *
       * <code>repeated string columnname = 2;</code>
       */
      public Builder addAllColumnname(
              java.lang.Iterable<java.lang.String> values) {
        ensureColumnnameIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
                values, columnname_);
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The tuple of columns that form this key. There must be at least one column.
       * Note that order is significant. All columns listed here must also appear
       * as ColunmSpecProtos in the same CsvSpecProto.
       * </pre>
       *
       * <code>repeated string columnname = 2;</code>
       */
      public Builder clearColumnname() {
        columnname_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The tuple of columns that form this key. There must be at least one column.
       * Note that order is significant. All columns listed here must also appear
       * as ColunmSpecProtos in the same CsvSpecProto.
       * </pre>
       *
       * <code>repeated string columnname = 2;</code>
       */
      public Builder addColumnnameBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureColumnnameIsMutable();
        columnname_.add(value);
        onChanged();
        return this;
      }

      private boolean uniquevalues_;

      /**
       * <pre>
       * If true, all value tuples defined by this table and key must be distinct.
       * Rows where some column is null (see CsvColumnSpec) are disregarded.
       * </pre>
       *
       * <code>optional bool uniquevalues = 3 [default = false];</code>
       */
      public boolean hasUniquevalues() {
        return ((bitField0_ & 0x00000004) != 0);
      }

      /**
       * <pre>
       * If true, all value tuples defined by this table and key must be distinct.
       * Rows where some column is null (see CsvColumnSpec) are disregarded.
       * </pre>
       *
       * <code>optional bool uniquevalues = 3 [default = false];</code>
       */
      public boolean getUniquevalues() {
        return uniquevalues_;
      }

      /**
       * <pre>
       * If true, all value tuples defined by this table and key must be distinct.
       * Rows where some column is null (see CsvColumnSpec) are disregarded.
       * </pre>
       *
       * <code>optional bool uniquevalues = 3 [default = false];</code>
       */
      public Builder setUniquevalues(boolean value) {
        bitField0_ |= 0x00000004;
        uniquevalues_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * If true, all value tuples defined by this table and key must be distinct.
       * Rows where some column is null (see CsvColumnSpec) are disregarded.
       * </pre>
       *
       * <code>optional bool uniquevalues = 3 [default = false];</code>
       */
      public Builder clearUniquevalues() {
        bitField0_ = (bitField0_ & ~0x00000004);
        uniquevalues_ = false;
        onChanged();
        return this;
      }

      private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto> supersetkey_ =
              java.util.Collections.emptyList();

      private void ensureSupersetkeyIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          supersetkey_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto>(supersetkey_);
          bitField0_ |= 0x00000008;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder> supersetkeyBuilder_;

      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto> getSupersetkeyList() {
        if (supersetkeyBuilder_ == null) {
          return java.util.Collections.unmodifiableList(supersetkey_);
        } else {
          return supersetkeyBuilder_.getMessageList();
        }
      }

      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public int getSupersetkeyCount() {
        if (supersetkeyBuilder_ == null) {
          return supersetkey_.size();
        } else {
          return supersetkeyBuilder_.getCount();
        }
      }

      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto getSupersetkey(int index) {
        if (supersetkeyBuilder_ == null) {
          return supersetkey_.get(index);
        } else {
          return supersetkeyBuilder_.getMessage(index);
        }
      }

      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public Builder setSupersetkey(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto value) {
        if (supersetkeyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSupersetkeyIsMutable();
          supersetkey_.set(index, value);
          onChanged();
        } else {
          supersetkeyBuilder_.setMessage(index, value);
        }
        return this;
      }

      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public Builder setSupersetkey(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder builderForValue) {
        if (supersetkeyBuilder_ == null) {
          ensureSupersetkeyIsMutable();
          supersetkey_.set(index, builderForValue.build());
          onChanged();
        } else {
          supersetkeyBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public Builder addSupersetkey(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto value) {
        if (supersetkeyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSupersetkeyIsMutable();
          supersetkey_.add(value);
          onChanged();
        } else {
          supersetkeyBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public Builder addSupersetkey(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto value) {
        if (supersetkeyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSupersetkeyIsMutable();
          supersetkey_.add(index, value);
          onChanged();
        } else {
          supersetkeyBuilder_.addMessage(index, value);
        }
        return this;
      }

      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public Builder addSupersetkey(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder builderForValue) {
        if (supersetkeyBuilder_ == null) {
          ensureSupersetkeyIsMutable();
          supersetkey_.add(builderForValue.build());
          onChanged();
        } else {
          supersetkeyBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public Builder addSupersetkey(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder builderForValue) {
        if (supersetkeyBuilder_ == null) {
          ensureSupersetkeyIsMutable();
          supersetkey_.add(index, builderForValue.build());
          onChanged();
        } else {
          supersetkeyBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public Builder addAllSupersetkey(
              java.lang.Iterable<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto> values) {
        if (supersetkeyBuilder_ == null) {
          ensureSupersetkeyIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
                  values, supersetkey_);
          onChanged();
        } else {
          supersetkeyBuilder_.addAllMessages(values);
        }
        return this;
      }

      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public Builder clearSupersetkey() {
        if (supersetkeyBuilder_ == null) {
          supersetkey_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          supersetkeyBuilder_.clear();
        }
        return this;
      }

      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public Builder removeSupersetkey(int index) {
        if (supersetkeyBuilder_ == null) {
          ensureSupersetkeyIsMutable();
          supersetkey_.remove(index);
          onChanged();
        } else {
          supersetkeyBuilder_.remove(index);
        }
        return this;
      }

      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder getSupersetkeyBuilder(
          int index) {
        return getSupersetkeyFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder getSupersetkeyOrBuilder(
              int index) {
        if (supersetkeyBuilder_ == null) {
          return supersetkey_.get(index);  } else {
          return supersetkeyBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder>
      getSupersetkeyOrBuilderList() {
        if (supersetkeyBuilder_ != null) {
          return supersetkeyBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(supersetkey_);
        }
      }
      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder addSupersetkeyBuilder() {
        return getSupersetkeyFieldBuilder().addBuilder(
            org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.getDefaultInstance());
      }
      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder addSupersetkeyBuilder(
          int index) {
        return getSupersetkeyFieldBuilder().addBuilder(
            index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.getDefaultInstance());
      }
      /**
       * <pre>
       * The set of value tuples defined by the KeySpecProto must be a subset of
       * each of the value sets defined by the keys listed here. This can be used
       * to verify references between two tables.
       * See SupersetKeySpecProto for more information.
       * </pre>
       *
       * <code>repeated .csvspec.SupersetKeySpecProto supersetkey = 4;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder> 
           getSupersetkeyBuilderList() {
        return getSupersetkeyFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder> 
          getSupersetkeyFieldBuilder() {
        if (supersetkeyBuilder_ == null) {
          supersetkeyBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.SupersetKeySpecProtoOrBuilder>(
                  supersetkey_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          supersetkey_ = null;
        }
        return supersetkeyBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csvspec.KeySpecProto)
    }

    // @@protoc_insertion_point(class_scope:csvspec.KeySpecProto)
    private static final org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto();
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<KeySpecProto>
        PARSER = new com.google.protobuf.AbstractParser<KeySpecProto>() {
      @java.lang.Override
      public KeySpecProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new KeySpecProto(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<KeySpecProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<KeySpecProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CsvSpecProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csvspec.CsvSpecProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This is the name of the csv.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    boolean hasName();
    /**
     * <pre>
     * This is the name of the csv.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * This is the name of the csv.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * This is the file where the csv is stored, without the directory path, that
     * will be added elsewhere. Note: this is actually required, it is set as
     * optional here just so that template/extension csv specs can be valid protos
     * on their own even if this field is missing in one of them.
     * </pre>
     *
     * <code>optional string filename = 2;</code>
     */
    boolean hasFilename();
    /**
     * <pre>
     * This is the file where the csv is stored, without the directory path, that
     * will be added elsewhere. Note: this is actually required, it is set as
     * optional here just so that template/extension csv specs can be valid protos
     * on their own even if this field is missing in one of them.
     * </pre>
     *
     * <code>optional string filename = 2;</code>
     */
    java.lang.String getFilename();
    /**
     * <pre>
     * This is the file where the csv is stored, without the directory path, that
     * will be added elsewhere. Note: this is actually required, it is set as
     * optional here just so that template/extension csv specs can be valid protos
     * on their own even if this field is missing in one of them.
     * </pre>
     *
     * <code>optional string filename = 2;</code>
     */
    com.google.protobuf.ByteString
    getFilenameBytes();

    /**
     * <pre>
     * If a template is used for this spec, and that template contains a csv spec
     * with the same name as this, the two csv specs may be merged. These flags
     * control which parts of the resulting csv spec should be based on the
     * template.
     * - Fields: all fields of the csv spec, except column and key.
     *   This is a plain proto buffer merge, non-repeated fields may be overridden
     *   from the template, repeated fields may be added to.
     * - Input columns: any input columns of the template are added to the ones
     *   given here. If a column with the same name exists both in template and
     *   here, the two copies are merged. See ColumnSpecProto for details on that.
     * - Output columns: just like input columns, except that a column with the
     *   same name will simply override the template, none of the fields in the
     *   template output column will be preserved.
     * - Keys: like output columns.
     * </pre>
     *
     * <code>optional bool inheritfields = 12 [default = false];</code>
     */
    boolean hasInheritfields();

    /**
     * <pre>
     * If a template is used for this spec, and that template contains a csv spec
     * with the same name as this, the two csv specs may be merged. These flags
     * control which parts of the resulting csv spec should be based on the
     * template.
     * - Fields: all fields of the csv spec, except column and key.
     *   This is a plain proto buffer merge, non-repeated fields may be overridden
     *   from the template, repeated fields may be added to.
     * - Input columns: any input columns of the template are added to the ones
     *   given here. If a column with the same name exists both in template and
     *   here, the two copies are merged. See ColumnSpecProto for details on that.
     * - Output columns: just like input columns, except that a column with the
     *   same name will simply override the template, none of the fields in the
     *   template output column will be preserved.
     * - Keys: like output columns.
     * </pre>
     *
     * <code>optional bool inheritfields = 12 [default = false];</code>
     */
    boolean getInheritfields();

    /**
     * <code>optional bool inheritinputcolumns = 13 [default = false];</code>
     */
    boolean hasInheritinputcolumns();

    /**
     * <code>optional bool inheritinputcolumns = 13 [default = false];</code>
     */
    boolean getInheritinputcolumns();

    /**
     * <code>optional bool inheritkeys = 15 [default = false];</code>
     */
    boolean hasInheritkeys();

    /**
     * <code>optional bool inheritkeys = 15 [default = false];</code>
     */
    boolean getInheritkeys();

    /**
     * <pre>
     * This determines what will happen if this csv is missing in the input
     * set. If true, an error will be flagged, if false, this will be silently
     * ignored and all tests on this csv, and any tests that reference it, will be
     * skipped.
     * </pre>
     *
     * <code>optional bool required = 3 [default = true];</code>
     */
    boolean hasRequired();
    /**
     * <pre>
     * This determines what will happen if this csv is missing in the input
     * set. If true, an error will be flagged, if false, this will be silently
     * ignored and all tests on this csv, and any tests that reference it, will be
     * skipped.
     * </pre>
     *
     * <code>optional bool required = 3 [default = true];</code>
     */
    boolean getRequired();

    /**
     * <pre>
     * If this is true, the first row of the input file will be interpreted as
     * column names.
     * </pre>
     *
     * <code>optional bool hasheader = 4 [default = true];</code>
     */
    boolean hasHasheader();

    /**
     * <pre>
     * If this is true, the first row of the input file will be interpreted as
     * column names.
     * </pre>
     *
     * <code>optional bool hasheader = 4 [default = true];</code>
     */
    boolean getHasheader();

    /**
     * <pre>
     * The character encoding of the document.
     * </pre>
     *
     * <code>optional string encoding = 5 [default = "UTF-8"];</code>
     */
    boolean hasEncoding();

    /**
     * <pre>
     * The character encoding of the document.
     * </pre>
     *
     * <code>optional string encoding = 5 [default = "UTF-8"];</code>
     */
    java.lang.String getEncoding();
    /**
     * <pre>
     * The character encoding of the document.
     * </pre>
     *
     * <code>optional string encoding = 5 [default = "UTF-8"];</code>
     */
    com.google.protobuf.ByteString
        getEncodingBytes();

    /**
     * <pre>
     * The subset of columns to be used from this table. Existence of the given
     * columns will be verified (as well as any properties specified).
     * </pre>
     *
     * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
     */
    java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto> 
        getColumnList();
    /**
     * <pre>
     * The subset of columns to be used from this table. Existence of the given
     * columns will be verified (as well as any properties specified).
     * </pre>
     *
     * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto getColumn(int index);

    /**
     * <pre>
     * The subset of columns to be used from this table. Existence of the given
     * columns will be verified (as well as any properties specified).
     * </pre>
     *
     * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
     */
    int getColumnCount();

    /**
     * <pre>
     * The subset of columns to be used from this table. Existence of the given
     * columns will be verified (as well as any properties specified).
     * </pre>
     *
     * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
     */
    java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder>
    getColumnOrBuilderList();

    /**
     * <pre>
     * The subset of columns to be used from this table. Existence of the given
     * columns will be verified (as well as any properties specified).
     * </pre>
     *
     * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder getColumnOrBuilder(
            int index);

    /**
     * <pre>
     * The keys of this table. A key is a tuple of one or more columns from the
     * same table.
     * </pre>
     *
     * <code>repeated .csvspec.KeySpecProto key = 7;</code>
     */
    java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto> 
        getKeyList();
    /**
     * <pre>
     * The keys of this table. A key is a tuple of one or more columns from the
     * same table.
     * </pre>
     *
     * <code>repeated .csvspec.KeySpecProto key = 7;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto getKey(int index);
    /**
     * <pre>
     * The keys of this table. A key is a tuple of one or more columns from the
     * same table.
     * </pre>
     *
     * <code>repeated .csvspec.KeySpecProto key = 7;</code>
     */
    int getKeyCount();

    /**
     * <pre>
     * The keys of this table. A key is a tuple of one or more columns from the
     * same table.
     * </pre>
     *
     * <code>repeated .csvspec.KeySpecProto key = 7;</code>
     */
    java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProtoOrBuilder>
    getKeyOrBuilderList();

    /**
     * <pre>
     * The keys of this table. A key is a tuple of one or more columns from the
     * same table.
     * </pre>
     *
     * <code>repeated .csvspec.KeySpecProto key = 7;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProtoOrBuilder getKeyOrBuilder(
            int index);

    /**
     * <pre>
     * The table rows will be re-sorted on this key. The first column of the key
     * is the most significant.
     * </pre>
     *
     * <code>optional string resortkey = 8;</code>
     */
    boolean hasResortkey();

    /**
     * <pre>
     * The table rows will be re-sorted on this key. The first column of the key
     * is the most significant.
     * </pre>
     *
     * <code>optional string resortkey = 8;</code>
     */
    java.lang.String getResortkey();

    /**
     * <pre>
     * The table rows will be re-sorted on this key. The first column of the key
     * is the most significant.
     * </pre>
     *
     * <code>optional string resortkey = 8;</code>
     */
    com.google.protobuf.ByteString
        getResortkeyBytes();

    /**
     * <pre>
     * The table rows will be required to be sorted on these keys. Note: If there
     * is a re-sorting key specified as well, the re-sorting will be carried out
     * before this check.
     * </pre>
     *
     * <code>repeated string requiresortedonkey = 9;</code>
     */
    java.util.List<java.lang.String>
    getRequiresortedonkeyList();

    /**
     * <pre>
     * The table rows will be required to be sorted on these keys. Note: If there
     * is a re-sorting key specified as well, the re-sorting will be carried out
     * before this check.
     * </pre>
     *
     * <code>repeated string requiresortedonkey = 9;</code>
     */
    int getRequiresortedonkeyCount();

    /**
     * <pre>
     * The table rows will be required to be sorted on these keys. Note: If there
     * is a re-sorting key specified as well, the re-sorting will be carried out
     * before this check.
     * </pre>
     *
     * <code>repeated string requiresortedonkey = 9;</code>
     */
    java.lang.String getRequiresortedonkey(int index);
    /**
     * <pre>
     * The table rows will be required to be sorted on these keys. Note: If there
     * is a re-sorting key specified as well, the re-sorting will be carried out
     * before this check.
     * </pre>
     *
     * <code>repeated string requiresortedonkey = 9;</code>
     */
    com.google.protobuf.ByteString
        getRequiresortedonkeyBytes(int index);

    /**
     * <pre>
     * Specifies names for certain values for columns of this csv spec.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> 
        getNamedvalueList();
    /**
     * <pre>
     * Specifies names for certain values for columns of this csv spec.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto getNamedvalue(int index);

    /**
     * <pre>
     * Specifies names for certain values for columns of this csv spec.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    int getNamedvalueCount();

    /**
     * <pre>
     * Specifies names for certain values for columns of this csv spec.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder> 
        getNamedvalueOrBuilderList();

    /**
     * <pre>
     * Specifies names for certain values for columns of this csv spec.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder getNamedvalueOrBuilder(
        int index);

    /**
     * <pre>
     * If set, overrides behavior inherited from CsvSpecProtos.
     * </pre>
     *
     * <code>optional bool strip_protected_whitespace_from_values = 18;</code>
     */
    boolean hasStripProtectedWhitespaceFromValues();
    /**
     * <pre>
     * If set, overrides behavior inherited from CsvSpecProtos.
     * </pre>
     *
     * <code>optional bool strip_protected_whitespace_from_values = 18;</code>
     */
    boolean getStripProtectedWhitespaceFromValues();

    /**
     * <pre>
     * Define a default column-value caching strategy across all columns in this
     * CSV file. Can be overwritten on a per-column basis.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
     */
    boolean hasColumnCache();
    /**
     * <pre>
     * Define a default column-value caching strategy across all columns in this
     * CSV file. Can be overwritten on a per-column basis.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto getColumnCache();
    /**
     * <pre>
     * Define a default column-value caching strategy across all columns in this
     * CSV file. Can be overwritten on a per-column basis.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder getColumnCacheOrBuilder();
  }
  /**
   * Protobuf type {@code csvspec.CsvSpecProto}
   */
  public static final class CsvSpecProto extends
          com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csvspec.CsvSpecProto)
      CsvSpecProtoOrBuilder {
  private static final long serialVersionUID = 0L;

    // Use CsvSpecProto.newBuilder() to construct.
    private CsvSpecProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CsvSpecProto() {
      name_ = "";
      filename_ = "";
      required_ = true;
      hasheader_ = true;
      encoding_ = "UTF-8";
      column_ = java.util.Collections.emptyList();
      key_ = java.util.Collections.emptyList();
      resortkey_ = "";
      requiresortedonkey_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      namedvalue_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new CsvSpecProto();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CsvSpecProto(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              filename_ = bs;
              break;
            }
            case 24: {
              bitField0_ |= 0x00000020;
              required_ = input.readBool();
              break;
            }
            case 32: {
              bitField0_ |= 0x00000040;
              hasheader_ = input.readBool();
              break;
            }
            case 42: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000080;
              encoding_ = bs;
              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000100) != 0)) {
                column_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto>();
                mutable_bitField0_ |= 0x00000100;
              }
              column_.add(
                  input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.PARSER, extensionRegistry));
              break;
            }
            case 58: {
              if (!((mutable_bitField0_ & 0x00000200) != 0)) {
                key_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto>();
                mutable_bitField0_ |= 0x00000200;
              }
              key_.add(
                  input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.PARSER, extensionRegistry));
              break;
            }
            case 66: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000100;
              resortkey_ = bs;
              break;
            }
            case 74: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000800) != 0)) {
                requiresortedonkey_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000800;
              }
              requiresortedonkey_.add(bs);
              break;
            }
            case 96: {
              bitField0_ |= 0x00000004;
              inheritfields_ = input.readBool();
              break;
            }
            case 104: {
              bitField0_ |= 0x00000008;
              inheritinputcolumns_ = input.readBool();
              break;
            }
            case 120: {
              bitField0_ |= 0x00000010;
              inheritkeys_ = input.readBool();
              break;
            }
            case 130: {
              if (!((mutable_bitField0_ & 0x00001000) != 0)) {
                namedvalue_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto>();
                mutable_bitField0_ |= 0x00001000;
              }
              namedvalue_.add(
                  input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.PARSER, extensionRegistry));
              break;
            }
            case 144: {
              bitField0_ |= 0x00000200;
              stripProtectedWhitespaceFromValues_ = input.readBool();
              break;
            }
            case 154: {
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder subBuilder = null;
              if (((bitField0_ & 0x00000400) != 0)) {
                subBuilder = columnCache_.toBuilder();
              }
              columnCache_ = input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(columnCache_);
                columnCache_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000400;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000100) != 0)) {
          column_ = java.util.Collections.unmodifiableList(column_);
        }
        if (((mutable_bitField0_ & 0x00000200) != 0)) {
          key_ = java.util.Collections.unmodifiableList(key_);
        }
        if (((mutable_bitField0_ & 0x00000800) != 0)) {
          requiresortedonkey_ = requiresortedonkey_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00001000) != 0)) {
          namedvalue_ = java.util.Collections.unmodifiableList(namedvalue_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvSpecProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvSpecProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * This is the name of the csv.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This is the name of the csv.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * This is the name of the csv.
     * </pre>
     *
     * <code>required string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FILENAME_FIELD_NUMBER = 2;
    private volatile java.lang.Object filename_;
    /**
     * <pre>
     * This is the file where the csv is stored, without the directory path, that
     * will be added elsewhere. Note: this is actually required, it is set as
     * optional here just so that template/extension csv specs can be valid protos
     * on their own even if this field is missing in one of them.
     * </pre>
     *
     * <code>optional string filename = 2;</code>
     */
    public boolean hasFilename() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * This is the file where the csv is stored, without the directory path, that
     * will be added elsewhere. Note: this is actually required, it is set as
     * optional here just so that template/extension csv specs can be valid protos
     * on their own even if this field is missing in one of them.
     * </pre>
     *
     * <code>optional string filename = 2;</code>
     */
    public java.lang.String getFilename() {
      java.lang.Object ref = filename_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          filename_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * This is the file where the csv is stored, without the directory path, that
     * will be added elsewhere. Note: this is actually required, it is set as
     * optional here just so that template/extension csv specs can be valid protos
     * on their own even if this field is missing in one of them.
     * </pre>
     *
     * <code>optional string filename = 2;</code>
     */
    public com.google.protobuf.ByteString
        getFilenameBytes() {
      java.lang.Object ref = filename_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        filename_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INHERITFIELDS_FIELD_NUMBER = 12;
    private boolean inheritfields_;
    /**
     * <pre>
     * If a template is used for this spec, and that template contains a csv spec
     * with the same name as this, the two csv specs may be merged. These flags
     * control which parts of the resulting csv spec should be based on the
     * template.
     * - Fields: all fields of the csv spec, except column and key.
     *   This is a plain proto buffer merge, non-repeated fields may be overridden
     *   from the template, repeated fields may be added to.
     * - Input columns: any input columns of the template are added to the ones
     *   given here. If a column with the same name exists both in template and
     *   here, the two copies are merged. See ColumnSpecProto for details on that.
     * - Output columns: just like input columns, except that a column with the
     *   same name will simply override the template, none of the fields in the
     *   template output column will be preserved.
     * - Keys: like output columns.
     * </pre>
     *
     * <code>optional bool inheritfields = 12 [default = false];</code>
     */
    public boolean hasInheritfields() {
      return ((bitField0_ & 0x00000004) != 0);
    }

    /**
     * <pre>
     * If a template is used for this spec, and that template contains a csv spec
     * with the same name as this, the two csv specs may be merged. These flags
     * control which parts of the resulting csv spec should be based on the
     * template.
     * - Fields: all fields of the csv spec, except column and key.
     *   This is a plain proto buffer merge, non-repeated fields may be overridden
     *   from the template, repeated fields may be added to.
     * - Input columns: any input columns of the template are added to the ones
     *   given here. If a column with the same name exists both in template and
     *   here, the two copies are merged. See ColumnSpecProto for details on that.
     * - Output columns: just like input columns, except that a column with the
     *   same name will simply override the template, none of the fields in the
     *   template output column will be preserved.
     * - Keys: like output columns.
     * </pre>
     *
     * <code>optional bool inheritfields = 12 [default = false];</code>
     */
    public boolean getInheritfields() {
      return inheritfields_;
    }

    public static final int INHERITINPUTCOLUMNS_FIELD_NUMBER = 13;
    private boolean inheritinputcolumns_;

    /**
     * <code>optional bool inheritinputcolumns = 13 [default = false];</code>
     */
    public boolean hasInheritinputcolumns() {
      return ((bitField0_ & 0x00000008) != 0);
    }

    /**
     * <code>optional bool inheritinputcolumns = 13 [default = false];</code>
     */
    public boolean getInheritinputcolumns() {
      return inheritinputcolumns_;
    }

    public static final int INHERITKEYS_FIELD_NUMBER = 15;
    private boolean inheritkeys_;

    /**
     * <code>optional bool inheritkeys = 15 [default = false];</code>
     */
    public boolean hasInheritkeys() {
      return ((bitField0_ & 0x00000010) != 0);
    }

    /**
     * <code>optional bool inheritkeys = 15 [default = false];</code>
     */
    public boolean getInheritkeys() {
      return inheritkeys_;
    }

    public static final int REQUIRED_FIELD_NUMBER = 3;
    private boolean required_;

    /**
     * <pre>
     * This determines what will happen if this csv is missing in the input
     * set. If true, an error will be flagged, if false, this will be silently
     * ignored and all tests on this csv, and any tests that reference it, will be
     * skipped.
     * </pre>
     *
     * <code>optional bool required = 3 [default = true];</code>
     */
    public boolean hasRequired() {
      return ((bitField0_ & 0x00000020) != 0);
    }

    /**
     * <pre>
     * This determines what will happen if this csv is missing in the input
     * set. If true, an error will be flagged, if false, this will be silently
     * ignored and all tests on this csv, and any tests that reference it, will be
     * skipped.
     * </pre>
     *
     * <code>optional bool required = 3 [default = true];</code>
     */
    public boolean getRequired() {
      return required_;
    }

    public static final int HASHEADER_FIELD_NUMBER = 4;
    private boolean hasheader_;

    /**
     * <pre>
     * If this is true, the first row of the input file will be interpreted as
     * column names.
     * </pre>
     *
     * <code>optional bool hasheader = 4 [default = true];</code>
     */
    public boolean hasHasheader() {
      return ((bitField0_ & 0x00000040) != 0);
    }

    /**
     * <pre>
     * If this is true, the first row of the input file will be interpreted as
     * column names.
     * </pre>
     *
     * <code>optional bool hasheader = 4 [default = true];</code>
     */
    public boolean getHasheader() {
      return hasheader_;
    }

    public static final int ENCODING_FIELD_NUMBER = 5;
    private volatile java.lang.Object encoding_;
    /**
     * <pre>
     * The character encoding of the document.
     * </pre>
     *
     * <code>optional string encoding = 5 [default = "UTF-8"];</code>
     */
    public boolean hasEncoding() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * The character encoding of the document.
     * </pre>
     *
     * <code>optional string encoding = 5 [default = "UTF-8"];</code>
     */
    public java.lang.String getEncoding() {
      java.lang.Object ref = encoding_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          encoding_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The character encoding of the document.
     * </pre>
     *
     * <code>optional string encoding = 5 [default = "UTF-8"];</code>
     */
    public com.google.protobuf.ByteString
    getEncodingBytes() {
      java.lang.Object ref = encoding_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
                com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
        encoding_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int COLUMN_FIELD_NUMBER = 6;
    private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto> column_;
    /**
     * <pre>
     * The subset of columns to be used from this table. Existence of the given
     * columns will be verified (as well as any properties specified).
     * </pre>
     *
     * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
     */
    public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto> getColumnList() {
      return column_;
    }
    /**
     * <pre>
     * The subset of columns to be used from this table. Existence of the given
     * columns will be verified (as well as any properties specified).
     * </pre>
     *
     * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
     */
    public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder> 
        getColumnOrBuilderList() {
      return column_;
    }
    /**
     * <pre>
     * The subset of columns to be used from this table. Existence of the given
     * columns will be verified (as well as any properties specified).
     * </pre>
     *
     * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
     */
    public int getColumnCount() {
      return column_.size();
    }
    /**
     * <pre>
     * The subset of columns to be used from this table. Existence of the given
     * columns will be verified (as well as any properties specified).
     * </pre>
     *
     * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto getColumn(int index) {
      return column_.get(index);
    }

    /**
     * <pre>
     * The subset of columns to be used from this table. Existence of the given
     * columns will be verified (as well as any properties specified).
     * </pre>
     *
     * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder getColumnOrBuilder(
            int index) {
      return column_.get(index);
    }

    public static final int KEY_FIELD_NUMBER = 7;
    private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto> key_;

    /**
     * <pre>
     * The keys of this table. A key is a tuple of one or more columns from the
     * same table.
     * </pre>
     *
     * <code>repeated .csvspec.KeySpecProto key = 7;</code>
     */
    public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto> getKeyList() {
      return key_;
    }

    /**
     * <pre>
     * The keys of this table. A key is a tuple of one or more columns from the
     * same table.
     * </pre>
     *
     * <code>repeated .csvspec.KeySpecProto key = 7;</code>
     */
    public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProtoOrBuilder>
    getKeyOrBuilderList() {
      return key_;
    }

    /**
     * <pre>
     * The keys of this table. A key is a tuple of one or more columns from the
     * same table.
     * </pre>
     *
     * <code>repeated .csvspec.KeySpecProto key = 7;</code>
     */
    public int getKeyCount() {
      return key_.size();
    }

    /**
     * <pre>
     * The keys of this table. A key is a tuple of one or more columns from the
     * same table.
     * </pre>
     *
     * <code>repeated .csvspec.KeySpecProto key = 7;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto getKey(int index) {
      return key_.get(index);
    }

    /**
     * <pre>
     * The keys of this table. A key is a tuple of one or more columns from the
     * same table.
     * </pre>
     *
     * <code>repeated .csvspec.KeySpecProto key = 7;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProtoOrBuilder getKeyOrBuilder(
        int index) {
      return key_.get(index);
    }

    public static final int RESORTKEY_FIELD_NUMBER = 8;
    private volatile java.lang.Object resortkey_;
    /**
     * <pre>
     * The table rows will be re-sorted on this key. The first column of the key
     * is the most significant.
     * </pre>
     *
     * <code>optional string resortkey = 8;</code>
     */
    public boolean hasResortkey() {
      return ((bitField0_ & 0x00000100) != 0);
    }

    /**
     * <pre>
     * The table rows will be re-sorted on this key. The first column of the key
     * is the most significant.
     * </pre>
     *
     * <code>optional string resortkey = 8;</code>
     */
    public java.lang.String getResortkey() {
      java.lang.Object ref = resortkey_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          resortkey_ = s;
        }
        return s;
      }
    }

    /**
     * <pre>
     * The table rows will be re-sorted on this key. The first column of the key
     * is the most significant.
     * </pre>
     *
     * <code>optional string resortkey = 8;</code>
     */
    public com.google.protobuf.ByteString
    getResortkeyBytes() {
      java.lang.Object ref = resortkey_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
                com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
        resortkey_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int REQUIRESORTEDONKEY_FIELD_NUMBER = 9;
    private com.google.protobuf.LazyStringList requiresortedonkey_;

    /**
     * <pre>
     * The table rows will be required to be sorted on these keys. Note: If there
     * is a re-sorting key specified as well, the re-sorting will be carried out
     * before this check.
     * </pre>
     *
     * <code>repeated string requiresortedonkey = 9;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getRequiresortedonkeyList() {
      return requiresortedonkey_;
    }
    /**
     * <pre>
     * The table rows will be required to be sorted on these keys. Note: If there
     * is a re-sorting key specified as well, the re-sorting will be carried out
     * before this check.
     * </pre>
     *
     * <code>repeated string requiresortedonkey = 9;</code>
     */
    public int getRequiresortedonkeyCount() {
      return requiresortedonkey_.size();
    }
    /**
     * <pre>
     * The table rows will be required to be sorted on these keys. Note: If there
     * is a re-sorting key specified as well, the re-sorting will be carried out
     * before this check.
     * </pre>
     *
     * <code>repeated string requiresortedonkey = 9;</code>
     */
    public java.lang.String getRequiresortedonkey(int index) {
      return requiresortedonkey_.get(index);
    }
    /**
     * <pre>
     * The table rows will be required to be sorted on these keys. Note: If there
     * is a re-sorting key specified as well, the re-sorting will be carried out
     * before this check.
     * </pre>
     *
     * <code>repeated string requiresortedonkey = 9;</code>
     */
    public com.google.protobuf.ByteString
        getRequiresortedonkeyBytes(int index) {
      return requiresortedonkey_.getByteString(index);
    }

    public static final int NAMEDVALUE_FIELD_NUMBER = 16;
    private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> namedvalue_;
    /**
     * <pre>
     * Specifies names for certain values for columns of this csv spec.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> getNamedvalueList() {
      return namedvalue_;
    }
    /**
     * <pre>
     * Specifies names for certain values for columns of this csv spec.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder> 
        getNamedvalueOrBuilderList() {
      return namedvalue_;
    }
    /**
     * <pre>
     * Specifies names for certain values for columns of this csv spec.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    public int getNamedvalueCount() {
      return namedvalue_.size();
    }
    /**
     * <pre>
     * Specifies names for certain values for columns of this csv spec.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto getNamedvalue(int index) {
      return namedvalue_.get(index);
    }
    /**
     * <pre>
     * Specifies names for certain values for columns of this csv spec.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder getNamedvalueOrBuilder(
            int index) {
      return namedvalue_.get(index);
    }

    public static final int STRIP_PROTECTED_WHITESPACE_FROM_VALUES_FIELD_NUMBER = 18;
    private boolean stripProtectedWhitespaceFromValues_;
    /**
     * <pre>
     * If set, overrides behavior inherited from CsvSpecProtos.
     * </pre>
     *
     * <code>optional bool strip_protected_whitespace_from_values = 18;</code>
     */
    public boolean hasStripProtectedWhitespaceFromValues() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * If set, overrides behavior inherited from CsvSpecProtos.
     * </pre>
     *
     * <code>optional bool strip_protected_whitespace_from_values = 18;</code>
     */
    public boolean getStripProtectedWhitespaceFromValues() {
      return stripProtectedWhitespaceFromValues_;
    }

    public static final int COLUMN_CACHE_FIELD_NUMBER = 19;
    private org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto columnCache_;
    /**
     * <pre>
     * Define a default column-value caching strategy across all columns in this
     * CSV file. Can be overwritten on a per-column basis.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
     */
    public boolean hasColumnCache() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Define a default column-value caching strategy across all columns in this
     * CSV file. Can be overwritten on a per-column basis.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto getColumnCache() {
      return columnCache_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance() : columnCache_;
    }
    /**
     * <pre>
     * Define a default column-value caching strategy across all columns in this
     * CSV file. Can be overwritten on a per-column basis.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder getColumnCacheOrBuilder() {
      return columnCache_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance() : columnCache_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasName()) {
        memoizedIsInitialized = 0;
        return false;
      }
      for (int i = 0; i < getColumnCount(); i++) {
        if (!getColumn(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getKeyCount(); i++) {
        if (!getKey(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getNamedvalueCount(); i++) {
        if (!getNamedvalue(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, filename_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBool(3, required_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBool(4, hasheader_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, encoding_);
      }
      for (int i = 0; i < column_.size(); i++) {
        output.writeMessage(6, column_.get(i));
      }
      for (int i = 0; i < key_.size(); i++) {
        output.writeMessage(7, key_.get(i));
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, resortkey_);
      }
      for (int i = 0; i < requiresortedonkey_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 9, requiresortedonkey_.getRaw(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(12, inheritfields_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeBool(13, inheritinputcolumns_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeBool(15, inheritkeys_);
      }
      for (int i = 0; i < namedvalue_.size(); i++) {
        output.writeMessage(16, namedvalue_.get(i));
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeBool(18, stripProtectedWhitespaceFromValues_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeMessage(19, getColumnCache());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, filename_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
                .computeBoolSize(3, required_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
                .computeBoolSize(4, hasheader_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, encoding_);
      }
      for (int i = 0; i < column_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(6, column_.get(i));
      }
      for (int i = 0; i < key_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(7, key_.get(i));
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, resortkey_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < requiresortedonkey_.size(); i++) {
          dataSize += computeStringSizeNoTag(requiresortedonkey_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getRequiresortedonkeyList().size();
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(12, inheritfields_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(13, inheritinputcolumns_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(15, inheritkeys_);
      }
      for (int i = 0; i < namedvalue_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(16, namedvalue_.get(i));
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(18, stripProtectedWhitespaceFromValues_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(19, getColumnCache());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto)) {
        return super.equals(obj);
      }
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto other = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
                .equals(other.getName())) return false;
      }
      if (hasFilename() != other.hasFilename()) return false;
      if (hasFilename()) {
        if (!getFilename()
                .equals(other.getFilename())) return false;
      }
      if (hasInheritfields() != other.hasInheritfields()) return false;
      if (hasInheritfields()) {
        if (getInheritfields()
                != other.getInheritfields()) return false;
      }
      if (hasInheritinputcolumns() != other.hasInheritinputcolumns()) return false;
      if (hasInheritinputcolumns()) {
        if (getInheritinputcolumns()
                != other.getInheritinputcolumns()) return false;
      }
      if (hasInheritkeys() != other.hasInheritkeys()) return false;
      if (hasInheritkeys()) {
        if (getInheritkeys()
                != other.getInheritkeys()) return false;
      }
      if (hasRequired() != other.hasRequired()) return false;
      if (hasRequired()) {
        if (getRequired()
                != other.getRequired()) return false;
      }
      if (hasHasheader() != other.hasHasheader()) return false;
      if (hasHasheader()) {
        if (getHasheader()
                != other.getHasheader()) return false;
      }
      if (hasEncoding() != other.hasEncoding()) return false;
      if (hasEncoding()) {
        if (!getEncoding()
                .equals(other.getEncoding())) return false;
      }
      if (!getColumnList()
              .equals(other.getColumnList())) return false;
      if (!getKeyList()
              .equals(other.getKeyList())) return false;
      if (hasResortkey() != other.hasResortkey()) return false;
      if (hasResortkey()) {
        if (!getResortkey()
                .equals(other.getResortkey())) return false;
      }
      if (!getRequiresortedonkeyList()
              .equals(other.getRequiresortedonkeyList())) return false;
      if (!getNamedvalueList()
              .equals(other.getNamedvalueList())) return false;
      if (hasStripProtectedWhitespaceFromValues() != other.hasStripProtectedWhitespaceFromValues()) return false;
      if (hasStripProtectedWhitespaceFromValues()) {
        if (getStripProtectedWhitespaceFromValues()
                != other.getStripProtectedWhitespaceFromValues()) return false;
      }
      if (hasColumnCache() != other.hasColumnCache()) return false;
      if (hasColumnCache()) {
        if (!getColumnCache()
                .equals(other.getColumnCache())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasFilename()) {
        hash = (37 * hash) + FILENAME_FIELD_NUMBER;
        hash = (53 * hash) + getFilename().hashCode();
      }
      if (hasInheritfields()) {
        hash = (37 * hash) + INHERITFIELDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getInheritfields());
      }
      if (hasInheritinputcolumns()) {
        hash = (37 * hash) + INHERITINPUTCOLUMNS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getInheritinputcolumns());
      }
      if (hasInheritkeys()) {
        hash = (37 * hash) + INHERITKEYS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getInheritkeys());
      }
      if (hasRequired()) {
        hash = (37 * hash) + REQUIRED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getRequired());
      }
      if (hasHasheader()) {
        hash = (37 * hash) + HASHEADER_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getHasheader());
      }
      if (hasEncoding()) {
        hash = (37 * hash) + ENCODING_FIELD_NUMBER;
        hash = (53 * hash) + getEncoding().hashCode();
      }
      if (getColumnCount() > 0) {
        hash = (37 * hash) + COLUMN_FIELD_NUMBER;
        hash = (53 * hash) + getColumnList().hashCode();
      }
      if (getKeyCount() > 0) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + getKeyList().hashCode();
      }
      if (hasResortkey()) {
        hash = (37 * hash) + RESORTKEY_FIELD_NUMBER;
        hash = (53 * hash) + getResortkey().hashCode();
      }
      if (getRequiresortedonkeyCount() > 0) {
        hash = (37 * hash) + REQUIRESORTEDONKEY_FIELD_NUMBER;
        hash = (53 * hash) + getRequiresortedonkeyList().hashCode();
      }
      if (getNamedvalueCount() > 0) {
        hash = (37 * hash) + NAMEDVALUE_FIELD_NUMBER;
        hash = (53 * hash) + getNamedvalueList().hashCode();
      }
      if (hasStripProtectedWhitespaceFromValues()) {
        hash = (37 * hash) + STRIP_PROTECTED_WHITESPACE_FROM_VALUES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getStripProtectedWhitespaceFromValues());
      }
      if (hasColumnCache()) {
        hash = (37 * hash) + COLUMN_CACHE_FIELD_NUMBER;
        hash = (53 * hash) + getColumnCache().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csvspec.CsvSpecProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csvspec.CsvSpecProto)
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvSpecProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvSpecProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.Builder.class);
      }

      // Construct using org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getColumnFieldBuilder();
          getKeyFieldBuilder();
          getNamedvalueFieldBuilder();
          getColumnCacheFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        filename_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        inheritfields_ = false;
        bitField0_ = (bitField0_ & ~0x00000004);
        inheritinputcolumns_ = false;
        bitField0_ = (bitField0_ & ~0x00000008);
        inheritkeys_ = false;
        bitField0_ = (bitField0_ & ~0x00000010);
        required_ = true;
        bitField0_ = (bitField0_ & ~0x00000020);
        hasheader_ = true;
        bitField0_ = (bitField0_ & ~0x00000040);
        encoding_ = "UTF-8";
        bitField0_ = (bitField0_ & ~0x00000080);
        if (columnBuilder_ == null) {
          column_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000100);
        } else {
          columnBuilder_.clear();
        }
        if (keyBuilder_ == null) {
          key_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000200);
        } else {
          keyBuilder_.clear();
        }
        resortkey_ = "";
        bitField0_ = (bitField0_ & ~0x00000400);
        requiresortedonkey_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000800);
        if (namedvalueBuilder_ == null) {
          namedvalue_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00001000);
        } else {
          namedvalueBuilder_.clear();
        }
        stripProtectedWhitespaceFromValues_ = false;
        bitField0_ = (bitField0_ & ~0x00002000);
        if (columnCacheBuilder_ == null) {
          columnCache_ = null;
        } else {
          columnCacheBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00004000);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
      getDescriptorForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvSpecProto_descriptor;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto getDefaultInstanceForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto build() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto buildPartial() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto result = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          to_bitField0_ |= 0x00000002;
        }
        result.filename_ = filename_;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.inheritfields_ = inheritfields_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.inheritinputcolumns_ = inheritinputcolumns_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.inheritkeys_ = inheritkeys_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          to_bitField0_ |= 0x00000020;
        }
        result.required_ = required_;
        if (((from_bitField0_ & 0x00000040) != 0)) {
          to_bitField0_ |= 0x00000040;
        }
        result.hasheader_ = hasheader_;
        if (((from_bitField0_ & 0x00000080) != 0)) {
          to_bitField0_ |= 0x00000080;
        }
        result.encoding_ = encoding_;
        if (columnBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0)) {
            column_ = java.util.Collections.unmodifiableList(column_);
            bitField0_ = (bitField0_ & ~0x00000100);
          }
          result.column_ = column_;
        } else {
          result.column_ = columnBuilder_.build();
        }
        if (keyBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0)) {
            key_ = java.util.Collections.unmodifiableList(key_);
            bitField0_ = (bitField0_ & ~0x00000200);
          }
          result.key_ = key_;
        } else {
          result.key_ = keyBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          to_bitField0_ |= 0x00000100;
        }
        result.resortkey_ = resortkey_;
        if (((bitField0_ & 0x00000800) != 0)) {
          requiresortedonkey_ = requiresortedonkey_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000800);
        }
        result.requiresortedonkey_ = requiresortedonkey_;
        if (namedvalueBuilder_ == null) {
          if (((bitField0_ & 0x00001000) != 0)) {
            namedvalue_ = java.util.Collections.unmodifiableList(namedvalue_);
            bitField0_ = (bitField0_ & ~0x00001000);
          }
          result.namedvalue_ = namedvalue_;
        } else {
          result.namedvalue_ = namedvalueBuilder_.build();
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.stripProtectedWhitespaceFromValues_ = stripProtectedWhitespaceFromValues_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          if (columnCacheBuilder_ == null) {
            result.columnCache_ = columnCache_;
          } else {
            result.columnCache_ = columnCacheBuilder_.build();
          }
          to_bitField0_ |= 0x00000400;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto) {
          return mergeFrom((org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto other) {
        if (other == org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.getDefaultInstance())
          return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasFilename()) {
          bitField0_ |= 0x00000002;
          filename_ = other.filename_;
          onChanged();
        }
        if (other.hasInheritfields()) {
          setInheritfields(other.getInheritfields());
        }
        if (other.hasInheritinputcolumns()) {
          setInheritinputcolumns(other.getInheritinputcolumns());
        }
        if (other.hasInheritkeys()) {
          setInheritkeys(other.getInheritkeys());
        }
        if (other.hasRequired()) {
          setRequired(other.getRequired());
        }
        if (other.hasHasheader()) {
          setHasheader(other.getHasheader());
        }
        if (other.hasEncoding()) {
          bitField0_ |= 0x00000080;
          encoding_ = other.encoding_;
          onChanged();
        }
        if (columnBuilder_ == null) {
          if (!other.column_.isEmpty()) {
            if (column_.isEmpty()) {
              column_ = other.column_;
              bitField0_ = (bitField0_ & ~0x00000100);
            } else {
              ensureColumnIsMutable();
              column_.addAll(other.column_);
            }
            onChanged();
          }
        } else {
          if (!other.column_.isEmpty()) {
            if (columnBuilder_.isEmpty()) {
              columnBuilder_.dispose();
              columnBuilder_ = null;
              column_ = other.column_;
              bitField0_ = (bitField0_ & ~0x00000100);
              columnBuilder_ =
                      com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                              getColumnFieldBuilder() : null;
            } else {
              columnBuilder_.addAllMessages(other.column_);
            }
          }
        }
        if (keyBuilder_ == null) {
          if (!other.key_.isEmpty()) {
            if (key_.isEmpty()) {
              key_ = other.key_;
              bitField0_ = (bitField0_ & ~0x00000200);
            } else {
              ensureKeyIsMutable();
              key_.addAll(other.key_);
            }
            onChanged();
          }
        } else {
          if (!other.key_.isEmpty()) {
            if (keyBuilder_.isEmpty()) {
              keyBuilder_.dispose();
              keyBuilder_ = null;
              key_ = other.key_;
              bitField0_ = (bitField0_ & ~0x00000200);
              keyBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getKeyFieldBuilder() : null;
            } else {
              keyBuilder_.addAllMessages(other.key_);
            }
          }
        }
        if (other.hasResortkey()) {
          bitField0_ |= 0x00000400;
          resortkey_ = other.resortkey_;
          onChanged();
        }
        if (!other.requiresortedonkey_.isEmpty()) {
          if (requiresortedonkey_.isEmpty()) {
            requiresortedonkey_ = other.requiresortedonkey_;
            bitField0_ = (bitField0_ & ~0x00000800);
          } else {
            ensureRequiresortedonkeyIsMutable();
            requiresortedonkey_.addAll(other.requiresortedonkey_);
          }
          onChanged();
        }
        if (namedvalueBuilder_ == null) {
          if (!other.namedvalue_.isEmpty()) {
            if (namedvalue_.isEmpty()) {
              namedvalue_ = other.namedvalue_;
              bitField0_ = (bitField0_ & ~0x00001000);
            } else {
              ensureNamedvalueIsMutable();
              namedvalue_.addAll(other.namedvalue_);
            }
            onChanged();
          }
        } else {
          if (!other.namedvalue_.isEmpty()) {
            if (namedvalueBuilder_.isEmpty()) {
              namedvalueBuilder_.dispose();
              namedvalueBuilder_ = null;
              namedvalue_ = other.namedvalue_;
              bitField0_ = (bitField0_ & ~0x00001000);
              namedvalueBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getNamedvalueFieldBuilder() : null;
            } else {
              namedvalueBuilder_.addAllMessages(other.namedvalue_);
            }
          }
        }
        if (other.hasStripProtectedWhitespaceFromValues()) {
          setStripProtectedWhitespaceFromValues(other.getStripProtectedWhitespaceFromValues());
        }
        if (other.hasColumnCache()) {
          mergeColumnCache(other.getColumnCache());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasName()) {
          return false;
        }
        for (int i = 0; i < getColumnCount(); i++) {
          if (!getColumn(i).isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getKeyCount(); i++) {
          if (!getKey(i).isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getNamedvalueCount(); i++) {
          if (!getNamedvalue(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * This is the name of the csv.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * This is the name of the csv.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This is the name of the csv.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This is the name of the csv.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is the name of the csv.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is the name of the csv.
       * </pre>
       *
       * <code>required string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object filename_ = "";
      /**
       * <pre>
       * This is the file where the csv is stored, without the directory path, that
       * will be added elsewhere. Note: this is actually required, it is set as
       * optional here just so that template/extension csv specs can be valid protos
       * on their own even if this field is missing in one of them.
       * </pre>
       *
       * <code>optional string filename = 2;</code>
       */
      public boolean hasFilename() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * This is the file where the csv is stored, without the directory path, that
       * will be added elsewhere. Note: this is actually required, it is set as
       * optional here just so that template/extension csv specs can be valid protos
       * on their own even if this field is missing in one of them.
       * </pre>
       *
       * <code>optional string filename = 2;</code>
       */
      public java.lang.String getFilename() {
        java.lang.Object ref = filename_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            filename_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This is the file where the csv is stored, without the directory path, that
       * will be added elsewhere. Note: this is actually required, it is set as
       * optional here just so that template/extension csv specs can be valid protos
       * on their own even if this field is missing in one of them.
       * </pre>
       *
       * <code>optional string filename = 2;</code>
       */
      public com.google.protobuf.ByteString
          getFilenameBytes() {
        java.lang.Object ref = filename_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          filename_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This is the file where the csv is stored, without the directory path, that
       * will be added elsewhere. Note: this is actually required, it is set as
       * optional here just so that template/extension csv specs can be valid protos
       * on their own even if this field is missing in one of them.
       * </pre>
       *
       * <code>optional string filename = 2;</code>
       */
      public Builder setFilename(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        filename_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is the file where the csv is stored, without the directory path, that
       * will be added elsewhere. Note: this is actually required, it is set as
       * optional here just so that template/extension csv specs can be valid protos
       * on their own even if this field is missing in one of them.
       * </pre>
       *
       * <code>optional string filename = 2;</code>
       */
      public Builder clearFilename() {
        bitField0_ = (bitField0_ & ~0x00000002);
        filename_ = getDefaultInstance().getFilename();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is the file where the csv is stored, without the directory path, that
       * will be added elsewhere. Note: this is actually required, it is set as
       * optional here just so that template/extension csv specs can be valid protos
       * on their own even if this field is missing in one of them.
       * </pre>
       *
       * <code>optional string filename = 2;</code>
       */
      public Builder setFilenameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        filename_ = value;
        onChanged();
        return this;
      }

      private boolean inheritfields_ ;
      /**
       * <pre>
       * If a template is used for this spec, and that template contains a csv spec
       * with the same name as this, the two csv specs may be merged. These flags
       * control which parts of the resulting csv spec should be based on the
       * template.
       * - Fields: all fields of the csv spec, except column and key.
       *   This is a plain proto buffer merge, non-repeated fields may be overridden
       *   from the template, repeated fields may be added to.
       * - Input columns: any input columns of the template are added to the ones
       *   given here. If a column with the same name exists both in template and
       *   here, the two copies are merged. See ColumnSpecProto for details on that.
       * - Output columns: just like input columns, except that a column with the
       *   same name will simply override the template, none of the fields in the
       *   template output column will be preserved.
       * - Keys: like output columns.
       * </pre>
       *
       * <code>optional bool inheritfields = 12 [default = false];</code>
       */
      public boolean hasInheritfields() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * If a template is used for this spec, and that template contains a csv spec
       * with the same name as this, the two csv specs may be merged. These flags
       * control which parts of the resulting csv spec should be based on the
       * template.
       * - Fields: all fields of the csv spec, except column and key.
       *   This is a plain proto buffer merge, non-repeated fields may be overridden
       *   from the template, repeated fields may be added to.
       * - Input columns: any input columns of the template are added to the ones
       *   given here. If a column with the same name exists both in template and
       *   here, the two copies are merged. See ColumnSpecProto for details on that.
       * - Output columns: just like input columns, except that a column with the
       *   same name will simply override the template, none of the fields in the
       *   template output column will be preserved.
       * - Keys: like output columns.
       * </pre>
       *
       * <code>optional bool inheritfields = 12 [default = false];</code>
       */
      public boolean getInheritfields() {
        return inheritfields_;
      }
      /**
       * <pre>
       * If a template is used for this spec, and that template contains a csv spec
       * with the same name as this, the two csv specs may be merged. These flags
       * control which parts of the resulting csv spec should be based on the
       * template.
       * - Fields: all fields of the csv spec, except column and key.
       *   This is a plain proto buffer merge, non-repeated fields may be overridden
       *   from the template, repeated fields may be added to.
       * - Input columns: any input columns of the template are added to the ones
       *   given here. If a column with the same name exists both in template and
       *   here, the two copies are merged. See ColumnSpecProto for details on that.
       * - Output columns: just like input columns, except that a column with the
       *   same name will simply override the template, none of the fields in the
       *   template output column will be preserved.
       * - Keys: like output columns.
       * </pre>
       *
       * <code>optional bool inheritfields = 12 [default = false];</code>
       */
      public Builder setInheritfields(boolean value) {
        bitField0_ |= 0x00000004;
        inheritfields_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If a template is used for this spec, and that template contains a csv spec
       * with the same name as this, the two csv specs may be merged. These flags
       * control which parts of the resulting csv spec should be based on the
       * template.
       * - Fields: all fields of the csv spec, except column and key.
       *   This is a plain proto buffer merge, non-repeated fields may be overridden
       *   from the template, repeated fields may be added to.
       * - Input columns: any input columns of the template are added to the ones
       *   given here. If a column with the same name exists both in template and
       *   here, the two copies are merged. See ColumnSpecProto for details on that.
       * - Output columns: just like input columns, except that a column with the
       *   same name will simply override the template, none of the fields in the
       *   template output column will be preserved.
       * - Keys: like output columns.
       * </pre>
       *
       * <code>optional bool inheritfields = 12 [default = false];</code>
       */
      public Builder clearInheritfields() {
        bitField0_ = (bitField0_ & ~0x00000004);
        inheritfields_ = false;
        onChanged();
        return this;
      }

      private boolean inheritinputcolumns_ ;
      /**
       * <code>optional bool inheritinputcolumns = 13 [default = false];</code>
       */
      public boolean hasInheritinputcolumns() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional bool inheritinputcolumns = 13 [default = false];</code>
       */
      public boolean getInheritinputcolumns() {
        return inheritinputcolumns_;
      }

      /**
       * <code>optional bool inheritinputcolumns = 13 [default = false];</code>
       */
      public Builder setInheritinputcolumns(boolean value) {
        bitField0_ |= 0x00000008;
        inheritinputcolumns_ = value;
        onChanged();
        return this;
      }

      /**
       * <code>optional bool inheritinputcolumns = 13 [default = false];</code>
       */
      public Builder clearInheritinputcolumns() {
        bitField0_ = (bitField0_ & ~0x00000008);
        inheritinputcolumns_ = false;
        onChanged();
        return this;
      }

      private boolean inheritkeys_;

      /**
       * <code>optional bool inheritkeys = 15 [default = false];</code>
       */
      public boolean hasInheritkeys() {
        return ((bitField0_ & 0x00000010) != 0);
      }

      /**
       * <code>optional bool inheritkeys = 15 [default = false];</code>
       */
      public boolean getInheritkeys() {
        return inheritkeys_;
      }

      /**
       * <code>optional bool inheritkeys = 15 [default = false];</code>
       */
      public Builder setInheritkeys(boolean value) {
        bitField0_ |= 0x00000010;
        inheritkeys_ = value;
        onChanged();
        return this;
      }

      /**
       * <code>optional bool inheritkeys = 15 [default = false];</code>
       */
      public Builder clearInheritkeys() {
        bitField0_ = (bitField0_ & ~0x00000010);
        inheritkeys_ = false;
        onChanged();
        return this;
      }

      private boolean required_ = true;
      /**
       * <pre>
       * This determines what will happen if this csv is missing in the input
       * set. If true, an error will be flagged, if false, this will be silently
       * ignored and all tests on this csv, and any tests that reference it, will be
       * skipped.
       * </pre>
       *
       * <code>optional bool required = 3 [default = true];</code>
       */
      public boolean hasRequired() {
        return ((bitField0_ & 0x00000020) != 0);
      }

      /**
       * <pre>
       * This determines what will happen if this csv is missing in the input
       * set. If true, an error will be flagged, if false, this will be silently
       * ignored and all tests on this csv, and any tests that reference it, will be
       * skipped.
       * </pre>
       *
       * <code>optional bool required = 3 [default = true];</code>
       */
      public boolean getRequired() {
        return required_;
      }

      /**
       * <pre>
       * This determines what will happen if this csv is missing in the input
       * set. If true, an error will be flagged, if false, this will be silently
       * ignored and all tests on this csv, and any tests that reference it, will be
       * skipped.
       * </pre>
       *
       * <code>optional bool required = 3 [default = true];</code>
       */
      public Builder setRequired(boolean value) {
        bitField0_ |= 0x00000020;
        required_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * This determines what will happen if this csv is missing in the input
       * set. If true, an error will be flagged, if false, this will be silently
       * ignored and all tests on this csv, and any tests that reference it, will be
       * skipped.
       * </pre>
       *
       * <code>optional bool required = 3 [default = true];</code>
       */
      public Builder clearRequired() {
        bitField0_ = (bitField0_ & ~0x00000020);
        required_ = true;
        onChanged();
        return this;
      }

      private boolean hasheader_ = true;
      /**
       * <pre>
       * If this is true, the first row of the input file will be interpreted as
       * column names.
       * </pre>
       *
       * <code>optional bool hasheader = 4 [default = true];</code>
       */
      public boolean hasHasheader() {
        return ((bitField0_ & 0x00000040) != 0);
      }

      /**
       * <pre>
       * If this is true, the first row of the input file will be interpreted as
       * column names.
       * </pre>
       *
       * <code>optional bool hasheader = 4 [default = true];</code>
       */
      public boolean getHasheader() {
        return hasheader_;
      }

      /**
       * <pre>
       * If this is true, the first row of the input file will be interpreted as
       * column names.
       * </pre>
       *
       * <code>optional bool hasheader = 4 [default = true];</code>
       */
      public Builder setHasheader(boolean value) {
        bitField0_ |= 0x00000040;
        hasheader_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * If this is true, the first row of the input file will be interpreted as
       * column names.
       * </pre>
       *
       * <code>optional bool hasheader = 4 [default = true];</code>
       */
      public Builder clearHasheader() {
        bitField0_ = (bitField0_ & ~0x00000040);
        hasheader_ = true;
        onChanged();
        return this;
      }

      private java.lang.Object encoding_ = "UTF-8";

      /**
       * <pre>
       * The character encoding of the document.
       * </pre>
       *
       * <code>optional string encoding = 5 [default = "UTF-8"];</code>
       */
      public boolean hasEncoding() {
        return ((bitField0_ & 0x00000080) != 0);
      }

      /**
       * <pre>
       * The character encoding of the document.
       * </pre>
       *
       * <code>optional string encoding = 5 [default = "UTF-8"];</code>
       */
      public java.lang.String getEncoding() {
        java.lang.Object ref = encoding_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
                  (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            encoding_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }

      /**
       * <pre>
       * The character encoding of the document.
       * </pre>
       *
       * <code>optional string encoding = 5 [default = "UTF-8"];</code>
       */
      public com.google.protobuf.ByteString
      getEncodingBytes() {
        java.lang.Object ref = encoding_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
                  com.google.protobuf.ByteString.copyFromUtf8(
                          (java.lang.String) ref);
          encoding_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       * <pre>
       * The character encoding of the document.
       * </pre>
       *
       * <code>optional string encoding = 5 [default = "UTF-8"];</code>
       */
      public Builder setEncoding(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000080;
        encoding_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The character encoding of the document.
       * </pre>
       *
       * <code>optional string encoding = 5 [default = "UTF-8"];</code>
       */
      public Builder clearEncoding() {
        bitField0_ = (bitField0_ & ~0x00000080);
        encoding_ = getDefaultInstance().getEncoding();
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The character encoding of the document.
       * </pre>
       *
       * <code>optional string encoding = 5 [default = "UTF-8"];</code>
       */
      public Builder setEncodingBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000080;
        encoding_ = value;
        onChanged();
        return this;
      }

      private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto> column_ =
              java.util.Collections.emptyList();

      private void ensureColumnIsMutable() {
        if (!((bitField0_ & 0x00000100) != 0)) {
          column_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto>(column_);
          bitField0_ |= 0x00000100;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder> columnBuilder_;

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto> getColumnList() {
        if (columnBuilder_ == null) {
          return java.util.Collections.unmodifiableList(column_);
        } else {
          return columnBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public int getColumnCount() {
        if (columnBuilder_ == null) {
          return column_.size();
        } else {
          return columnBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto getColumn(int index) {
        if (columnBuilder_ == null) {
          return column_.get(index);
        } else {
          return columnBuilder_.getMessage(index);
        }
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public Builder setColumn(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto value) {
        if (columnBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureColumnIsMutable();
          column_.set(index, value);
          onChanged();
        } else {
          columnBuilder_.setMessage(index, value);
        }
        return this;
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public Builder setColumn(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder builderForValue) {
        if (columnBuilder_ == null) {
          ensureColumnIsMutable();
          column_.set(index, builderForValue.build());
          onChanged();
        } else {
          columnBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public Builder addColumn(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto value) {
        if (columnBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureColumnIsMutable();
          column_.add(value);
          onChanged();
        } else {
          columnBuilder_.addMessage(value);
        }
        return this;
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public Builder addColumn(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto value) {
        if (columnBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureColumnIsMutable();
          column_.add(index, value);
          onChanged();
        } else {
          columnBuilder_.addMessage(index, value);
        }
        return this;
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public Builder addColumn(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder builderForValue) {
        if (columnBuilder_ == null) {
          ensureColumnIsMutable();
          column_.add(builderForValue.build());
          onChanged();
        } else {
          columnBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public Builder addColumn(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder builderForValue) {
        if (columnBuilder_ == null) {
          ensureColumnIsMutable();
          column_.add(index, builderForValue.build());
          onChanged();
        } else {
          columnBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public Builder addAllColumn(
              java.lang.Iterable<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto> values) {
        if (columnBuilder_ == null) {
          ensureColumnIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
                  values, column_);
          onChanged();
        } else {
          columnBuilder_.addAllMessages(values);
        }
        return this;
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public Builder clearColumn() {
        if (columnBuilder_ == null) {
          column_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000100);
          onChanged();
        } else {
          columnBuilder_.clear();
        }
        return this;
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public Builder removeColumn(int index) {
        if (columnBuilder_ == null) {
          ensureColumnIsMutable();
          column_.remove(index);
          onChanged();
        } else {
          columnBuilder_.remove(index);
        }
        return this;
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder getColumnBuilder(
              int index) {
        return getColumnFieldBuilder().getBuilder(index);
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder getColumnOrBuilder(
              int index) {
        if (columnBuilder_ == null) {
          return column_.get(index);
        } else {
          return columnBuilder_.getMessageOrBuilder(index);
        }
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder>
      getColumnOrBuilderList() {
        if (columnBuilder_ != null) {
          return columnBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(column_);
        }
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder addColumnBuilder() {
        return getColumnFieldBuilder().addBuilder(
                org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.getDefaultInstance());
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder addColumnBuilder(
              int index) {
        return getColumnFieldBuilder().addBuilder(
                index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.getDefaultInstance());
      }

      /**
       * <pre>
       * The subset of columns to be used from this table. Existence of the given
       * columns will be verified (as well as any properties specified).
       * </pre>
       *
       * <code>repeated .csvspec.ColumnSpecProto column = 6;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder>
      getColumnBuilderList() {
        return getColumnFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder>
      getColumnFieldBuilder() {
        if (columnBuilder_ == null) {
          columnBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder>(
                  column_,
                  ((bitField0_ & 0x00000100) != 0),
                  getParentForChildren(),
                  isClean());
          column_ = null;
        }
        return columnBuilder_;
      }

      private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto> key_ =
        java.util.Collections.emptyList();
      private void ensureKeyIsMutable() {
        if (!((bitField0_ & 0x00000200) != 0)) {
          key_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto>(key_);
          bitField0_ |= 0x00000200;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProtoOrBuilder> keyBuilder_;

      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto> getKeyList() {
        if (keyBuilder_ == null) {
          return java.util.Collections.unmodifiableList(key_);
        } else {
          return keyBuilder_.getMessageList();
        }
      }

      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public int getKeyCount() {
        if (keyBuilder_ == null) {
          return key_.size();
        } else {
          return keyBuilder_.getCount();
        }
      }

      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto getKey(int index) {
        if (keyBuilder_ == null) {
          return key_.get(index);
        } else {
          return keyBuilder_.getMessage(index);
        }
      }

      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public Builder setKey(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto value) {
        if (keyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeyIsMutable();
          key_.set(index, value);
          onChanged();
        } else {
          keyBuilder_.setMessage(index, value);
        }
        return this;
      }

      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public Builder setKey(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.Builder builderForValue) {
        if (keyBuilder_ == null) {
          ensureKeyIsMutable();
          key_.set(index, builderForValue.build());
          onChanged();
        } else {
          keyBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public Builder addKey(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto value) {
        if (keyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeyIsMutable();
          key_.add(value);
          onChanged();
        } else {
          keyBuilder_.addMessage(value);
        }
        return this;
      }

      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public Builder addKey(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto value) {
        if (keyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeyIsMutable();
          key_.add(index, value);
          onChanged();
        } else {
          keyBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public Builder addKey(
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.Builder builderForValue) {
        if (keyBuilder_ == null) {
          ensureKeyIsMutable();
          key_.add(builderForValue.build());
          onChanged();
        } else {
          keyBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public Builder addKey(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.Builder builderForValue) {
        if (keyBuilder_ == null) {
          ensureKeyIsMutable();
          key_.add(index, builderForValue.build());
          onChanged();
        } else {
          keyBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public Builder addAllKey(
              java.lang.Iterable<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto> values) {
        if (keyBuilder_ == null) {
          ensureKeyIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
                  values, key_);
          onChanged();
        } else {
          keyBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public Builder clearKey() {
        if (keyBuilder_ == null) {
          key_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000200);
          onChanged();
        } else {
          keyBuilder_.clear();
        }
        return this;
      }

      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public Builder removeKey(int index) {
        if (keyBuilder_ == null) {
          ensureKeyIsMutable();
          key_.remove(index);
          onChanged();
        } else {
          keyBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.Builder getKeyBuilder(
              int index) {
        return getKeyFieldBuilder().getBuilder(index);
      }

      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProtoOrBuilder getKeyOrBuilder(
              int index) {
        if (keyBuilder_ == null) {
          return key_.get(index);
        } else {
          return keyBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProtoOrBuilder> 
           getKeyOrBuilderList() {
        if (keyBuilder_ != null) {
          return keyBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(key_);
        }
      }

      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.Builder addKeyBuilder() {
        return getKeyFieldBuilder().addBuilder(
                org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.getDefaultInstance());
      }

      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.Builder addKeyBuilder(
              int index) {
        return getKeyFieldBuilder().addBuilder(
                index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.getDefaultInstance());
      }

      /**
       * <pre>
       * The keys of this table. A key is a tuple of one or more columns from the
       * same table.
       * </pre>
       *
       * <code>repeated .csvspec.KeySpecProto key = 7;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.Builder>
      getKeyBuilderList() {
        return getKeyFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProtoOrBuilder>
      getKeyFieldBuilder() {
        if (keyBuilder_ == null) {
          keyBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.KeySpecProtoOrBuilder>(
                  key_,
                  ((bitField0_ & 0x00000200) != 0),
                  getParentForChildren(),
                  isClean());
          key_ = null;
        }
        return keyBuilder_;
      }

      private java.lang.Object resortkey_ = "";
      /**
       * <pre>
       * The table rows will be re-sorted on this key. The first column of the key
       * is the most significant.
       * </pre>
       *
       * <code>optional string resortkey = 8;</code>
       */
      public boolean hasResortkey() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * The table rows will be re-sorted on this key. The first column of the key
       * is the most significant.
       * </pre>
       *
       * <code>optional string resortkey = 8;</code>
       */
      public java.lang.String getResortkey() {
        java.lang.Object ref = resortkey_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
                  (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            resortkey_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }

      /**
       * <pre>
       * The table rows will be re-sorted on this key. The first column of the key
       * is the most significant.
       * </pre>
       *
       * <code>optional string resortkey = 8;</code>
       */
      public com.google.protobuf.ByteString
      getResortkeyBytes() {
        java.lang.Object ref = resortkey_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
                  com.google.protobuf.ByteString.copyFromUtf8(
                          (java.lang.String) ref);
          resortkey_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       * <pre>
       * The table rows will be re-sorted on this key. The first column of the key
       * is the most significant.
       * </pre>
       *
       * <code>optional string resortkey = 8;</code>
       */
      public Builder setResortkey(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000400;
        resortkey_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The table rows will be re-sorted on this key. The first column of the key
       * is the most significant.
       * </pre>
       *
       * <code>optional string resortkey = 8;</code>
       */
      public Builder clearResortkey() {
        bitField0_ = (bitField0_ & ~0x00000400);
        resortkey_ = getDefaultInstance().getResortkey();
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The table rows will be re-sorted on this key. The first column of the key
       * is the most significant.
       * </pre>
       *
       * <code>optional string resortkey = 8;</code>
       */
      public Builder setResortkeyBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000400;
        resortkey_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList requiresortedonkey_ = com.google.protobuf.LazyStringArrayList.EMPTY;

      private void ensureRequiresortedonkeyIsMutable() {
        if (!((bitField0_ & 0x00000800) != 0)) {
          requiresortedonkey_ = new com.google.protobuf.LazyStringArrayList(requiresortedonkey_);
          bitField0_ |= 0x00000800;
        }
      }

      /**
       * <pre>
       * The table rows will be required to be sorted on these keys. Note: If there
       * is a re-sorting key specified as well, the re-sorting will be carried out
       * before this check.
       * </pre>
       *
       * <code>repeated string requiresortedonkey = 9;</code>
       */
      public com.google.protobuf.ProtocolStringList
      getRequiresortedonkeyList() {
        return requiresortedonkey_.getUnmodifiableView();
      }

      /**
       * <pre>
       * The table rows will be required to be sorted on these keys. Note: If there
       * is a re-sorting key specified as well, the re-sorting will be carried out
       * before this check.
       * </pre>
       *
       * <code>repeated string requiresortedonkey = 9;</code>
       */
      public int getRequiresortedonkeyCount() {
        return requiresortedonkey_.size();
      }

      /**
       * <pre>
       * The table rows will be required to be sorted on these keys. Note: If there
       * is a re-sorting key specified as well, the re-sorting will be carried out
       * before this check.
       * </pre>
       *
       * <code>repeated string requiresortedonkey = 9;</code>
       */
      public java.lang.String getRequiresortedonkey(int index) {
        return requiresortedonkey_.get(index);
      }

      /**
       * <pre>
       * The table rows will be required to be sorted on these keys. Note: If there
       * is a re-sorting key specified as well, the re-sorting will be carried out
       * before this check.
       * </pre>
       *
       * <code>repeated string requiresortedonkey = 9;</code>
       */
      public com.google.protobuf.ByteString
      getRequiresortedonkeyBytes(int index) {
        return requiresortedonkey_.getByteString(index);
      }

      /**
       * <pre>
       * The table rows will be required to be sorted on these keys. Note: If there
       * is a re-sorting key specified as well, the re-sorting will be carried out
       * before this check.
       * </pre>
       *
       * <code>repeated string requiresortedonkey = 9;</code>
       */
      public Builder setRequiresortedonkey(
              int index, java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRequiresortedonkeyIsMutable();
        requiresortedonkey_.set(index, value);
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The table rows will be required to be sorted on these keys. Note: If there
       * is a re-sorting key specified as well, the re-sorting will be carried out
       * before this check.
       * </pre>
       *
       * <code>repeated string requiresortedonkey = 9;</code>
       */
      public Builder addRequiresortedonkey(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRequiresortedonkeyIsMutable();
        requiresortedonkey_.add(value);
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The table rows will be required to be sorted on these keys. Note: If there
       * is a re-sorting key specified as well, the re-sorting will be carried out
       * before this check.
       * </pre>
       *
       * <code>repeated string requiresortedonkey = 9;</code>
       */
      public Builder addAllRequiresortedonkey(
              java.lang.Iterable<java.lang.String> values) {
        ensureRequiresortedonkeyIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
                values, requiresortedonkey_);
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The table rows will be required to be sorted on these keys. Note: If there
       * is a re-sorting key specified as well, the re-sorting will be carried out
       * before this check.
       * </pre>
       *
       * <code>repeated string requiresortedonkey = 9;</code>
       */
      public Builder clearRequiresortedonkey() {
        requiresortedonkey_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000800);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The table rows will be required to be sorted on these keys. Note: If there
       * is a re-sorting key specified as well, the re-sorting will be carried out
       * before this check.
       * </pre>
       *
       * <code>repeated string requiresortedonkey = 9;</code>
       */
      public Builder addRequiresortedonkeyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureRequiresortedonkeyIsMutable();
        requiresortedonkey_.add(value);
        onChanged();
        return this;
      }

      private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> namedvalue_ =
              java.util.Collections.emptyList();

      private void ensureNamedvalueIsMutable() {
        if (!((bitField0_ & 0x00001000) != 0)) {
          namedvalue_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto>(namedvalue_);
          bitField0_ |= 0x00001000;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder> namedvalueBuilder_;

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> getNamedvalueList() {
        if (namedvalueBuilder_ == null) {
          return java.util.Collections.unmodifiableList(namedvalue_);
        } else {
          return namedvalueBuilder_.getMessageList();
        }
      }

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public int getNamedvalueCount() {
        if (namedvalueBuilder_ == null) {
          return namedvalue_.size();
        } else {
          return namedvalueBuilder_.getCount();
        }
      }

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto getNamedvalue(int index) {
        if (namedvalueBuilder_ == null) {
          return namedvalue_.get(index);
        } else {
          return namedvalueBuilder_.getMessage(index);
        }
      }

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder setNamedvalue(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto value) {
        if (namedvalueBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNamedvalueIsMutable();
          namedvalue_.set(index, value);
          onChanged();
        } else {
          namedvalueBuilder_.setMessage(index, value);
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder setNamedvalue(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder builderForValue) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          namedvalue_.set(index, builderForValue.build());
          onChanged();
        } else {
          namedvalueBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder addNamedvalue(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto value) {
        if (namedvalueBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNamedvalueIsMutable();
          namedvalue_.add(value);
          onChanged();
        } else {
          namedvalueBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder addNamedvalue(
          int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto value) {
        if (namedvalueBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNamedvalueIsMutable();
          namedvalue_.add(index, value);
          onChanged();
        } else {
          namedvalueBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder addNamedvalue(
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder builderForValue) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          namedvalue_.add(builderForValue.build());
          onChanged();
        } else {
          namedvalueBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder addNamedvalue(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder builderForValue) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          namedvalue_.add(index, builderForValue.build());
          onChanged();
        } else {
          namedvalueBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder addAllNamedvalue(
              java.lang.Iterable<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> values) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
                  values, namedvalue_);
          onChanged();
        } else {
          namedvalueBuilder_.addAllMessages(values);
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder clearNamedvalue() {
        if (namedvalueBuilder_ == null) {
          namedvalue_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00001000);
          onChanged();
        } else {
          namedvalueBuilder_.clear();
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public Builder removeNamedvalue(int index) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          namedvalue_.remove(index);
          onChanged();
        } else {
          namedvalueBuilder_.remove(index);
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder getNamedvalueBuilder(
              int index) {
        return getNamedvalueFieldBuilder().getBuilder(index);
      }

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder getNamedvalueOrBuilder(
              int index) {
        if (namedvalueBuilder_ == null) {
          return namedvalue_.get(index);
        } else {
          return namedvalueBuilder_.getMessageOrBuilder(index);
        }
      }

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder>
      getNamedvalueOrBuilderList() {
        if (namedvalueBuilder_ != null) {
          return namedvalueBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(namedvalue_);
        }
      }
      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder addNamedvalueBuilder() {
        return getNamedvalueFieldBuilder().addBuilder(
                org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.getDefaultInstance());
      }

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder addNamedvalueBuilder(
              int index) {
        return getNamedvalueFieldBuilder().addBuilder(
                index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.getDefaultInstance());
      }

      /**
       * <pre>
       * Specifies names for certain values for columns of this csv spec.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 16;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder>
      getNamedvalueBuilderList() {
        return getNamedvalueFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder>
      getNamedvalueFieldBuilder() {
        if (namedvalueBuilder_ == null) {
          namedvalueBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder>(
                  namedvalue_,
                  ((bitField0_ & 0x00001000) != 0),
                  getParentForChildren(),
                  isClean());
          namedvalue_ = null;
        }
        return namedvalueBuilder_;
      }

      private boolean stripProtectedWhitespaceFromValues_;

      /**
       * <pre>
       * If set, overrides behavior inherited from CsvSpecProtos.
       * </pre>
       *
       * <code>optional bool strip_protected_whitespace_from_values = 18;</code>
       */
      public boolean hasStripProtectedWhitespaceFromValues() {
        return ((bitField0_ & 0x00002000) != 0);
      }

      /**
       * <pre>
       * If set, overrides behavior inherited from CsvSpecProtos.
       * </pre>
       *
       * <code>optional bool strip_protected_whitespace_from_values = 18;</code>
       */
      public boolean getStripProtectedWhitespaceFromValues() {
        return stripProtectedWhitespaceFromValues_;
      }
      /**
       * <pre>
       * If set, overrides behavior inherited from CsvSpecProtos.
       * </pre>
       *
       * <code>optional bool strip_protected_whitespace_from_values = 18;</code>
       */
      public Builder setStripProtectedWhitespaceFromValues(boolean value) {
        bitField0_ |= 0x00002000;
        stripProtectedWhitespaceFromValues_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * If set, overrides behavior inherited from CsvSpecProtos.
       * </pre>
       *
       * <code>optional bool strip_protected_whitespace_from_values = 18;</code>
       */
      public Builder clearStripProtectedWhitespaceFromValues() {
        bitField0_ = (bitField0_ & ~0x00002000);
        stripProtectedWhitespaceFromValues_ = false;
        onChanged();
        return this;
      }

      private org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto columnCache_;
      private com.google.protobuf.SingleFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder> columnCacheBuilder_;

      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in this
       * CSV file. Can be overwritten on a per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
       */
      public boolean hasColumnCache() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in this
       * CSV file. Can be overwritten on a per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto getColumnCache() {
        if (columnCacheBuilder_ == null) {
          return columnCache_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance() : columnCache_;
        } else {
          return columnCacheBuilder_.getMessage();
        }
      }

      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in this
       * CSV file. Can be overwritten on a per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
       */
      public Builder setColumnCache(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto value) {
        if (columnCacheBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          columnCache_ = value;
          onChanged();
        } else {
          columnCacheBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00004000;
        return this;
      }

      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in this
       * CSV file. Can be overwritten on a per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
       */
      public Builder setColumnCache(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder builderForValue) {
        if (columnCacheBuilder_ == null) {
          columnCache_ = builderForValue.build();
          onChanged();
        } else {
          columnCacheBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00004000;
        return this;
      }

      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in this
       * CSV file. Can be overwritten on a per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
       */
      public Builder mergeColumnCache(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto value) {
        if (columnCacheBuilder_ == null) {
          if (((bitField0_ & 0x00004000) != 0) &&
                  columnCache_ != null &&
                  columnCache_ != org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance()) {
            columnCache_ =
                    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.newBuilder(columnCache_).mergeFrom(value).buildPartial();
          } else {
            columnCache_ = value;
          }
          onChanged();
        } else {
          columnCacheBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in this
       * CSV file. Can be overwritten on a per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
       */
      public Builder clearColumnCache() {
        if (columnCacheBuilder_ == null) {
          columnCache_ = null;
          onChanged();
        } else {
          columnCacheBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00004000);
        return this;
      }
      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in this
       * CSV file. Can be overwritten on a per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder getColumnCacheBuilder() {
        bitField0_ |= 0x00004000;
        onChanged();
        return getColumnCacheFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in this
       * CSV file. Can be overwritten on a per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder getColumnCacheOrBuilder() {
        if (columnCacheBuilder_ != null) {
          return columnCacheBuilder_.getMessageOrBuilder();
        } else {
          return columnCache_ == null ?
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance() : columnCache_;
        }
      }

      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in this
       * CSV file. Can be overwritten on a per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 19;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder>
      getColumnCacheFieldBuilder() {
        if (columnCacheBuilder_ == null) {
          columnCacheBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder>(
                  getColumnCache(),
                  getParentForChildren(),
                  isClean());
          columnCache_ = null;
        }
        return columnCacheBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csvspec.CsvSpecProto)
    }

    // @@protoc_insertion_point(class_scope:csvspec.CsvSpecProto)
    private static final org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto();
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<CsvSpecProto>
            PARSER = new com.google.protobuf.AbstractParser<CsvSpecProto>() {
      @java.lang.Override
      public CsvSpecProto parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return new CsvSpecProto(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CsvSpecProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CsvSpecProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CsvSpecProtosOrBuilder extends
          // @@protoc_insertion_point(interface_extends:csvspec.CsvSpecProtos)
          com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A template file to base this csv spec file on (see CsvSpecProto for
     * details). Path relative to this file.
     * </pre>
     *
     * <code>optional string templatefile = 2;</code>
     */
    boolean hasTemplatefile();

    /**
     * <pre>
     * A template file to base this csv spec file on (see CsvSpecProto for
     * details). Path relative to this file.
     * </pre>
     *
     * <code>optional string templatefile = 2;</code>
     */
    java.lang.String getTemplatefile();

    /**
     * <pre>
     * A template file to base this csv spec file on (see CsvSpecProto for
     * details). Path relative to this file.
     * </pre>
     *
     * <code>optional string templatefile = 2;</code>
     */
    com.google.protobuf.ByteString
        getTemplatefileBytes();

    /**
     * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
     */
    java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto>
    getCsvspecList();

    /**
     * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto getCsvspec(int index);
    /**
     * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
     */
    int getCsvspecCount();

    /**
     * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
     */
    java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtoOrBuilder>
    getCsvspecOrBuilderList();

    /**
     * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtoOrBuilder getCsvspecOrBuilder(
            int index);

    /**
     * <pre>
     * Specifies names for certain values of columns of any of these csv specs.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
     */
    java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> 
        getNamedvalueList();
    /**
     * <pre>
     * Specifies names for certain values of columns of any of these csv specs.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto getNamedvalue(int index);

    /**
     * <pre>
     * Specifies names for certain values of columns of any of these csv specs.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
     */
    int getNamedvalueCount();
    /**
     * <pre>
     * Specifies names for certain values of columns of any of these csv specs.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
     */
    java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder> 
        getNamedvalueOrBuilderList();
    /**
     * <pre>
     * Specifies names for certain values of columns of any of these csv specs.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder getNamedvalueOrBuilder(
        int index);

    /**
     * <pre>
     * If true, protected whitespace will be stripped from CSV values when they
     * are read.  Note that the existing Google CSV parser implementation will
     * strip whitespace from values (eg. ' a, b , c' producing [a,b,c]).
     * However, whitespace for a value can be protected for a value by enclosing
     * it in double quotes (eg. '" a "," b "," c"' producing [ a , b , c]).
     * Controls default setting for all files in a CSV bundle.
     * </pre>
     *
     * <code>optional bool strip_protected_whitespace_from_values = 4 [default = false];</code>
     */
    boolean hasStripProtectedWhitespaceFromValues();
    /**
     * <pre>
     * If true, protected whitespace will be stripped from CSV values when they
     * are read.  Note that the existing Google CSV parser implementation will
     * strip whitespace from values (eg. ' a, b , c' producing [a,b,c]).
     * However, whitespace for a value can be protected for a value by enclosing
     * it in double quotes (eg. '" a "," b "," c"' producing [ a , b , c]).
     * Controls default setting for all files in a CSV bundle.
     * </pre>
     *
     * <code>optional bool strip_protected_whitespace_from_values = 4 [default = false];</code>
     */
    boolean getStripProtectedWhitespaceFromValues();

    /**
     * <pre>
     * Define a default column-value caching strategy across all columns in all
     * CSV files. Can be overwritten on a per-file and per-column basis.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
     */
    boolean hasColumnCache();

    /**
     * <pre>
     * Define a default column-value caching strategy across all columns in all
     * CSV files. Can be overwritten on a per-file and per-column basis.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto getColumnCache();

    /**
     * <pre>
     * Define a default column-value caching strategy across all columns in all
     * CSV files. Can be overwritten on a per-file and per-column basis.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder getColumnCacheOrBuilder();
  }

  /**
   * Protobuf type {@code csvspec.CsvSpecProtos}
   */
  public static final class CsvSpecProtos extends
          com.google.protobuf.GeneratedMessageV3 implements
          // @@protoc_insertion_point(message_implements:csvspec.CsvSpecProtos)
          CsvSpecProtosOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use CsvSpecProtos.newBuilder() to construct.
    private CsvSpecProtos(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private CsvSpecProtos() {
      templatefile_ = "";
      csvspec_ = java.util.Collections.emptyList();
      namedvalue_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
            UnusedPrivateParameter unused) {
      return new CsvSpecProtos();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }

    private CsvSpecProtos(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
              com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                csvspec_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto>();
                mutable_bitField0_ |= 0x00000002;
              }
              csvspec_.add(
                  input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.PARSER, extensionRegistry));
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              templatefile_ = bs;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) != 0)) {
                namedvalue_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto>();
                mutable_bitField0_ |= 0x00000004;
              }
              namedvalue_.add(
                  input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.PARSER, extensionRegistry));
              break;
            }
            case 32: {
              bitField0_ |= 0x00000002;
              stripProtectedWhitespaceFromValues_ = input.readBool();
              break;
            }
            case 42: {
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) != 0)) {
                subBuilder = columnCache_.toBuilder();
              }
              columnCache_ = input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(columnCache_);
                columnCache_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
                e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) != 0)) {
          csvspec_ = java.util.Collections.unmodifiableList(csvspec_);
        }
        if (((mutable_bitField0_ & 0x00000004) != 0)) {
          namedvalue_ = java.util.Collections.unmodifiableList(namedvalue_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor
    getDescriptor() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvSpecProtos_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
    internalGetFieldAccessorTable() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvSpecProtos_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos.Builder.class);
    }

    private int bitField0_;
    public static final int TEMPLATEFILE_FIELD_NUMBER = 2;
    private volatile java.lang.Object templatefile_;
    /**
     * <pre>
     * A template file to base this csv spec file on (see CsvSpecProto for
     * details). Path relative to this file.
     * </pre>
     *
     * <code>optional string templatefile = 2;</code>
     */
    public boolean hasTemplatefile() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     * <pre>
     * A template file to base this csv spec file on (see CsvSpecProto for
     * details). Path relative to this file.
     * </pre>
     *
     * <code>optional string templatefile = 2;</code>
     */
    public java.lang.String getTemplatefile() {
      java.lang.Object ref = templatefile_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          templatefile_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A template file to base this csv spec file on (see CsvSpecProto for
     * details). Path relative to this file.
     * </pre>
     *
     * <code>optional string templatefile = 2;</code>
     */
    public com.google.protobuf.ByteString
        getTemplatefileBytes() {
      java.lang.Object ref = templatefile_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        templatefile_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CSVSPEC_FIELD_NUMBER = 1;
    private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto> csvspec_;

    /**
     * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
     */
    public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto> getCsvspecList() {
      return csvspec_;
    }
    /**
     * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
     */
    public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtoOrBuilder>
    getCsvspecOrBuilderList() {
      return csvspec_;
    }

    /**
     * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
     */
    public int getCsvspecCount() {
      return csvspec_.size();
    }
    /**
     * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto getCsvspec(int index) {
      return csvspec_.get(index);
    }
    /**
     * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtoOrBuilder getCsvspecOrBuilder(
        int index) {
      return csvspec_.get(index);
    }

    public static final int NAMEDVALUE_FIELD_NUMBER = 3;
    private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> namedvalue_;
    /**
     * <pre>
     * Specifies names for certain values of columns of any of these csv specs.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
     */
    public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> getNamedvalueList() {
      return namedvalue_;
    }
    /**
     * <pre>
     * Specifies names for certain values of columns of any of these csv specs.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
     */
    public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder> 
        getNamedvalueOrBuilderList() {
      return namedvalue_;
    }
    /**
     * <pre>
     * Specifies names for certain values of columns of any of these csv specs.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
     */
    public int getNamedvalueCount() {
      return namedvalue_.size();
    }

    /**
     * <pre>
     * Specifies names for certain values of columns of any of these csv specs.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto getNamedvalue(int index) {
      return namedvalue_.get(index);
    }
    /**
     * <pre>
     * Specifies names for certain values of columns of any of these csv specs.
     * </pre>
     *
     * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder getNamedvalueOrBuilder(
            int index) {
      return namedvalue_.get(index);
    }

    public static final int STRIP_PROTECTED_WHITESPACE_FROM_VALUES_FIELD_NUMBER = 4;
    private boolean stripProtectedWhitespaceFromValues_;

    /**
     * <pre>
     * If true, protected whitespace will be stripped from CSV values when they
     * are read.  Note that the existing Google CSV parser implementation will
     * strip whitespace from values (eg. ' a, b , c' producing [a,b,c]).
     * However, whitespace for a value can be protected for a value by enclosing
     * it in double quotes (eg. '" a "," b "," c"' producing [ a , b , c]).
     * Controls default setting for all files in a CSV bundle.
     * </pre>
     *
     * <code>optional bool strip_protected_whitespace_from_values = 4 [default = false];</code>
     */
    public boolean hasStripProtectedWhitespaceFromValues() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     * <pre>
     * If true, protected whitespace will be stripped from CSV values when they
     * are read.  Note that the existing Google CSV parser implementation will
     * strip whitespace from values (eg. ' a, b , c' producing [a,b,c]).
     * However, whitespace for a value can be protected for a value by enclosing
     * it in double quotes (eg. '" a "," b "," c"' producing [ a , b , c]).
     * Controls default setting for all files in a CSV bundle.
     * </pre>
     *
     * <code>optional bool strip_protected_whitespace_from_values = 4 [default = false];</code>
     */
    public boolean getStripProtectedWhitespaceFromValues() {
      return stripProtectedWhitespaceFromValues_;
    }

    public static final int COLUMN_CACHE_FIELD_NUMBER = 5;
    private org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto columnCache_;

    /**
     * <pre>
     * Define a default column-value caching strategy across all columns in all
     * CSV files. Can be overwritten on a per-file and per-column basis.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
     */
    public boolean hasColumnCache() {
      return ((bitField0_ & 0x00000004) != 0);
    }

    /**
     * <pre>
     * Define a default column-value caching strategy across all columns in all
     * CSV files. Can be overwritten on a per-file and per-column basis.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto getColumnCache() {
      return columnCache_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance() : columnCache_;
    }

    /**
     * <pre>
     * Define a default column-value caching strategy across all columns in all
     * CSV files. Can be overwritten on a per-file and per-column basis.
     * </pre>
     *
     * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder getColumnCacheOrBuilder() {
      return columnCache_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance() : columnCache_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getCsvspecCount(); i++) {
        if (!getCsvspec(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getNamedvalueCount(); i++) {
        if (!getNamedvalue(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      for (int i = 0; i < csvspec_.size(); i++) {
        output.writeMessage(1, csvspec_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, templatefile_);
      }
      for (int i = 0; i < namedvalue_.size(); i++) {
        output.writeMessage(3, namedvalue_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBool(4, stripProtectedWhitespaceFromValues_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(5, getColumnCache());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < csvspec_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(1, csvspec_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, templatefile_);
      }
      for (int i = 0; i < namedvalue_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(3, namedvalue_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
                .computeBoolSize(4, stripProtectedWhitespaceFromValues_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(5, getColumnCache());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos)) {
        return super.equals(obj);
      }
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos other = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos) obj;

      if (hasTemplatefile() != other.hasTemplatefile()) return false;
      if (hasTemplatefile()) {
        if (!getTemplatefile()
            .equals(other.getTemplatefile())) return false;
      }
      if (!getCsvspecList()
          .equals(other.getCsvspecList())) return false;
      if (!getNamedvalueList()
          .equals(other.getNamedvalueList())) return false;
      if (hasStripProtectedWhitespaceFromValues() != other.hasStripProtectedWhitespaceFromValues()) return false;
      if (hasStripProtectedWhitespaceFromValues()) {
        if (getStripProtectedWhitespaceFromValues()
                != other.getStripProtectedWhitespaceFromValues()) return false;
      }
      if (hasColumnCache() != other.hasColumnCache()) return false;
      if (hasColumnCache()) {
        if (!getColumnCache()
                .equals(other.getColumnCache())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasTemplatefile()) {
        hash = (37 * hash) + TEMPLATEFILE_FIELD_NUMBER;
        hash = (53 * hash) + getTemplatefile().hashCode();
      }
      if (getCsvspecCount() > 0) {
        hash = (37 * hash) + CSVSPEC_FIELD_NUMBER;
        hash = (53 * hash) + getCsvspecList().hashCode();
      }
      if (getNamedvalueCount() > 0) {
        hash = (37 * hash) + NAMEDVALUE_FIELD_NUMBER;
        hash = (53 * hash) + getNamedvalueList().hashCode();
      }
      if (hasStripProtectedWhitespaceFromValues()) {
        hash = (37 * hash) + STRIP_PROTECTED_WHITESPACE_FROM_VALUES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getStripProtectedWhitespaceFromValues());
      }
      if (hasColumnCache()) {
        hash = (37 * hash) + COLUMN_CACHE_FIELD_NUMBER;
        hash = (53 * hash) + getColumnCache().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos parseFrom(
            com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     * Protobuf type {@code csvspec.CsvSpecProtos}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:csvspec.CsvSpecProtos)
            org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtosOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvSpecProtos_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvSpecProtos_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos.Builder.class);
      }

      // Construct using org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
              com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getCsvspecFieldBuilder();
          getNamedvalueFieldBuilder();
          getColumnCacheFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        templatefile_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (csvspecBuilder_ == null) {
          csvspec_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          csvspecBuilder_.clear();
        }
        if (namedvalueBuilder_ == null) {
          namedvalue_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          namedvalueBuilder_.clear();
        }
        stripProtectedWhitespaceFromValues_ = false;
        bitField0_ = (bitField0_ & ~0x00000008);
        if (columnCacheBuilder_ == null) {
          columnCache_ = null;
        } else {
          columnCacheBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvSpecProtos_descriptor;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos getDefaultInstanceForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos.getDefaultInstance();
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos build() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos buildPartial() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos result = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.templatefile_ = templatefile_;
        if (csvspecBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            csvspec_ = java.util.Collections.unmodifiableList(csvspec_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.csvspec_ = csvspec_;
        } else {
          result.csvspec_ = csvspecBuilder_.build();
        }
        if (namedvalueBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            namedvalue_ = java.util.Collections.unmodifiableList(namedvalue_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.namedvalue_ = namedvalue_;
        } else {
          result.namedvalue_ = namedvalueBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.stripProtectedWhitespaceFromValues_ = stripProtectedWhitespaceFromValues_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          if (columnCacheBuilder_ == null) {
            result.columnCache_ = columnCache_;
          } else {
            result.columnCache_ = columnCacheBuilder_.build();
          }
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(
              com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(
              com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos) {
          return mergeFrom((org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos other) {
        if (other == org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos.getDefaultInstance())
          return this;
        if (other.hasTemplatefile()) {
          bitField0_ |= 0x00000001;
          templatefile_ = other.templatefile_;
          onChanged();
        }
        if (csvspecBuilder_ == null) {
          if (!other.csvspec_.isEmpty()) {
            if (csvspec_.isEmpty()) {
              csvspec_ = other.csvspec_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureCsvspecIsMutable();
              csvspec_.addAll(other.csvspec_);
            }
            onChanged();
          }
        } else {
          if (!other.csvspec_.isEmpty()) {
            if (csvspecBuilder_.isEmpty()) {
              csvspecBuilder_.dispose();
              csvspecBuilder_ = null;
              csvspec_ = other.csvspec_;
              bitField0_ = (bitField0_ & ~0x00000002);
              csvspecBuilder_ =
                      com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                              getCsvspecFieldBuilder() : null;
            } else {
              csvspecBuilder_.addAllMessages(other.csvspec_);
            }
          }
        }
        if (namedvalueBuilder_ == null) {
          if (!other.namedvalue_.isEmpty()) {
            if (namedvalue_.isEmpty()) {
              namedvalue_ = other.namedvalue_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureNamedvalueIsMutable();
              namedvalue_.addAll(other.namedvalue_);
            }
            onChanged();
          }
        } else {
          if (!other.namedvalue_.isEmpty()) {
            if (namedvalueBuilder_.isEmpty()) {
              namedvalueBuilder_.dispose();
              namedvalueBuilder_ = null;
              namedvalue_ = other.namedvalue_;
              bitField0_ = (bitField0_ & ~0x00000004);
              namedvalueBuilder_ =
                      com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                              getNamedvalueFieldBuilder() : null;
            } else {
              namedvalueBuilder_.addAllMessages(other.namedvalue_);
            }
          }
        }
        if (other.hasStripProtectedWhitespaceFromValues()) {
          setStripProtectedWhitespaceFromValues(other.getStripProtectedWhitespaceFromValues());
        }
        if (other.hasColumnCache()) {
          mergeColumnCache(other.getColumnCache());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        for (int i = 0; i < getCsvspecCount(); i++) {
          if (!getCsvspec(i).isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getNamedvalueCount(); i++) {
          if (!getNamedvalue(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object templatefile_ = "";
      /**
       * <pre>
       * A template file to base this csv spec file on (see CsvSpecProto for
       * details). Path relative to this file.
       * </pre>
       *
       * <code>optional string templatefile = 2;</code>
       */
      public boolean hasTemplatefile() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * A template file to base this csv spec file on (see CsvSpecProto for
       * details). Path relative to this file.
       * </pre>
       *
       * <code>optional string templatefile = 2;</code>
       */
      public java.lang.String getTemplatefile() {
        java.lang.Object ref = templatefile_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
                  (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            templatefile_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }

      /**
       * <pre>
       * A template file to base this csv spec file on (see CsvSpecProto for
       * details). Path relative to this file.
       * </pre>
       *
       * <code>optional string templatefile = 2;</code>
       */
      public com.google.protobuf.ByteString
      getTemplatefileBytes() {
        java.lang.Object ref = templatefile_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
                  com.google.protobuf.ByteString.copyFromUtf8(
                          (java.lang.String) ref);
          templatefile_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       * <pre>
       * A template file to base this csv spec file on (see CsvSpecProto for
       * details). Path relative to this file.
       * </pre>
       *
       * <code>optional string templatefile = 2;</code>
       */
      public Builder setTemplatefile(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        templatefile_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * A template file to base this csv spec file on (see CsvSpecProto for
       * details). Path relative to this file.
       * </pre>
       *
       * <code>optional string templatefile = 2;</code>
       */
      public Builder clearTemplatefile() {
        bitField0_ = (bitField0_ & ~0x00000001);
        templatefile_ = getDefaultInstance().getTemplatefile();
        onChanged();
        return this;
      }

      /**
       * <pre>
       * A template file to base this csv spec file on (see CsvSpecProto for
       * details). Path relative to this file.
       * </pre>
       *
       * <code>optional string templatefile = 2;</code>
       */
      public Builder setTemplatefileBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        templatefile_ = value;
        onChanged();
        return this;
      }

      private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto> csvspec_ =
              java.util.Collections.emptyList();

      private void ensureCsvspecIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          csvspec_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto>(csvspec_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtoOrBuilder> csvspecBuilder_;

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto> getCsvspecList() {
        if (csvspecBuilder_ == null) {
          return java.util.Collections.unmodifiableList(csvspec_);
        } else {
          return csvspecBuilder_.getMessageList();
        }
      }

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public int getCsvspecCount() {
        if (csvspecBuilder_ == null) {
          return csvspec_.size();
        } else {
          return csvspecBuilder_.getCount();
        }
      }

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto getCsvspec(int index) {
        if (csvspecBuilder_ == null) {
          return csvspec_.get(index);
        } else {
          return csvspecBuilder_.getMessage(index);
        }
      }

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public Builder setCsvspec(
          int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto value) {
        if (csvspecBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCsvspecIsMutable();
          csvspec_.set(index, value);
          onChanged();
        } else {
          csvspecBuilder_.setMessage(index, value);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public Builder setCsvspec(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.Builder builderForValue) {
        if (csvspecBuilder_ == null) {
          ensureCsvspecIsMutable();
          csvspec_.set(index, builderForValue.build());
          onChanged();
        } else {
          csvspecBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public Builder addCsvspec(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto value) {
        if (csvspecBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCsvspecIsMutable();
          csvspec_.add(value);
          onChanged();
        } else {
          csvspecBuilder_.addMessage(value);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public Builder addCsvspec(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto value) {
        if (csvspecBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCsvspecIsMutable();
          csvspec_.add(index, value);
          onChanged();
        } else {
          csvspecBuilder_.addMessage(index, value);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public Builder addCsvspec(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.Builder builderForValue) {
        if (csvspecBuilder_ == null) {
          ensureCsvspecIsMutable();
          csvspec_.add(builderForValue.build());
          onChanged();
        } else {
          csvspecBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public Builder addCsvspec(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.Builder builderForValue) {
        if (csvspecBuilder_ == null) {
          ensureCsvspecIsMutable();
          csvspec_.add(index, builderForValue.build());
          onChanged();
        } else {
          csvspecBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public Builder addAllCsvspec(
              java.lang.Iterable<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto> values) {
        if (csvspecBuilder_ == null) {
          ensureCsvspecIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
                  values, csvspec_);
          onChanged();
        } else {
          csvspecBuilder_.addAllMessages(values);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public Builder clearCsvspec() {
        if (csvspecBuilder_ == null) {
          csvspec_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          csvspecBuilder_.clear();
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public Builder removeCsvspec(int index) {
        if (csvspecBuilder_ == null) {
          ensureCsvspecIsMutable();
          csvspec_.remove(index);
          onChanged();
        } else {
          csvspecBuilder_.remove(index);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.Builder getCsvspecBuilder(
              int index) {
        return getCsvspecFieldBuilder().getBuilder(index);
      }

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtoOrBuilder getCsvspecOrBuilder(
              int index) {
        if (csvspecBuilder_ == null) {
          return csvspec_.get(index);
        } else {
          return csvspecBuilder_.getMessageOrBuilder(index);
        }
      }

      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtoOrBuilder>
      getCsvspecOrBuilderList() {
        if (csvspecBuilder_ != null) {
          return csvspecBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(csvspec_);
        }
      }
      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.Builder addCsvspecBuilder() {
        return getCsvspecFieldBuilder().addBuilder(
            org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.getDefaultInstance());
      }
      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.Builder addCsvspecBuilder(
          int index) {
        return getCsvspecFieldBuilder().addBuilder(
            index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.getDefaultInstance());
      }
      /**
       * <code>repeated .csvspec.CsvSpecProto csvspec = 1;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.Builder>
      getCsvspecBuilderList() {
        return getCsvspecFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtoOrBuilder>
      getCsvspecFieldBuilder() {
        if (csvspecBuilder_ == null) {
          csvspecBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtoOrBuilder>(
                  csvspec_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          csvspec_ = null;
        }
        return csvspecBuilder_;
      }

      private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> namedvalue_ =
              java.util.Collections.emptyList();

      private void ensureNamedvalueIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          namedvalue_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto>(namedvalue_);
          bitField0_ |= 0x00000004;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder> namedvalueBuilder_;

      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> getNamedvalueList() {
        if (namedvalueBuilder_ == null) {
          return java.util.Collections.unmodifiableList(namedvalue_);
        } else {
          return namedvalueBuilder_.getMessageList();
        }
      }

      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public int getNamedvalueCount() {
        if (namedvalueBuilder_ == null) {
          return namedvalue_.size();
        } else {
          return namedvalueBuilder_.getCount();
        }
      }

      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto getNamedvalue(int index) {
        if (namedvalueBuilder_ == null) {
          return namedvalue_.get(index);
        } else {
          return namedvalueBuilder_.getMessage(index);
        }
      }

      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public Builder setNamedvalue(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto value) {
        if (namedvalueBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNamedvalueIsMutable();
          namedvalue_.set(index, value);
          onChanged();
        } else {
          namedvalueBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public Builder setNamedvalue(
          int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder builderForValue) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          namedvalue_.set(index, builderForValue.build());
          onChanged();
        } else {
          namedvalueBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public Builder addNamedvalue(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto value) {
        if (namedvalueBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNamedvalueIsMutable();
          namedvalue_.add(value);
          onChanged();
        } else {
          namedvalueBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public Builder addNamedvalue(
          int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto value) {
        if (namedvalueBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNamedvalueIsMutable();
          namedvalue_.add(index, value);
          onChanged();
        } else {
          namedvalueBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public Builder addNamedvalue(
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder builderForValue) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          namedvalue_.add(builderForValue.build());
          onChanged();
        } else {
          namedvalueBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public Builder addNamedvalue(
          int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder builderForValue) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          namedvalue_.add(index, builderForValue.build());
          onChanged();
        } else {
          namedvalueBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public Builder addAllNamedvalue(
          java.lang.Iterable<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto> values) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
                  values, namedvalue_);
          onChanged();
        } else {
          namedvalueBuilder_.addAllMessages(values);
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public Builder clearNamedvalue() {
        if (namedvalueBuilder_ == null) {
          namedvalue_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          namedvalueBuilder_.clear();
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public Builder removeNamedvalue(int index) {
        if (namedvalueBuilder_ == null) {
          ensureNamedvalueIsMutable();
          namedvalue_.remove(index);
          onChanged();
        } else {
          namedvalueBuilder_.remove(index);
        }
        return this;
      }

      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder getNamedvalueBuilder(
              int index) {
        return getNamedvalueFieldBuilder().getBuilder(index);
      }

      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder getNamedvalueOrBuilder(
              int index) {
        if (namedvalueBuilder_ == null) {
          return namedvalue_.get(index);
        } else {
          return namedvalueBuilder_.getMessageOrBuilder(index);
        }
      }

      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder>
      getNamedvalueOrBuilderList() {
        if (namedvalueBuilder_ != null) {
          return namedvalueBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(namedvalue_);
        }
      }

      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder addNamedvalueBuilder() {
        return getNamedvalueFieldBuilder().addBuilder(
            org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder addNamedvalueBuilder(
              int index) {
        return getNamedvalueFieldBuilder().addBuilder(
                index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.getDefaultInstance());
      }

      /**
       * <pre>
       * Specifies names for certain values of columns of any of these csv specs.
       * </pre>
       *
       * <code>repeated .csvspec.NamedValueProto namedvalue = 3;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder>
      getNamedvalueBuilderList() {
        return getNamedvalueFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder>
      getNamedvalueFieldBuilder() {
        if (namedvalueBuilder_ == null) {
          namedvalueBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.NamedValueProtoOrBuilder>(
                  namedvalue_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          namedvalue_ = null;
        }
        return namedvalueBuilder_;
      }

      private boolean stripProtectedWhitespaceFromValues_;

      /**
       * <pre>
       * If true, protected whitespace will be stripped from CSV values when they
       * are read.  Note that the existing Google CSV parser implementation will
       * strip whitespace from values (eg. ' a, b , c' producing [a,b,c]).
       * However, whitespace for a value can be protected for a value by enclosing
       * it in double quotes (eg. '" a "," b "," c"' producing [ a , b , c]).
       * Controls default setting for all files in a CSV bundle.
       * </pre>
       *
       * <code>optional bool strip_protected_whitespace_from_values = 4 [default = false];</code>
       */
      public boolean hasStripProtectedWhitespaceFromValues() {
        return ((bitField0_ & 0x00000008) != 0);
      }

      /**
       * <pre>
       * If true, protected whitespace will be stripped from CSV values when they
       * are read.  Note that the existing Google CSV parser implementation will
       * strip whitespace from values (eg. ' a, b , c' producing [a,b,c]).
       * However, whitespace for a value can be protected for a value by enclosing
       * it in double quotes (eg. '" a "," b "," c"' producing [ a , b , c]).
       * Controls default setting for all files in a CSV bundle.
       * </pre>
       *
       * <code>optional bool strip_protected_whitespace_from_values = 4 [default = false];</code>
       */
      public boolean getStripProtectedWhitespaceFromValues() {
        return stripProtectedWhitespaceFromValues_;
      }

      /**
       * <pre>
       * If true, protected whitespace will be stripped from CSV values when they
       * are read.  Note that the existing Google CSV parser implementation will
       * strip whitespace from values (eg. ' a, b , c' producing [a,b,c]).
       * However, whitespace for a value can be protected for a value by enclosing
       * it in double quotes (eg. '" a "," b "," c"' producing [ a , b , c]).
       * Controls default setting for all files in a CSV bundle.
       * </pre>
       *
       * <code>optional bool strip_protected_whitespace_from_values = 4 [default = false];</code>
       */
      public Builder setStripProtectedWhitespaceFromValues(boolean value) {
        bitField0_ |= 0x00000008;
        stripProtectedWhitespaceFromValues_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, protected whitespace will be stripped from CSV values when they
       * are read.  Note that the existing Google CSV parser implementation will
       * strip whitespace from values (eg. ' a, b , c' producing [a,b,c]).
       * However, whitespace for a value can be protected for a value by enclosing
       * it in double quotes (eg. '" a "," b "," c"' producing [ a , b , c]).
       * Controls default setting for all files in a CSV bundle.
       * </pre>
       *
       * <code>optional bool strip_protected_whitespace_from_values = 4 [default = false];</code>
       */
      public Builder clearStripProtectedWhitespaceFromValues() {
        bitField0_ = (bitField0_ & ~0x00000008);
        stripProtectedWhitespaceFromValues_ = false;
        onChanged();
        return this;
      }

      private org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto columnCache_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder> columnCacheBuilder_;
      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in all
       * CSV files. Can be overwritten on a per-file and per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
       */
      public boolean hasColumnCache() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in all
       * CSV files. Can be overwritten on a per-file and per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto getColumnCache() {
        if (columnCacheBuilder_ == null) {
          return columnCache_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance() : columnCache_;
        } else {
          return columnCacheBuilder_.getMessage();
        }
      }

      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in all
       * CSV files. Can be overwritten on a per-file and per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
       */
      public Builder setColumnCache(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto value) {
        if (columnCacheBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          columnCache_ = value;
          onChanged();
        } else {
          columnCacheBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        return this;
      }

      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in all
       * CSV files. Can be overwritten on a per-file and per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
       */
      public Builder setColumnCache(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder builderForValue) {
        if (columnCacheBuilder_ == null) {
          columnCache_ = builderForValue.build();
          onChanged();
        } else {
          columnCacheBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        return this;
      }

      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in all
       * CSV files. Can be overwritten on a per-file and per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
       */
      public Builder mergeColumnCache(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto value) {
        if (columnCacheBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
              columnCache_ != null &&
              columnCache_ != org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance()) {
            columnCache_ =
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.newBuilder(columnCache_).mergeFrom(value).buildPartial();
          } else {
            columnCache_ = value;
          }
          onChanged();
        } else {
          columnCacheBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000010;
        return this;
      }

      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in all
       * CSV files. Can be overwritten on a per-file and per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
       */
      public Builder clearColumnCache() {
        if (columnCacheBuilder_ == null) {
          columnCache_ = null;
          onChanged();
        } else {
          columnCacheBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }
      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in all
       * CSV files. Can be overwritten on a per-file and per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder getColumnCacheBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getColumnCacheFieldBuilder().getBuilder();
      }

      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in all
       * CSV files. Can be overwritten on a per-file and per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder getColumnCacheOrBuilder() {
        if (columnCacheBuilder_ != null) {
          return columnCacheBuilder_.getMessageOrBuilder();
        } else {
          return columnCache_ == null ?
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.getDefaultInstance() : columnCache_;
        }
      }
      /**
       * <pre>
       * Define a default column-value caching strategy across all columns in all
       * CSV files. Can be overwritten on a per-file and per-column basis.
       * </pre>
       *
       * <code>optional .csvspec.ColumnCacheProto column_cache = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder> 
          getColumnCacheFieldBuilder() {
        if (columnCacheBuilder_ == null) {
          columnCacheBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnCacheProtoOrBuilder>(
                  getColumnCache(),
                  getParentForChildren(),
                  isClean());
          columnCache_ = null;
        }
        return columnCacheBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csvspec.CsvSpecProtos)
    }

    // @@protoc_insertion_point(class_scope:csvspec.CsvSpecProtos)
    private static final org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos();
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<CsvSpecProtos>
            PARSER = new com.google.protobuf.AbstractParser<CsvSpecProtos>() {
      @java.lang.Override
      public CsvSpecProtos parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return new CsvSpecProtos(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CsvSpecProtos> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CsvSpecProtos> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvSpecProtos getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CsvErrorColumnProtoOrBuilder extends
          // @@protoc_insertion_point(interface_extends:csvspec.CsvErrorColumnProto)
          com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The index of the column.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     */
    boolean hasIndex();

    /**
     * <pre>
     * The index of the column.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     */
    int getIndex();

    /**
     * <pre>
     * The type of the column.
     * </pre>
     *
     * <code>optional int32 type = 2;</code>
     */
    boolean hasType();

    /**
     * <pre>
     * The type of the column.
     * </pre>
     *
     * <code>optional int32 type = 2;</code>
     */
    int getType();

    /**
     * <pre>
     * The original name of the column. This may be empty, if the input file does
     * not have column names in its header.
     * </pre>
     *
     * <code>optional string originalname = 3;</code>
     */
    boolean hasOriginalname();
    /**
     * <pre>
     * The original name of the column. This may be empty, if the input file does
     * not have column names in its header.
     * </pre>
     *
     * <code>optional string originalname = 3;</code>
     */
    java.lang.String getOriginalname();
    /**
     * <pre>
     * The original name of the column. This may be empty, if the input file does
     * not have column names in its header.
     * </pre>
     *
     * <code>optional string originalname = 3;</code>
     */
    com.google.protobuf.ByteString
        getOriginalnameBytes();

    /**
     * <pre>
     * The original column spec for this column.
     * </pre>
     *
     * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
     */
    boolean hasColspec();
    /**
     * <pre>
     * The original column spec for this column.
     * </pre>
     *
     * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto getColspec();
    /**
     * <pre>
     * The original column spec for this column.
     * </pre>
     *
     * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder getColspecOrBuilder();
  }
  /**
   * Protobuf type {@code csvspec.CsvErrorColumnProto}
   */
  public static final class CsvErrorColumnProto extends
          com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csvspec.CsvErrorColumnProto)
      CsvErrorColumnProtoOrBuilder {
  private static final long serialVersionUID = 0L;

    // Use CsvErrorColumnProto.newBuilder() to construct.
    private CsvErrorColumnProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private CsvErrorColumnProto() {
      originalname_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
            UnusedPrivateParameter unused) {
      return new CsvErrorColumnProto();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CsvErrorColumnProto(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
              com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              index_ = input.readInt32();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              type_ = input.readInt32();
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              originalname_ = bs;
              break;
            }
            case 34: {
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) != 0)) {
                subBuilder = colspec_.toBuilder();
              }
              colspec_ = input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(colspec_);
                colspec_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
            default: {
              if (!parseUnknownField(
                      input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
                e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor
    getDescriptor() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorColumnProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
    internalGetFieldAccessorTable() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorColumnProto_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.Builder.class);
    }

    private int bitField0_;
    public static final int INDEX_FIELD_NUMBER = 1;
    private int index_;

    /**
     * <pre>
     * The index of the column.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     */
    public boolean hasIndex() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     * <pre>
     * The index of the column.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     */
    public int getIndex() {
      return index_;
    }

    public static final int TYPE_FIELD_NUMBER = 2;
    private int type_;

    /**
     * <pre>
     * The type of the column.
     * </pre>
     *
     * <code>optional int32 type = 2;</code>
     */
    public boolean hasType() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     * <pre>
     * The type of the column.
     * </pre>
     *
     * <code>optional int32 type = 2;</code>
     */
    public int getType() {
      return type_;
    }

    public static final int ORIGINALNAME_FIELD_NUMBER = 3;
    private volatile java.lang.Object originalname_;

    /**
     * <pre>
     * The original name of the column. This may be empty, if the input file does
     * not have column names in its header.
     * </pre>
     *
     * <code>optional string originalname = 3;</code>
     */
    public boolean hasOriginalname() {
      return ((bitField0_ & 0x00000004) != 0);
    }

    /**
     * <pre>
     * The original name of the column. This may be empty, if the input file does
     * not have column names in its header.
     * </pre>
     *
     * <code>optional string originalname = 3;</code>
     */
    public java.lang.String getOriginalname() {
      java.lang.Object ref = originalname_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          originalname_ = s;
        }
        return s;
      }
    }

    /**
     * <pre>
     * The original name of the column. This may be empty, if the input file does
     * not have column names in its header.
     * </pre>
     *
     * <code>optional string originalname = 3;</code>
     */
    public com.google.protobuf.ByteString
    getOriginalnameBytes() {
      java.lang.Object ref = originalname_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        originalname_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int COLSPEC_FIELD_NUMBER = 4;
    private org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto colspec_;

    /**
     * <pre>
     * The original column spec for this column.
     * </pre>
     *
     * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
     */
    public boolean hasColspec() {
      return ((bitField0_ & 0x00000008) != 0);
    }

    /**
     * <pre>
     * The original column spec for this column.
     * </pre>
     *
     * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto getColspec() {
      return colspec_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.getDefaultInstance() : colspec_;
    }

    /**
     * <pre>
     * The original column spec for this column.
     * </pre>
     *
     * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder getColspecOrBuilder() {
      return colspec_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.getDefaultInstance() : colspec_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (hasColspec()) {
        if (!getColspec().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, index_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, type_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, originalname_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(4, getColspec());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
                .computeInt32Size(1, index_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
                .computeInt32Size(2, type_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, originalname_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(4, getColspec());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto)) {
        return super.equals(obj);
      }
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto other = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto) obj;

      if (hasIndex() != other.hasIndex()) return false;
      if (hasIndex()) {
        if (getIndex()
            != other.getIndex()) return false;
      }
      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (getType()
            != other.getType()) return false;
      }
      if (hasOriginalname() != other.hasOriginalname()) return false;
      if (hasOriginalname()) {
        if (!getOriginalname()
            .equals(other.getOriginalname())) return false;
      }
      if (hasColspec() != other.hasColspec()) return false;
      if (hasColspec()) {
        if (!getColspec()
                .equals(other.getColspec())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasIndex()) {
        hash = (37 * hash) + INDEX_FIELD_NUMBER;
        hash = (53 * hash) + getIndex();
      }
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType();
      }
      if (hasOriginalname()) {
        hash = (37 * hash) + ORIGINALNAME_FIELD_NUMBER;
        hash = (53 * hash) + getOriginalname().hashCode();
      }
      if (hasColspec()) {
        hash = (37 * hash) + COLSPEC_FIELD_NUMBER;
        hash = (53 * hash) + getColspec().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto parseFrom(
            com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto parseFrom(
            java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csvspec.CsvErrorColumnProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csvspec.CsvErrorColumnProto)
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorColumnProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorColumnProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.Builder.class);
      }

      // Construct using org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
              com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getColspecFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        index_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        originalname_ = "";
        bitField0_ = (bitField0_ & ~0x00000004);
        if (colspecBuilder_ == null) {
          colspec_ = null;
        } else {
          colspecBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorColumnProto_descriptor;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto getDefaultInstanceForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto build() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto buildPartial() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto result = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.index_ = index_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          to_bitField0_ |= 0x00000004;
        }
        result.originalname_ = originalname_;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          if (colspecBuilder_ == null) {
            result.colspec_ = colspec_;
          } else {
            result.colspec_ = colspecBuilder_.build();
          }
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(
              com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(
              com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto) {
          return mergeFrom((org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto other) {
        if (other == org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.getDefaultInstance())
          return this;
        if (other.hasIndex()) {
          setIndex(other.getIndex());
        }
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasOriginalname()) {
          bitField0_ |= 0x00000004;
          originalname_ = other.originalname_;
          onChanged();
        }
        if (other.hasColspec()) {
          mergeColspec(other.getColspec());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (hasColspec()) {
          if (!getColspec().isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private int index_;

      /**
       * <pre>
       * The index of the column.
       * </pre>
       *
       * <code>optional int32 index = 1;</code>
       */
      public boolean hasIndex() {
        return ((bitField0_ & 0x00000001) != 0);
      }

      /**
       * <pre>
       * The index of the column.
       * </pre>
       *
       * <code>optional int32 index = 1;</code>
       */
      public int getIndex() {
        return index_;
      }

      /**
       * <pre>
       * The index of the column.
       * </pre>
       *
       * <code>optional int32 index = 1;</code>
       */
      public Builder setIndex(int value) {
        bitField0_ |= 0x00000001;
        index_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The index of the column.
       * </pre>
       *
       * <code>optional int32 index = 1;</code>
       */
      public Builder clearIndex() {
        bitField0_ = (bitField0_ & ~0x00000001);
        index_ = 0;
        onChanged();
        return this;
      }

      private int type_;

      /**
       * <pre>
       * The type of the column.
       * </pre>
       *
       * <code>optional int32 type = 2;</code>
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000002) != 0);
      }

      /**
       * <pre>
       * The type of the column.
       * </pre>
       *
       * <code>optional int32 type = 2;</code>
       */
      public int getType() {
        return type_;
      }
      /**
       * <pre>
       * The type of the column.
       * </pre>
       *
       * <code>optional int32 type = 2;</code>
       */
      public Builder setType(int value) {
        bitField0_ |= 0x00000002;
        type_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The type of the column.
       * </pre>
       *
       * <code>optional int32 type = 2;</code>
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000002);
        type_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object originalname_ = "";

      /**
       * <pre>
       * The original name of the column. This may be empty, if the input file does
       * not have column names in its header.
       * </pre>
       *
       * <code>optional string originalname = 3;</code>
       */
      public boolean hasOriginalname() {
        return ((bitField0_ & 0x00000004) != 0);
      }

      /**
       * <pre>
       * The original name of the column. This may be empty, if the input file does
       * not have column names in its header.
       * </pre>
       *
       * <code>optional string originalname = 3;</code>
       */
      public java.lang.String getOriginalname() {
        java.lang.Object ref = originalname_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
                  (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            originalname_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }

      /**
       * <pre>
       * The original name of the column. This may be empty, if the input file does
       * not have column names in its header.
       * </pre>
       *
       * <code>optional string originalname = 3;</code>
       */
      public com.google.protobuf.ByteString
          getOriginalnameBytes() {
        java.lang.Object ref = originalname_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          originalname_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       * <pre>
       * The original name of the column. This may be empty, if the input file does
       * not have column names in its header.
       * </pre>
       *
       * <code>optional string originalname = 3;</code>
       */
      public Builder setOriginalname(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        originalname_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The original name of the column. This may be empty, if the input file does
       * not have column names in its header.
       * </pre>
       *
       * <code>optional string originalname = 3;</code>
       */
      public Builder clearOriginalname() {
        bitField0_ = (bitField0_ & ~0x00000004);
        originalname_ = getDefaultInstance().getOriginalname();
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The original name of the column. This may be empty, if the input file does
       * not have column names in its header.
       * </pre>
       *
       * <code>optional string originalname = 3;</code>
       */
      public Builder setOriginalnameBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        originalname_ = value;
        onChanged();
        return this;
      }

      private org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto colspec_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder> colspecBuilder_;

      /**
       * <pre>
       * The original column spec for this column.
       * </pre>
       *
       * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
       */
      public boolean hasColspec() {
        return ((bitField0_ & 0x00000008) != 0);
      }

      /**
       * <pre>
       * The original column spec for this column.
       * </pre>
       *
       * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto getColspec() {
        if (colspecBuilder_ == null) {
          return colspec_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.getDefaultInstance() : colspec_;
        } else {
          return colspecBuilder_.getMessage();
        }
      }

      /**
       * <pre>
       * The original column spec for this column.
       * </pre>
       *
       * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
       */
      public Builder setColspec(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto value) {
        if (colspecBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          colspec_ = value;
          onChanged();
        } else {
          colspecBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * The original column spec for this column.
       * </pre>
       *
       * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
       */
      public Builder setColspec(
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder builderForValue) {
        if (colspecBuilder_ == null) {
          colspec_ = builderForValue.build();
          onChanged();
        } else {
          colspecBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * The original column spec for this column.
       * </pre>
       *
       * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
       */
      public Builder mergeColspec(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto value) {
        if (colspecBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
              colspec_ != null &&
              colspec_ != org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.getDefaultInstance()) {
            colspec_ =
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.newBuilder(colspec_).mergeFrom(value).buildPartial();
          } else {
            colspec_ = value;
          }
          onChanged();
        } else {
          colspecBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }

      /**
       * <pre>
       * The original column spec for this column.
       * </pre>
       *
       * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
       */
      public Builder clearColspec() {
        if (colspecBuilder_ == null) {
          colspec_ = null;
          onChanged();
        } else {
          colspecBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }
      /**
       * <pre>
       * The original column spec for this column.
       * </pre>
       *
       * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder getColspecBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getColspecFieldBuilder().getBuilder();
      }

      /**
       * <pre>
       * The original column spec for this column.
       * </pre>
       *
       * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder getColspecOrBuilder() {
        if (colspecBuilder_ != null) {
          return colspecBuilder_.getMessageOrBuilder();
        } else {
          return colspec_ == null ?
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.getDefaultInstance() : colspec_;
        }
      }

      /**
       * <pre>
       * The original column spec for this column.
       * </pre>
       *
       * <code>optional .csvspec.ColumnSpecProto colspec = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder>
      getColspecFieldBuilder() {
        if (colspecBuilder_ == null) {
          colspecBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.ColumnSpecProtoOrBuilder>(
                  getColspec(),
                  getParentForChildren(),
                  isClean());
          colspec_ = null;
        }
        return colspecBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csvspec.CsvErrorColumnProto)
    }

    // @@protoc_insertion_point(class_scope:csvspec.CsvErrorColumnProto)
    private static final org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto();
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<CsvErrorColumnProto>
            PARSER = new com.google.protobuf.AbstractParser<CsvErrorColumnProto>() {
      @java.lang.Override
      public CsvErrorColumnProto parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return new CsvErrorColumnProto(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CsvErrorColumnProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CsvErrorColumnProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CsvErrorLinesProtoOrBuilder extends
          // @@protoc_insertion_point(interface_extends:csvspec.CsvErrorLinesProto)
          com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The interval is given from startline to endline, inclusive. A one line
     * interval only needs to specify a startline. The first line of the file is
     * numbered 0.
     * </pre>
     *
     * <code>required int32 startline = 1;</code>
     */
    boolean hasStartline();

    /**
     * <pre>
     * The interval is given from startline to endline, inclusive. A one line
     * interval only needs to specify a startline. The first line of the file is
     * numbered 0.
     * </pre>
     *
     * <code>required int32 startline = 1;</code>
     */
    int getStartline();

    /**
     * <code>optional int32 endline = 2;</code>
     */
    boolean hasEndline();

    /**
     * <code>optional int32 endline = 2;</code>
     */
    int getEndline();
  }

  /**
   * Protobuf type {@code csvspec.CsvErrorLinesProto}
   */
  public static final class CsvErrorLinesProto extends
          com.google.protobuf.GeneratedMessageV3 implements
          // @@protoc_insertion_point(message_implements:csvspec.CsvErrorLinesProto)
          CsvErrorLinesProtoOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use CsvErrorLinesProto.newBuilder() to construct.
    private CsvErrorLinesProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private CsvErrorLinesProto() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
            UnusedPrivateParameter unused) {
      return new CsvErrorLinesProto();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }

    private CsvErrorLinesProto(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
              com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              startline_ = input.readInt32();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              endline_ = input.readInt32();
              break;
            }
            default: {
              if (!parseUnknownField(
                      input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
                e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorLinesProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorLinesProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.Builder.class);
    }

    private int bitField0_;
    public static final int STARTLINE_FIELD_NUMBER = 1;
    private int startline_;

    /**
     * <pre>
     * The interval is given from startline to endline, inclusive. A one line
     * interval only needs to specify a startline. The first line of the file is
     * numbered 0.
     * </pre>
     *
     * <code>required int32 startline = 1;</code>
     */
    public boolean hasStartline() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     * <pre>
     * The interval is given from startline to endline, inclusive. A one line
     * interval only needs to specify a startline. The first line of the file is
     * numbered 0.
     * </pre>
     *
     * <code>required int32 startline = 1;</code>
     */
    public int getStartline() {
      return startline_;
    }

    public static final int ENDLINE_FIELD_NUMBER = 2;
    private int endline_;

    /**
     * <code>optional int32 endline = 2;</code>
     */
    public boolean hasEndline() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     * <code>optional int32 endline = 2;</code>
     */
    public int getEndline() {
      return endline_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasStartline()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, startline_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, endline_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, startline_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, endline_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto)) {
        return super.equals(obj);
      }
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto other = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto) obj;

      if (hasStartline() != other.hasStartline()) return false;
      if (hasStartline()) {
        if (getStartline()
                != other.getStartline()) return false;
      }
      if (hasEndline() != other.hasEndline()) return false;
      if (hasEndline()) {
        if (getEndline()
                != other.getEndline()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasStartline()) {
        hash = (37 * hash) + STARTLINE_FIELD_NUMBER;
        hash = (53 * hash) + getStartline();
      }
      if (hasEndline()) {
        hash = (37 * hash) + ENDLINE_FIELD_NUMBER;
        hash = (53 * hash) + getEndline();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csvspec.CsvErrorLinesProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csvspec.CsvErrorLinesProto)
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorLinesProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorLinesProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.Builder.class);
      }

      // Construct using org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        startline_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        endline_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorLinesProto_descriptor;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto getDefaultInstanceForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto build() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto buildPartial() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto result = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.startline_ = startline_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.endline_ = endline_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(
              com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(
              com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto) {
          return mergeFrom((org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto other) {
        if (other == org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.getDefaultInstance()) return this;
        if (other.hasStartline()) {
          setStartline(other.getStartline());
        }
        if (other.hasEndline()) {
          setEndline(other.getEndline());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasStartline()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private int startline_;

      /**
       * <pre>
       * The interval is given from startline to endline, inclusive. A one line
       * interval only needs to specify a startline. The first line of the file is
       * numbered 0.
       * </pre>
       *
       * <code>required int32 startline = 1;</code>
       */
      public boolean hasStartline() {
        return ((bitField0_ & 0x00000001) != 0);
      }

      /**
       * <pre>
       * The interval is given from startline to endline, inclusive. A one line
       * interval only needs to specify a startline. The first line of the file is
       * numbered 0.
       * </pre>
       *
       * <code>required int32 startline = 1;</code>
       */
      public int getStartline() {
        return startline_;
      }
      /**
       * <pre>
       * The interval is given from startline to endline, inclusive. A one line
       * interval only needs to specify a startline. The first line of the file is
       * numbered 0.
       * </pre>
       *
       * <code>required int32 startline = 1;</code>
       */
      public Builder setStartline(int value) {
        bitField0_ |= 0x00000001;
        startline_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The interval is given from startline to endline, inclusive. A one line
       * interval only needs to specify a startline. The first line of the file is
       * numbered 0.
       * </pre>
       *
       * <code>required int32 startline = 1;</code>
       */
      public Builder clearStartline() {
        bitField0_ = (bitField0_ & ~0x00000001);
        startline_ = 0;
        onChanged();
        return this;
      }

      private int endline_;

      /**
       * <code>optional int32 endline = 2;</code>
       */
      public boolean hasEndline() {
        return ((bitField0_ & 0x00000002) != 0);
      }

      /**
       * <code>optional int32 endline = 2;</code>
       */
      public int getEndline() {
        return endline_;
      }

      /**
       * <code>optional int32 endline = 2;</code>
       */
      public Builder setEndline(int value) {
        bitField0_ |= 0x00000002;
        endline_ = value;
        onChanged();
        return this;
      }

      /**
       * <code>optional int32 endline = 2;</code>
       */
      public Builder clearEndline() {
        bitField0_ = (bitField0_ & ~0x00000002);
        endline_ = 0;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csvspec.CsvErrorLinesProto)
    }

    // @@protoc_insertion_point(class_scope:csvspec.CsvErrorLinesProto)
    private static final org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto();
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<CsvErrorLinesProto>
        PARSER = new com.google.protobuf.AbstractParser<CsvErrorLinesProto>() {
      @java.lang.Override
      public CsvErrorLinesProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CsvErrorLinesProto(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CsvErrorLinesProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CsvErrorLinesProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CsvErrorLocationProtoOrBuilder extends
          // @@protoc_insertion_point(interface_extends:csvspec.CsvErrorLocationProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The alias of the csv table where the error is located.
     * </pre>
     *
     * <code>optional string csvname = 1;</code>
     */
    boolean hasCsvname();
    /**
     * <pre>
     * The alias of the csv table where the error is located.
     * </pre>
     *
     * <code>optional string csvname = 1;</code>
     */
    java.lang.String getCsvname();
    /**
     * <pre>
     * The alias of the csv table where the error is located.
     * </pre>
     *
     * <code>optional string csvname = 1;</code>
     */
    com.google.protobuf.ByteString
        getCsvnameBytes();

    /**
     * <pre>
     * The filename of the csv table where the error is located. This is only
     * intended for display and will not include the path.
     * </pre>
     *
     * <code>optional string csvfilename = 2;</code>
     */
    boolean hasCsvfilename();

    /**
     * <pre>
     * The filename of the csv table where the error is located. This is only
     * intended for display and will not include the path.
     * </pre>
     *
     * <code>optional string csvfilename = 2;</code>
     */
    java.lang.String getCsvfilename();

    /**
     * <pre>
     * The filename of the csv table where the error is located. This is only
     * intended for display and will not include the path.
     * </pre>
     *
     * <code>optional string csvfilename = 2;</code>
     */
    com.google.protobuf.ByteString
        getCsvfilenameBytes();

    /**
     * <pre>
     * The name given in the csvspec to the key (or column, since each column also
     * has a 1-column key with the same name) where the error is located.
     * </pre>
     *
     * <code>optional string keyname = 3;</code>
     */
    boolean hasKeyname();
    /**
     * <pre>
     * The name given in the csvspec to the key (or column, since each column also
     * has a 1-column key with the same name) where the error is located.
     * </pre>
     *
     * <code>optional string keyname = 3;</code>
     */
    java.lang.String getKeyname();
    /**
     * <pre>
     * The name given in the csvspec to the key (or column, since each column also
     * has a 1-column key with the same name) where the error is located.
     * </pre>
     *
     * <code>optional string keyname = 3;</code>
     */
    com.google.protobuf.ByteString
        getKeynameBytes();

    /**
     * <pre>
     * The columns of the key.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
     */
    java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto> 
        getColumnList();
    /**
     * <pre>
     * The columns of the key.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto getColumn(int index);

    /**
     * <pre>
     * The columns of the key.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
     */
    int getColumnCount();

    /**
     * <pre>
     * The columns of the key.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
     */
    java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProtoOrBuilder>
    getColumnOrBuilderList();

    /**
     * <pre>
     * The columns of the key.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProtoOrBuilder getColumnOrBuilder(
            int index);

    /**
     * <pre>
     * A list of lines in the source csv file that all have this error. The first
     * line of the file is numbered 0.  This is an intermediate step, the final
     * protos ready for output will have an empty list here, and the line
     * information moved to linerange instead.
     * </pre>
     *
     * <code>repeated int32 linenumber = 5;</code>
     */
    java.util.List<java.lang.Integer> getLinenumberList();
    /**
     * <pre>
     * A list of lines in the source csv file that all have this error. The first
     * line of the file is numbered 0.  This is an intermediate step, the final
     * protos ready for output will have an empty list here, and the line
     * information moved to linerange instead.
     * </pre>
     *
     * <code>repeated int32 linenumber = 5;</code>
     */
    int getLinenumberCount();
    /**
     * <pre>
     * A list of lines in the source csv file that all have this error. The first
     * line of the file is numbered 0.  This is an intermediate step, the final
     * protos ready for output will have an empty list here, and the line
     * information moved to linerange instead.
     * </pre>
     *
     * <code>repeated int32 linenumber = 5;</code>
     */
    int getLinenumber(int index);

    /**
     * <pre>
     * A list of line ranges in the source csv that all have this error. The
     * ranges are maximal and sorted.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
     */
    java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto> 
        getLinerangeList();
    /**
     * <pre>
     * A list of line ranges in the source csv that all have this error. The
     * ranges are maximal and sorted.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto getLinerange(int index);
    /**
     * <pre>
     * A list of line ranges in the source csv that all have this error. The
     * ranges are maximal and sorted.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
     */
    int getLinerangeCount();
    /**
     * <pre>
     * A list of line ranges in the source csv that all have this error. The
     * ranges are maximal and sorted.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
     */
    java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProtoOrBuilder> 
        getLinerangeOrBuilderList();
    /**
     * <pre>
     * A list of line ranges in the source csv that all have this error. The
     * ranges are maximal and sorted.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProtoOrBuilder getLinerangeOrBuilder(
        int index);

    /**
     * <pre>
     * A list of rows in the source CsvParser data table that all have this
     * error.  Rows are zero-based, do not include the csv file header, and may
     * be different from linenumber, in the case of sort keys.
     * </pre>
     *
     * <code>repeated int32 row = 7;</code>
     */
    java.util.List<java.lang.Integer> getRowList();
    /**
     * <pre>
     * A list of rows in the source CsvParser data table that all have this
     * error.  Rows are zero-based, do not include the csv file header, and may
     * be different from linenumber, in the case of sort keys.
     * </pre>
     *
     * <code>repeated int32 row = 7;</code>
     */
    int getRowCount();
    /**
     * <pre>
     * A list of rows in the source CsvParser data table that all have this
     * error.  Rows are zero-based, do not include the csv file header, and may
     * be different from linenumber, in the case of sort keys.
     * </pre>
     *
     * <code>repeated int32 row = 7;</code>
     */
    int getRow(int index);
  }
  /**
   * Protobuf type {@code csvspec.CsvErrorLocationProto}
   */
  public  static final class CsvErrorLocationProto extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csvspec.CsvErrorLocationProto)
      CsvErrorLocationProtoOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use CsvErrorLocationProto.newBuilder() to construct.
    private CsvErrorLocationProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private CsvErrorLocationProto() {
      csvname_ = "";
      csvfilename_ = "";
      keyname_ = "";
      column_ = java.util.Collections.emptyList();
      linenumber_ = emptyIntList();
      linerange_ = java.util.Collections.emptyList();
      row_ = emptyIntList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
            UnusedPrivateParameter unused) {
      return new CsvErrorLocationProto();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }

    private CsvErrorLocationProto(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
              com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              csvname_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              csvfilename_ = bs;
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              keyname_ = bs;
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) != 0)) {
                column_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto>();
                mutable_bitField0_ |= 0x00000008;
              }
              column_.add(
                      input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.PARSER, extensionRegistry));
              break;
            }
            case 40: {
              if (!((mutable_bitField0_ & 0x00000010) != 0)) {
                linenumber_ = newIntList();
                mutable_bitField0_ |= 0x00000010;
              }
              linenumber_.addInt(input.readInt32());
              break;
            }
            case 42: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000010) != 0) && input.getBytesUntilLimit() > 0) {
                linenumber_ = newIntList();
                mutable_bitField0_ |= 0x00000010;
              }
              while (input.getBytesUntilLimit() > 0) {
                linenumber_.addInt(input.readInt32());
              }
              input.popLimit(limit);
              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000020) != 0)) {
                linerange_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto>();
                mutable_bitField0_ |= 0x00000020;
              }
              linerange_.add(
                  input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.PARSER, extensionRegistry));
              break;
            }
            case 56: {
              if (!((mutable_bitField0_ & 0x00000040) != 0)) {
                row_ = newIntList();
                mutable_bitField0_ |= 0x00000040;
              }
              row_.addInt(input.readInt32());
              break;
            }
            case 58: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000040) != 0) && input.getBytesUntilLimit() > 0) {
                row_ = newIntList();
                mutable_bitField0_ |= 0x00000040;
              }
              while (input.getBytesUntilLimit() > 0) {
                row_.addInt(input.readInt32());
              }
              input.popLimit(limit);
              break;
            }
            default: {
              if (!parseUnknownField(
                      input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
                e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000008) != 0)) {
          column_ = java.util.Collections.unmodifiableList(column_);
        }
        if (((mutable_bitField0_ & 0x00000010) != 0)) {
          linenumber_.makeImmutable(); // C
        }
        if (((mutable_bitField0_ & 0x00000020) != 0)) {
          linerange_ = java.util.Collections.unmodifiableList(linerange_);
        }
        if (((mutable_bitField0_ & 0x00000040) != 0)) {
          row_.makeImmutable(); // C
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor
    getDescriptor() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorLocationProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
    internalGetFieldAccessorTable() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorLocationProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.Builder.class);
    }

    private int bitField0_;
    public static final int CSVNAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object csvname_;

    /**
     * <pre>
     * The alias of the csv table where the error is located.
     * </pre>
     *
     * <code>optional string csvname = 1;</code>
     */
    public boolean hasCsvname() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     * <pre>
     * The alias of the csv table where the error is located.
     * </pre>
     *
     * <code>optional string csvname = 1;</code>
     */
    public java.lang.String getCsvname() {
      java.lang.Object ref = csvname_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          csvname_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The alias of the csv table where the error is located.
     * </pre>
     *
     * <code>optional string csvname = 1;</code>
     */
    public com.google.protobuf.ByteString
        getCsvnameBytes() {
      java.lang.Object ref = csvname_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        csvname_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CSVFILENAME_FIELD_NUMBER = 2;
    private volatile java.lang.Object csvfilename_;

    /**
     * <pre>
     * The filename of the csv table where the error is located. This is only
     * intended for display and will not include the path.
     * </pre>
     *
     * <code>optional string csvfilename = 2;</code>
     */
    public boolean hasCsvfilename() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     * <pre>
     * The filename of the csv table where the error is located. This is only
     * intended for display and will not include the path.
     * </pre>
     *
     * <code>optional string csvfilename = 2;</code>
     */
    public java.lang.String getCsvfilename() {
      java.lang.Object ref = csvfilename_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          csvfilename_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The filename of the csv table where the error is located. This is only
     * intended for display and will not include the path.
     * </pre>
     *
     * <code>optional string csvfilename = 2;</code>
     */
    public com.google.protobuf.ByteString
        getCsvfilenameBytes() {
      java.lang.Object ref = csvfilename_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        csvfilename_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KEYNAME_FIELD_NUMBER = 3;
    private volatile java.lang.Object keyname_;

    /**
     * <pre>
     * The name given in the csvspec to the key (or column, since each column also
     * has a 1-column key with the same name) where the error is located.
     * </pre>
     *
     * <code>optional string keyname = 3;</code>
     */
    public boolean hasKeyname() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The name given in the csvspec to the key (or column, since each column also
     * has a 1-column key with the same name) where the error is located.
     * </pre>
     *
     * <code>optional string keyname = 3;</code>
     */
    public java.lang.String getKeyname() {
      java.lang.Object ref = keyname_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          keyname_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The name given in the csvspec to the key (or column, since each column also
     * has a 1-column key with the same name) where the error is located.
     * </pre>
     *
     * <code>optional string keyname = 3;</code>
     */
    public com.google.protobuf.ByteString
        getKeynameBytes() {
      java.lang.Object ref = keyname_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        keyname_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int COLUMN_FIELD_NUMBER = 4;
    private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto> column_;
    /**
     * <pre>
     * The columns of the key.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
     */
    public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto> getColumnList() {
      return column_;
    }
    /**
     * <pre>
     * The columns of the key.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
     */
    public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProtoOrBuilder> 
        getColumnOrBuilderList() {
      return column_;
    }
    /**
     * <pre>
     * The columns of the key.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
     */
    public int getColumnCount() {
      return column_.size();
    }
    /**
     * <pre>
     * The columns of the key.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto getColumn(int index) {
      return column_.get(index);
    }
    /**
     * <pre>
     * The columns of the key.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProtoOrBuilder getColumnOrBuilder(
            int index) {
      return column_.get(index);
    }

    public static final int LINENUMBER_FIELD_NUMBER = 5;
    private com.google.protobuf.Internal.IntList linenumber_;

    /**
     * <pre>
     * A list of lines in the source csv file that all have this error. The first
     * line of the file is numbered 0.  This is an intermediate step, the final
     * protos ready for output will have an empty list here, and the line
     * information moved to linerange instead.
     * </pre>
     *
     * <code>repeated int32 linenumber = 5;</code>
     */
    public java.util.List<java.lang.Integer>
    getLinenumberList() {
      return linenumber_;
    }

    /**
     * <pre>
     * A list of lines in the source csv file that all have this error. The first
     * line of the file is numbered 0.  This is an intermediate step, the final
     * protos ready for output will have an empty list here, and the line
     * information moved to linerange instead.
     * </pre>
     *
     * <code>repeated int32 linenumber = 5;</code>
     */
    public int getLinenumberCount() {
      return linenumber_.size();
    }

    /**
     * <pre>
     * A list of lines in the source csv file that all have this error. The first
     * line of the file is numbered 0.  This is an intermediate step, the final
     * protos ready for output will have an empty list here, and the line
     * information moved to linerange instead.
     * </pre>
     *
     * <code>repeated int32 linenumber = 5;</code>
     */
    public int getLinenumber(int index) {
      return linenumber_.getInt(index);
    }

    public static final int LINERANGE_FIELD_NUMBER = 6;
    private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto> linerange_;

    /**
     * <pre>
     * A list of line ranges in the source csv that all have this error. The
     * ranges are maximal and sorted.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
     */
    public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto> getLinerangeList() {
      return linerange_;
    }

    /**
     * <pre>
     * A list of line ranges in the source csv that all have this error. The
     * ranges are maximal and sorted.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
     */
    public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProtoOrBuilder>
    getLinerangeOrBuilderList() {
      return linerange_;
    }

    /**
     * <pre>
     * A list of line ranges in the source csv that all have this error. The
     * ranges are maximal and sorted.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
     */
    public int getLinerangeCount() {
      return linerange_.size();
    }

    /**
     * <pre>
     * A list of line ranges in the source csv that all have this error. The
     * ranges are maximal and sorted.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto getLinerange(int index) {
      return linerange_.get(index);
    }

    /**
     * <pre>
     * A list of line ranges in the source csv that all have this error. The
     * ranges are maximal and sorted.
     * </pre>
     *
     * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProtoOrBuilder getLinerangeOrBuilder(
            int index) {
      return linerange_.get(index);
    }

    public static final int ROW_FIELD_NUMBER = 7;
    private com.google.protobuf.Internal.IntList row_;

    /**
     * <pre>
     * A list of rows in the source CsvParser data table that all have this
     * error.  Rows are zero-based, do not include the csv file header, and may
     * be different from linenumber, in the case of sort keys.
     * </pre>
     *
     * <code>repeated int32 row = 7;</code>
     */
    public java.util.List<java.lang.Integer>
    getRowList() {
      return row_;
    }

    /**
     * <pre>
     * A list of rows in the source CsvParser data table that all have this
     * error.  Rows are zero-based, do not include the csv file header, and may
     * be different from linenumber, in the case of sort keys.
     * </pre>
     *
     * <code>repeated int32 row = 7;</code>
     */
    public int getRowCount() {
      return row_.size();
    }

    /**
     * <pre>
     * A list of rows in the source CsvParser data table that all have this
     * error.  Rows are zero-based, do not include the csv file header, and may
     * be different from linenumber, in the case of sort keys.
     * </pre>
     *
     * <code>repeated int32 row = 7;</code>
     */
    public int getRow(int index) {
      return row_.getInt(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getColumnCount(); i++) {
        if (!getColumn(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getLinerangeCount(); i++) {
        if (!getLinerange(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, csvname_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, csvfilename_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, keyname_);
      }
      for (int i = 0; i < column_.size(); i++) {
        output.writeMessage(4, column_.get(i));
      }
      for (int i = 0; i < linenumber_.size(); i++) {
        output.writeInt32(5, linenumber_.getInt(i));
      }
      for (int i = 0; i < linerange_.size(); i++) {
        output.writeMessage(6, linerange_.get(i));
      }
      for (int i = 0; i < row_.size(); i++) {
        output.writeInt32(7, row_.getInt(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, csvname_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, csvfilename_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, keyname_);
      }
      for (int i = 0; i < column_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(4, column_.get(i));
      }
      {
        int dataSize = 0;
        for (int i = 0; i < linenumber_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
                  .computeInt32SizeNoTag(linenumber_.getInt(i));
        }
        size += dataSize;
        size += 1 * getLinenumberList().size();
      }
      for (int i = 0; i < linerange_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(6, linerange_.get(i));
      }
      {
        int dataSize = 0;
        for (int i = 0; i < row_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
                  .computeInt32SizeNoTag(row_.getInt(i));
        }
        size += dataSize;
        size += 1 * getRowList().size();
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto)) {
        return super.equals(obj);
      }
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto other = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto) obj;

      if (hasCsvname() != other.hasCsvname()) return false;
      if (hasCsvname()) {
        if (!getCsvname()
            .equals(other.getCsvname())) return false;
      }
      if (hasCsvfilename() != other.hasCsvfilename()) return false;
      if (hasCsvfilename()) {
        if (!getCsvfilename()
            .equals(other.getCsvfilename())) return false;
      }
      if (hasKeyname() != other.hasKeyname()) return false;
      if (hasKeyname()) {
        if (!getKeyname()
            .equals(other.getKeyname())) return false;
      }
      if (!getColumnList()
          .equals(other.getColumnList())) return false;
      if (!getLinenumberList()
          .equals(other.getLinenumberList())) return false;
      if (!getLinerangeList()
          .equals(other.getLinerangeList())) return false;
      if (!getRowList()
          .equals(other.getRowList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCsvname()) {
        hash = (37 * hash) + CSVNAME_FIELD_NUMBER;
        hash = (53 * hash) + getCsvname().hashCode();
      }
      if (hasCsvfilename()) {
        hash = (37 * hash) + CSVFILENAME_FIELD_NUMBER;
        hash = (53 * hash) + getCsvfilename().hashCode();
      }
      if (hasKeyname()) {
        hash = (37 * hash) + KEYNAME_FIELD_NUMBER;
        hash = (53 * hash) + getKeyname().hashCode();
      }
      if (getColumnCount() > 0) {
        hash = (37 * hash) + COLUMN_FIELD_NUMBER;
        hash = (53 * hash) + getColumnList().hashCode();
      }
      if (getLinenumberCount() > 0) {
        hash = (37 * hash) + LINENUMBER_FIELD_NUMBER;
        hash = (53 * hash) + getLinenumberList().hashCode();
      }
      if (getLinerangeCount() > 0) {
        hash = (37 * hash) + LINERANGE_FIELD_NUMBER;
        hash = (53 * hash) + getLinerangeList().hashCode();
      }
      if (getRowCount() > 0) {
        hash = (37 * hash) + ROW_FIELD_NUMBER;
        hash = (53 * hash) + getRowList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     * Protobuf type {@code csvspec.CsvErrorLocationProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csvspec.CsvErrorLocationProto)
            org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorLocationProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorLocationProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.Builder.class);
      }

      // Construct using org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getColumnFieldBuilder();
          getLinerangeFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        csvname_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        csvfilename_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        keyname_ = "";
        bitField0_ = (bitField0_ & ~0x00000004);
        if (columnBuilder_ == null) {
          column_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
        } else {
          columnBuilder_.clear();
        }
        linenumber_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000010);
        if (linerangeBuilder_ == null) {
          linerange_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
        } else {
          linerangeBuilder_.clear();
        }
        row_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorLocationProto_descriptor;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto getDefaultInstanceForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto build() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto buildPartial() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto result = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.csvname_ = csvname_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          to_bitField0_ |= 0x00000002;
        }
        result.csvfilename_ = csvfilename_;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          to_bitField0_ |= 0x00000004;
        }
        result.keyname_ = keyname_;
        if (columnBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            column_ = java.util.Collections.unmodifiableList(column_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.column_ = column_;
        } else {
          result.column_ = columnBuilder_.build();
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          linenumber_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000010);
        }
        result.linenumber_ = linenumber_;
        if (linerangeBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            linerange_ = java.util.Collections.unmodifiableList(linerange_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.linerange_ = linerange_;
        } else {
          result.linerange_ = linerangeBuilder_.build();
        }
        if (((bitField0_ & 0x00000040) != 0)) {
          row_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000040);
        }
        result.row_ = row_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
              com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto) {
          return mergeFrom((org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto other) {
        if (other == org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.getDefaultInstance()) return this;
        if (other.hasCsvname()) {
          bitField0_ |= 0x00000001;
          csvname_ = other.csvname_;
          onChanged();
        }
        if (other.hasCsvfilename()) {
          bitField0_ |= 0x00000002;
          csvfilename_ = other.csvfilename_;
          onChanged();
        }
        if (other.hasKeyname()) {
          bitField0_ |= 0x00000004;
          keyname_ = other.keyname_;
          onChanged();
        }
        if (columnBuilder_ == null) {
          if (!other.column_.isEmpty()) {
            if (column_.isEmpty()) {
              column_ = other.column_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureColumnIsMutable();
              column_.addAll(other.column_);
            }
            onChanged();
          }
        } else {
          if (!other.column_.isEmpty()) {
            if (columnBuilder_.isEmpty()) {
              columnBuilder_.dispose();
              columnBuilder_ = null;
              column_ = other.column_;
              bitField0_ = (bitField0_ & ~0x00000008);
              columnBuilder_ =
                      com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                              getColumnFieldBuilder() : null;
            } else {
              columnBuilder_.addAllMessages(other.column_);
            }
          }
        }
        if (!other.linenumber_.isEmpty()) {
          if (linenumber_.isEmpty()) {
            linenumber_ = other.linenumber_;
            bitField0_ = (bitField0_ & ~0x00000010);
          } else {
            ensureLinenumberIsMutable();
            linenumber_.addAll(other.linenumber_);
          }
          onChanged();
        }
        if (linerangeBuilder_ == null) {
          if (!other.linerange_.isEmpty()) {
            if (linerange_.isEmpty()) {
              linerange_ = other.linerange_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureLinerangeIsMutable();
              linerange_.addAll(other.linerange_);
            }
            onChanged();
          }
        } else {
          if (!other.linerange_.isEmpty()) {
            if (linerangeBuilder_.isEmpty()) {
              linerangeBuilder_.dispose();
              linerangeBuilder_ = null;
              linerange_ = other.linerange_;
              bitField0_ = (bitField0_ & ~0x00000020);
              linerangeBuilder_ =
                      com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                              getLinerangeFieldBuilder() : null;
            } else {
              linerangeBuilder_.addAllMessages(other.linerange_);
            }
          }
        }
        if (!other.row_.isEmpty()) {
          if (row_.isEmpty()) {
            row_ = other.row_;
            bitField0_ = (bitField0_ & ~0x00000040);
          } else {
            ensureRowIsMutable();
            row_.addAll(other.row_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        for (int i = 0; i < getColumnCount(); i++) {
          if (!getColumn(i).isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getLinerangeCount(); i++) {
          if (!getLinerange(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object csvname_ = "";

      /**
       * <pre>
       * The alias of the csv table where the error is located.
       * </pre>
       *
       * <code>optional string csvname = 1;</code>
       */
      public boolean hasCsvname() {
        return ((bitField0_ & 0x00000001) != 0);
      }

      /**
       * <pre>
       * The alias of the csv table where the error is located.
       * </pre>
       *
       * <code>optional string csvname = 1;</code>
       */
      public java.lang.String getCsvname() {
        java.lang.Object ref = csvname_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
                  (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            csvname_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }

      /**
       * <pre>
       * The alias of the csv table where the error is located.
       * </pre>
       *
       * <code>optional string csvname = 1;</code>
       */
      public com.google.protobuf.ByteString
      getCsvnameBytes() {
        java.lang.Object ref = csvname_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
                  com.google.protobuf.ByteString.copyFromUtf8(
                          (java.lang.String) ref);
          csvname_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       * <pre>
       * The alias of the csv table where the error is located.
       * </pre>
       *
       * <code>optional string csvname = 1;</code>
       */
      public Builder setCsvname(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        csvname_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The alias of the csv table where the error is located.
       * </pre>
       *
       * <code>optional string csvname = 1;</code>
       */
      public Builder clearCsvname() {
        bitField0_ = (bitField0_ & ~0x00000001);
        csvname_ = getDefaultInstance().getCsvname();
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The alias of the csv table where the error is located.
       * </pre>
       *
       * <code>optional string csvname = 1;</code>
       */
      public Builder setCsvnameBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        csvname_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object csvfilename_ = "";

      /**
       * <pre>
       * The filename of the csv table where the error is located. This is only
       * intended for display and will not include the path.
       * </pre>
       *
       * <code>optional string csvfilename = 2;</code>
       */
      public boolean hasCsvfilename() {
        return ((bitField0_ & 0x00000002) != 0);
      }

      /**
       * <pre>
       * The filename of the csv table where the error is located. This is only
       * intended for display and will not include the path.
       * </pre>
       *
       * <code>optional string csvfilename = 2;</code>
       */
      public java.lang.String getCsvfilename() {
        java.lang.Object ref = csvfilename_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
                  (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            csvfilename_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }

      /**
       * <pre>
       * The filename of the csv table where the error is located. This is only
       * intended for display and will not include the path.
       * </pre>
       *
       * <code>optional string csvfilename = 2;</code>
       */
      public com.google.protobuf.ByteString
      getCsvfilenameBytes() {
        java.lang.Object ref = csvfilename_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
                  com.google.protobuf.ByteString.copyFromUtf8(
                          (java.lang.String) ref);
          csvfilename_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The filename of the csv table where the error is located. This is only
       * intended for display and will not include the path.
       * </pre>
       *
       * <code>optional string csvfilename = 2;</code>
       */
      public Builder setCsvfilename(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        csvfilename_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The filename of the csv table where the error is located. This is only
       * intended for display and will not include the path.
       * </pre>
       *
       * <code>optional string csvfilename = 2;</code>
       */
      public Builder clearCsvfilename() {
        bitField0_ = (bitField0_ & ~0x00000002);
        csvfilename_ = getDefaultInstance().getCsvfilename();
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The filename of the csv table where the error is located. This is only
       * intended for display and will not include the path.
       * </pre>
       *
       * <code>optional string csvfilename = 2;</code>
       */
      public Builder setCsvfilenameBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        csvfilename_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object keyname_ = "";

      /**
       * <pre>
       * The name given in the csvspec to the key (or column, since each column also
       * has a 1-column key with the same name) where the error is located.
       * </pre>
       *
       * <code>optional string keyname = 3;</code>
       */
      public boolean hasKeyname() {
        return ((bitField0_ & 0x00000004) != 0);
      }

      /**
       * <pre>
       * The name given in the csvspec to the key (or column, since each column also
       * has a 1-column key with the same name) where the error is located.
       * </pre>
       *
       * <code>optional string keyname = 3;</code>
       */
      public java.lang.String getKeyname() {
        java.lang.Object ref = keyname_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
                  (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            keyname_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }

      /**
       * <pre>
       * The name given in the csvspec to the key (or column, since each column also
       * has a 1-column key with the same name) where the error is located.
       * </pre>
       *
       * <code>optional string keyname = 3;</code>
       */
      public com.google.protobuf.ByteString
      getKeynameBytes() {
        java.lang.Object ref = keyname_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
                  com.google.protobuf.ByteString.copyFromUtf8(
                          (java.lang.String) ref);
          keyname_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       * <pre>
       * The name given in the csvspec to the key (or column, since each column also
       * has a 1-column key with the same name) where the error is located.
       * </pre>
       *
       * <code>optional string keyname = 3;</code>
       */
      public Builder setKeyname(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        keyname_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The name given in the csvspec to the key (or column, since each column also
       * has a 1-column key with the same name) where the error is located.
       * </pre>
       *
       * <code>optional string keyname = 3;</code>
       */
      public Builder clearKeyname() {
        bitField0_ = (bitField0_ & ~0x00000004);
        keyname_ = getDefaultInstance().getKeyname();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name given in the csvspec to the key (or column, since each column also
       * has a 1-column key with the same name) where the error is located.
       * </pre>
       *
       * <code>optional string keyname = 3;</code>
       */
      public Builder setKeynameBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        keyname_ = value;
        onChanged();
        return this;
      }

      private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto> column_ =
              java.util.Collections.emptyList();

      private void ensureColumnIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          column_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto>(column_);
          bitField0_ |= 0x00000008;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProtoOrBuilder> columnBuilder_;

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto> getColumnList() {
        if (columnBuilder_ == null) {
          return java.util.Collections.unmodifiableList(column_);
        } else {
          return columnBuilder_.getMessageList();
        }
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public int getColumnCount() {
        if (columnBuilder_ == null) {
          return column_.size();
        } else {
          return columnBuilder_.getCount();
        }
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto getColumn(int index) {
        if (columnBuilder_ == null) {
          return column_.get(index);
        } else {
          return columnBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public Builder setColumn(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto value) {
        if (columnBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureColumnIsMutable();
          column_.set(index, value);
          onChanged();
        } else {
          columnBuilder_.setMessage(index, value);
        }
        return this;
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public Builder setColumn(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.Builder builderForValue) {
        if (columnBuilder_ == null) {
          ensureColumnIsMutable();
          column_.set(index, builderForValue.build());
          onChanged();
        } else {
          columnBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public Builder addColumn(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto value) {
        if (columnBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureColumnIsMutable();
          column_.add(value);
          onChanged();
        } else {
          columnBuilder_.addMessage(value);
        }
        return this;
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public Builder addColumn(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto value) {
        if (columnBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureColumnIsMutable();
          column_.add(index, value);
          onChanged();
        } else {
          columnBuilder_.addMessage(index, value);
        }
        return this;
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public Builder addColumn(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.Builder builderForValue) {
        if (columnBuilder_ == null) {
          ensureColumnIsMutable();
          column_.add(builderForValue.build());
          onChanged();
        } else {
          columnBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public Builder addColumn(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.Builder builderForValue) {
        if (columnBuilder_ == null) {
          ensureColumnIsMutable();
          column_.add(index, builderForValue.build());
          onChanged();
        } else {
          columnBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public Builder addAllColumn(
              java.lang.Iterable<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto> values) {
        if (columnBuilder_ == null) {
          ensureColumnIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
                  values, column_);
          onChanged();
        } else {
          columnBuilder_.addAllMessages(values);
        }
        return this;
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public Builder clearColumn() {
        if (columnBuilder_ == null) {
          column_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          columnBuilder_.clear();
        }
        return this;
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public Builder removeColumn(int index) {
        if (columnBuilder_ == null) {
          ensureColumnIsMutable();
          column_.remove(index);
          onChanged();
        } else {
          columnBuilder_.remove(index);
        }
        return this;
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.Builder getColumnBuilder(
              int index) {
        return getColumnFieldBuilder().getBuilder(index);
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProtoOrBuilder getColumnOrBuilder(
              int index) {
        if (columnBuilder_ == null) {
          return column_.get(index);
        } else {
          return columnBuilder_.getMessageOrBuilder(index);
        }
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProtoOrBuilder>
      getColumnOrBuilderList() {
        if (columnBuilder_ != null) {
          return columnBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(column_);
        }
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.Builder addColumnBuilder() {
        return getColumnFieldBuilder().addBuilder(
                org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.getDefaultInstance());
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.Builder addColumnBuilder(
              int index) {
        return getColumnFieldBuilder().addBuilder(
                index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.getDefaultInstance());
      }

      /**
       * <pre>
       * The columns of the key.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorColumnProto column = 4;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.Builder>
      getColumnBuilderList() {
        return getColumnFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProtoOrBuilder>
      getColumnFieldBuilder() {
        if (columnBuilder_ == null) {
          columnBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorColumnProtoOrBuilder>(
                  column_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          column_ = null;
        }
        return columnBuilder_;
      }

      private com.google.protobuf.Internal.IntList linenumber_ = emptyIntList();
      private void ensureLinenumberIsMutable() {
        if (!((bitField0_ & 0x00000010) != 0)) {
          linenumber_ = mutableCopy(linenumber_);
          bitField0_ |= 0x00000010;
         }
      }
      /**
       * <pre>
       * A list of lines in the source csv file that all have this error. The first
       * line of the file is numbered 0.  This is an intermediate step, the final
       * protos ready for output will have an empty list here, and the line
       * information moved to linerange instead.
       * </pre>
       *
       * <code>repeated int32 linenumber = 5;</code>
       */
      public java.util.List<java.lang.Integer>
      getLinenumberList() {
        return ((bitField0_ & 0x00000010) != 0) ?
                java.util.Collections.unmodifiableList(linenumber_) : linenumber_;
      }

      /**
       * <pre>
       * A list of lines in the source csv file that all have this error. The first
       * line of the file is numbered 0.  This is an intermediate step, the final
       * protos ready for output will have an empty list here, and the line
       * information moved to linerange instead.
       * </pre>
       *
       * <code>repeated int32 linenumber = 5;</code>
       */
      public int getLinenumberCount() {
        return linenumber_.size();
      }

      /**
       * <pre>
       * A list of lines in the source csv file that all have this error. The first
       * line of the file is numbered 0.  This is an intermediate step, the final
       * protos ready for output will have an empty list here, and the line
       * information moved to linerange instead.
       * </pre>
       *
       * <code>repeated int32 linenumber = 5;</code>
       */
      public int getLinenumber(int index) {
        return linenumber_.getInt(index);
      }

      /**
       * <pre>
       * A list of lines in the source csv file that all have this error. The first
       * line of the file is numbered 0.  This is an intermediate step, the final
       * protos ready for output will have an empty list here, and the line
       * information moved to linerange instead.
       * </pre>
       *
       * <code>repeated int32 linenumber = 5;</code>
       */
      public Builder setLinenumber(
              int index, int value) {
        ensureLinenumberIsMutable();
        linenumber_.setInt(index, value);
        onChanged();
        return this;
      }

      /**
       * <pre>
       * A list of lines in the source csv file that all have this error. The first
       * line of the file is numbered 0.  This is an intermediate step, the final
       * protos ready for output will have an empty list here, and the line
       * information moved to linerange instead.
       * </pre>
       *
       * <code>repeated int32 linenumber = 5;</code>
       */
      public Builder addLinenumber(int value) {
        ensureLinenumberIsMutable();
        linenumber_.addInt(value);
        onChanged();
        return this;
      }

      /**
       * <pre>
       * A list of lines in the source csv file that all have this error. The first
       * line of the file is numbered 0.  This is an intermediate step, the final
       * protos ready for output will have an empty list here, and the line
       * information moved to linerange instead.
       * </pre>
       *
       * <code>repeated int32 linenumber = 5;</code>
       */
      public Builder addAllLinenumber(
              java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureLinenumberIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
                values, linenumber_);
        onChanged();
        return this;
      }

      /**
       * <pre>
       * A list of lines in the source csv file that all have this error. The first
       * line of the file is numbered 0.  This is an intermediate step, the final
       * protos ready for output will have an empty list here, and the line
       * information moved to linerange instead.
       * </pre>
       *
       * <code>repeated int32 linenumber = 5;</code>
       */
      public Builder clearLinenumber() {
        linenumber_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }

      private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto> linerange_ =
              java.util.Collections.emptyList();

      private void ensureLinerangeIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          linerange_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto>(linerange_);
          bitField0_ |= 0x00000020;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProtoOrBuilder> linerangeBuilder_;

      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto> getLinerangeList() {
        if (linerangeBuilder_ == null) {
          return java.util.Collections.unmodifiableList(linerange_);
        } else {
          return linerangeBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public int getLinerangeCount() {
        if (linerangeBuilder_ == null) {
          return linerange_.size();
        } else {
          return linerangeBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto getLinerange(int index) {
        if (linerangeBuilder_ == null) {
          return linerange_.get(index);
        } else {
          return linerangeBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public Builder setLinerange(
          int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto value) {
        if (linerangeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLinerangeIsMutable();
          linerange_.set(index, value);
          onChanged();
        } else {
          linerangeBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public Builder setLinerange(
          int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.Builder builderForValue) {
        if (linerangeBuilder_ == null) {
          ensureLinerangeIsMutable();
          linerange_.set(index, builderForValue.build());
          onChanged();
        } else {
          linerangeBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public Builder addLinerange(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto value) {
        if (linerangeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLinerangeIsMutable();
          linerange_.add(value);
          onChanged();
        } else {
          linerangeBuilder_.addMessage(value);
        }
        return this;
      }

      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public Builder addLinerange(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto value) {
        if (linerangeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLinerangeIsMutable();
          linerange_.add(index, value);
          onChanged();
        } else {
          linerangeBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public Builder addLinerange(
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.Builder builderForValue) {
        if (linerangeBuilder_ == null) {
          ensureLinerangeIsMutable();
          linerange_.add(builderForValue.build());
          onChanged();
        } else {
          linerangeBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public Builder addLinerange(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.Builder builderForValue) {
        if (linerangeBuilder_ == null) {
          ensureLinerangeIsMutable();
          linerange_.add(index, builderForValue.build());
          onChanged();
        } else {
          linerangeBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public Builder addAllLinerange(
              java.lang.Iterable<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto> values) {
        if (linerangeBuilder_ == null) {
          ensureLinerangeIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
                  values, linerange_);
          onChanged();
        } else {
          linerangeBuilder_.addAllMessages(values);
        }
        return this;
      }

      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public Builder clearLinerange() {
        if (linerangeBuilder_ == null) {
          linerange_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          linerangeBuilder_.clear();
        }
        return this;
      }

      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public Builder removeLinerange(int index) {
        if (linerangeBuilder_ == null) {
          ensureLinerangeIsMutable();
          linerange_.remove(index);
          onChanged();
        } else {
          linerangeBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.Builder getLinerangeBuilder(
          int index) {
        return getLinerangeFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProtoOrBuilder getLinerangeOrBuilder(
          int index) {
        if (linerangeBuilder_ == null) {
          return linerange_.get(index);  } else {
          return linerangeBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProtoOrBuilder> 
           getLinerangeOrBuilderList() {
        if (linerangeBuilder_ != null) {
          return linerangeBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(linerange_);
        }
      }

      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.Builder addLinerangeBuilder() {
        return getLinerangeFieldBuilder().addBuilder(
                org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.Builder addLinerangeBuilder(
          int index) {
        return getLinerangeFieldBuilder().addBuilder(
            index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.getDefaultInstance());
      }

      /**
       * <pre>
       * A list of line ranges in the source csv that all have this error. The
       * ranges are maximal and sorted.
       * </pre>
       *
       * <code>repeated .csvspec.CsvErrorLinesProto linerange = 6;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.Builder> 
           getLinerangeBuilderList() {
        return getLinerangeFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProtoOrBuilder> 
          getLinerangeFieldBuilder() {
        if (linerangeBuilder_ == null) {
          linerangeBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLinesProtoOrBuilder>(
                  linerange_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          linerange_ = null;
        }
        return linerangeBuilder_;
      }

      private com.google.protobuf.Internal.IntList row_ = emptyIntList();

      private void ensureRowIsMutable() {
        if (!((bitField0_ & 0x00000040) != 0)) {
          row_ = mutableCopy(row_);
          bitField0_ |= 0x00000040;
        }
      }

      /**
       * <pre>
       * A list of rows in the source CsvParser data table that all have this
       * error.  Rows are zero-based, do not include the csv file header, and may
       * be different from linenumber, in the case of sort keys.
       * </pre>
       *
       * <code>repeated int32 row = 7;</code>
       */
      public java.util.List<java.lang.Integer>
      getRowList() {
        return ((bitField0_ & 0x00000040) != 0) ?
                java.util.Collections.unmodifiableList(row_) : row_;
      }

      /**
       * <pre>
       * A list of rows in the source CsvParser data table that all have this
       * error.  Rows are zero-based, do not include the csv file header, and may
       * be different from linenumber, in the case of sort keys.
       * </pre>
       *
       * <code>repeated int32 row = 7;</code>
       */
      public int getRowCount() {
        return row_.size();
      }
      /**
       * <pre>
       * A list of rows in the source CsvParser data table that all have this
       * error.  Rows are zero-based, do not include the csv file header, and may
       * be different from linenumber, in the case of sort keys.
       * </pre>
       *
       * <code>repeated int32 row = 7;</code>
       */
      public int getRow(int index) {
        return row_.getInt(index);
      }
      /**
       * <pre>
       * A list of rows in the source CsvParser data table that all have this
       * error.  Rows are zero-based, do not include the csv file header, and may
       * be different from linenumber, in the case of sort keys.
       * </pre>
       *
       * <code>repeated int32 row = 7;</code>
       */
      public Builder setRow(
          int index, int value) {
        ensureRowIsMutable();
        row_.setInt(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of rows in the source CsvParser data table that all have this
       * error.  Rows are zero-based, do not include the csv file header, and may
       * be different from linenumber, in the case of sort keys.
       * </pre>
       *
       * <code>repeated int32 row = 7;</code>
       */
      public Builder addRow(int value) {
        ensureRowIsMutable();
        row_.addInt(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of rows in the source CsvParser data table that all have this
       * error.  Rows are zero-based, do not include the csv file header, and may
       * be different from linenumber, in the case of sort keys.
       * </pre>
       *
       * <code>repeated int32 row = 7;</code>
       */
      public Builder addAllRow(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureRowIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, row_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of rows in the source CsvParser data table that all have this
       * error.  Rows are zero-based, do not include the csv file header, and may
       * be different from linenumber, in the case of sort keys.
       * </pre>
       *
       * <code>repeated int32 row = 7;</code>
       */
      public Builder clearRow() {
        row_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csvspec.CsvErrorLocationProto)
    }

    // @@protoc_insertion_point(class_scope:csvspec.CsvErrorLocationProto)
    private static final org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto();
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<CsvErrorLocationProto>
        PARSER = new com.google.protobuf.AbstractParser<CsvErrorLocationProto>() {
      @java.lang.Override
      public CsvErrorLocationProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CsvErrorLocationProto(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CsvErrorLocationProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CsvErrorLocationProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CsvErrorProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csvspec.CsvErrorProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The type of the error.
     * </pre>
     *
     * <code>required .csvspec.CsvErrorProto.ErrorType errortype = 1;</code>
     */
    boolean hasErrortype();
    /**
     * <pre>
     * The type of the error.
     * </pre>
     *
     * <code>required .csvspec.CsvErrorProto.ErrorType errortype = 1;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.ErrorType getErrortype();

    /**
     * <pre>
     * The location of the error, or locations rather, since multiple linenumbers
     * may be specified in a CsvErrorLocationProto.
     * </pre>
     *
     * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
     */
    boolean hasLocation();
    /**
     * <pre>
     * The location of the error, or locations rather, since multiple linenumbers
     * may be specified in a CsvErrorLocationProto.
     * </pre>
     *
     * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto getLocation();
    /**
     * <pre>
     * The location of the error, or locations rather, since multiple linenumbers
     * may be specified in a CsvErrorLocationProto.
     * </pre>
     *
     * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProtoOrBuilder getLocationOrBuilder();

    /**
     * <pre>
     * If this is a cross-reference error, the referred location may be specified
     * here.
     * </pre>
     *
     * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
     */
    boolean hasOtherlocation();
    /**
     * <pre>
     * If this is a cross-reference error, the referred location may be specified
     * here.
     * </pre>
     *
     * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto getOtherlocation();
    /**
     * <pre>
     * If this is a cross-reference error, the referred location may be specified
     * here.
     * </pre>
     *
     * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProtoOrBuilder getOtherlocationOrBuilder();
  }
  /**
   * Protobuf type {@code csvspec.CsvErrorProto}
   */
  public  static final class CsvErrorProto extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csvspec.CsvErrorProto)
      CsvErrorProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CsvErrorProto.newBuilder() to construct.
    private CsvErrorProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CsvErrorProto() {
      errortype_ = 10;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new CsvErrorProto();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CsvErrorProto(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              int rawValue = input.readEnum();
                @SuppressWarnings("deprecation")
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.ErrorType value = org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.ErrorType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(1, rawValue);
              } else {
                bitField0_ |= 0x00000001;
                errortype_ = rawValue;
              }
              break;
            }
            case 18: {
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) != 0)) {
                subBuilder = location_.toBuilder();
              }
              location_ = input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(location_);
                location_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) != 0)) {
                subBuilder = otherlocation_.toBuilder();
              }
              otherlocation_ = input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(otherlocation_);
                otherlocation_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            default: {
              if (!parseUnknownField(
                      input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
                e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor
    getDescriptor() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
    internalGetFieldAccessorTable() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorProto_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.Builder.class);
    }

    /**
     * Protobuf enum {@code csvspec.CsvErrorProto.ErrorType}
     */
    public enum ErrorType
            implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * The table file is missing.
       * </pre>
       *
       * <code>MISSING_TABLE = 10;</code>
       */
      MISSING_TABLE(10),
      /**
       * <pre>
       * The input file is not a well-formed csv.
       * </pre>
       *
       * <code>SPLITTING_ERROR = 20;</code>
       */
      SPLITTING_ERROR(20),
      /**
       * <pre>
       * The input file contained a null character ('&#92;0').
       * </pre>
       *
       * <code>CONTAINS_NULL_CHARACTER = 21;</code>
       */
      CONTAINS_NULL_CHARACTER(21),
      /**
       * <pre>
       * Deprecated.
       * </pre>
       *
       * <code>UTF8_CONVERSION_ERROR = 22 [deprecated = true];</code>
       */
      @java.lang.Deprecated
      UTF8_CONVERSION_ERROR(22),
      /**
       * <pre>
       * The specified lines have characters that are not valid UTF-8 (either
       * structure or interchange).
       * </pre>
       *
       * <code>INVALID_UTF8 = 23;</code>
       */
      INVALID_UTF8(23),
      /**
       * <pre>
       * The input file CSV header has the same column name repeated.
       * </pre>
       *
       * <code>DUPLICATE_COLUMN_NAME = 24;</code>
       */
      DUPLICATE_COLUMN_NAME(24),
      /**
       * <pre>
       * A row in the input file has a different number of values than specified
       * by the CSV header.
       * </pre>
       *
       * <code>BAD_NUMBER_OF_VALUES = 25;</code>
       */
      BAD_NUMBER_OF_VALUES(25),
      /**
       * <pre>
       * The input file is corrupted and cannot be read properly.
       * </pre>
       *
       * <code>FILE_CORRUPTED = 26;</code>
       */
      FILE_CORRUPTED(26),
      /**
       * <pre>
       * A file was in an unexpected location
       * </pre>
       *
       * <code>UNEXPECTED_LOCATION = 27;</code>
       */
      UNEXPECTED_LOCATION(27),
      /**
       * <pre>
       * The column is missing in the input file, either the name cannot be found
       * in the header line, or the number is out of bound.
       * </pre>
       *
       * <code>MISSING_COLUMN = 30;</code>
       */
      MISSING_COLUMN(30),
      /**
       * <pre>
       * The key was not properly added to its table, probably because one or more
       * of its columns are missing.
       * </pre>
       *
       * <code>MISSING_KEY = 31;</code>
       */
      MISSING_KEY(31),
      /**
       * <pre>
       * The input rows are not properly sorted on the given key.
       * </pre>
       *
       * <code>UNSORTED = 40;</code>
       */
      UNSORTED(40),
      /**
       * <pre>
       * The values in the given column of the input rows are not 1..n when
       * grouped on some key.
       * </pre>
       *
       * <code>NON_CONTIGUOUS = 41;</code>
       */
      NON_CONTIGUOUS(41),
      /**
       * <pre>
       * The number of data rows of the table is not as required.
       * </pre>
       *
       * <code>BAD_NUMBER_OF_ROWS = 42;</code>
       */
      BAD_NUMBER_OF_ROWS(42),
      /**
       * <pre>
       * The values in the given column of the input rows do not represent valid
       * values according to the column type, or have values that conflict with
       * others according to the requirements on the input.
       * </pre>
       *
       * <code>VALUE_ERROR = 50;</code>
       */
      VALUE_ERROR(50),
      /**
       * <pre>
       * The values in the given column of the input rows do not match some
       * regular expression.
       * </pre>
       *
       * <code>REGEXP_MISMATCH = 51;</code>
       */
      REGEXP_MISMATCH(51),
      /**
       * <pre>
       * The values in the given column of the input rows are out of range.
       * </pre>
       *
       * <code>OUT_OF_RANGE = 52;</code>
       */
      OUT_OF_RANGE(52),
      /**
       * <pre>
       * The given column is null in the input rows, even though values are
       * required.
       * </pre>
       *
       * <code>MISSING_VALUE = 53;</code>
       */
      MISSING_VALUE(53),
      /**
       * <pre>
       * The values of the given key and rows of one table cannot be found a
       * values of the given key in another table. This is the case when a foreign
       * key of one table references a non-existing value in its original table.
       * </pre>
       *
       * <code>MISSING_KEY_DATA = 61;</code>
       */
      MISSING_KEY_DATA(61),
      /**
       * <pre>
       * The values of the given key and rows are duplicates. The first occurrence
       * of a value is not included in the duplicates list.
       * </pre>
       *
       * <code>DUPLICATE_KEY_VALUE = 62;</code>
       */
      DUPLICATE_KEY_VALUE(62),
      /**
       * <pre>
       * The values of the given key and rows reference a table that does not
       * exist.
       * </pre>
       *
       * <code>MISSING_KEY_TABLE = 63;</code>
       */
      MISSING_KEY_TABLE(63),
      /**
       * <pre>
       * The file size is too large to process (&gt;=4GiB).
       * </pre>
       *
       * <code>FILE_TOO_LARGE = 64;</code>
       */
      FILE_TOO_LARGE(64),
      ;

      /**
       * <pre>
       * The table file is missing.
       * </pre>
       *
       * <code>MISSING_TABLE = 10;</code>
       */
      public static final int MISSING_TABLE_VALUE = 10;
      /**
       * <pre>
       * The input file is not a well-formed csv.
       * </pre>
       *
       * <code>SPLITTING_ERROR = 20;</code>
       */
      public static final int SPLITTING_ERROR_VALUE = 20;
      /**
       * <pre>
       * The input file contained a null character ('&#92;0').
       * </pre>
       *
       * <code>CONTAINS_NULL_CHARACTER = 21;</code>
       */
      public static final int CONTAINS_NULL_CHARACTER_VALUE = 21;
      /**
       * <pre>
       * Deprecated.
       * </pre>
       *
       * <code>UTF8_CONVERSION_ERROR = 22 [deprecated = true];</code>
       */
      public static final int UTF8_CONVERSION_ERROR_VALUE = 22;
      /**
       * <pre>
       * The specified lines have characters that are not valid UTF-8 (either
       * structure or interchange).
       * </pre>
       *
       * <code>INVALID_UTF8 = 23;</code>
       */
      public static final int INVALID_UTF8_VALUE = 23;
      /**
       * <pre>
       * The input file CSV header has the same column name repeated.
       * </pre>
       *
       * <code>DUPLICATE_COLUMN_NAME = 24;</code>
       */
      public static final int DUPLICATE_COLUMN_NAME_VALUE = 24;
      /**
       * <pre>
       * A row in the input file has a different number of values than specified
       * by the CSV header.
       * </pre>
       *
       * <code>BAD_NUMBER_OF_VALUES = 25;</code>
       */
      public static final int BAD_NUMBER_OF_VALUES_VALUE = 25;
      /**
       * <pre>
       * The input file is corrupted and cannot be read properly.
       * </pre>
       *
       * <code>FILE_CORRUPTED = 26;</code>
       */
      public static final int FILE_CORRUPTED_VALUE = 26;
      /**
       * <pre>
       * A file was in an unexpected location
       * </pre>
       *
       * <code>UNEXPECTED_LOCATION = 27;</code>
       */
      public static final int UNEXPECTED_LOCATION_VALUE = 27;
      /**
       * <pre>
       * The column is missing in the input file, either the name cannot be found
       * in the header line, or the number is out of bound.
       * </pre>
       *
       * <code>MISSING_COLUMN = 30;</code>
       */
      public static final int MISSING_COLUMN_VALUE = 30;
      /**
       * <pre>
       * The key was not properly added to its table, probably because one or more
       * of its columns are missing.
       * </pre>
       *
       * <code>MISSING_KEY = 31;</code>
       */
      public static final int MISSING_KEY_VALUE = 31;
      /**
       * <pre>
       * The input rows are not properly sorted on the given key.
       * </pre>
       *
       * <code>UNSORTED = 40;</code>
       */
      public static final int UNSORTED_VALUE = 40;
      /**
       * <pre>
       * The values in the given column of the input rows are not 1..n when
       * grouped on some key.
       * </pre>
       *
       * <code>NON_CONTIGUOUS = 41;</code>
       */
      public static final int NON_CONTIGUOUS_VALUE = 41;
      /**
       * <pre>
       * The number of data rows of the table is not as required.
       * </pre>
       *
       * <code>BAD_NUMBER_OF_ROWS = 42;</code>
       */
      public static final int BAD_NUMBER_OF_ROWS_VALUE = 42;
      /**
       * <pre>
       * The values in the given column of the input rows do not represent valid
       * values according to the column type, or have values that conflict with
       * others according to the requirements on the input.
       * </pre>
       *
       * <code>VALUE_ERROR = 50;</code>
       */
      public static final int VALUE_ERROR_VALUE = 50;
      /**
       * <pre>
       * The values in the given column of the input rows do not match some
       * regular expression.
       * </pre>
       *
       * <code>REGEXP_MISMATCH = 51;</code>
       */
      public static final int REGEXP_MISMATCH_VALUE = 51;
      /**
       * <pre>
       * The values in the given column of the input rows are out of range.
       * </pre>
       *
       * <code>OUT_OF_RANGE = 52;</code>
       */
      public static final int OUT_OF_RANGE_VALUE = 52;
      /**
       * <pre>
       * The given column is null in the input rows, even though values are
       * required.
       * </pre>
       *
       * <code>MISSING_VALUE = 53;</code>
       */
      public static final int MISSING_VALUE_VALUE = 53;
      /**
       * <pre>
       * The values of the given key and rows of one table cannot be found a
       * values of the given key in another table. This is the case when a foreign
       * key of one table references a non-existing value in its original table.
       * </pre>
       *
       * <code>MISSING_KEY_DATA = 61;</code>
       */
      public static final int MISSING_KEY_DATA_VALUE = 61;
      /**
       * <pre>
       * The values of the given key and rows are duplicates. The first occurrence
       * of a value is not included in the duplicates list.
       * </pre>
       *
       * <code>DUPLICATE_KEY_VALUE = 62;</code>
       */
      public static final int DUPLICATE_KEY_VALUE_VALUE = 62;
      /**
       * <pre>
       * The values of the given key and rows reference a table that does not
       * exist.
       * </pre>
       *
       * <code>MISSING_KEY_TABLE = 63;</code>
       */
      public static final int MISSING_KEY_TABLE_VALUE = 63;
      /**
       * <pre>
       * The file size is too large to process (&gt;=4GiB).
       * </pre>
       *
       * <code>FILE_TOO_LARGE = 64;</code>
       */
      public static final int FILE_TOO_LARGE_VALUE = 64;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ErrorType valueOf(int value) {
        return forNumber(value);
      }

      public static ErrorType forNumber(int value) {
        switch (value) {
          case 10:
            return MISSING_TABLE;
          case 20:
            return SPLITTING_ERROR;
          case 21:
            return CONTAINS_NULL_CHARACTER;
          case 22:
            return UTF8_CONVERSION_ERROR;
          case 23:
            return INVALID_UTF8;
          case 24:
            return DUPLICATE_COLUMN_NAME;
          case 25:
            return BAD_NUMBER_OF_VALUES;
          case 26:
            return FILE_CORRUPTED;
          case 27:
            return UNEXPECTED_LOCATION;
          case 30:
            return MISSING_COLUMN;
          case 31:
            return MISSING_KEY;
          case 40:
            return UNSORTED;
          case 41:
            return NON_CONTIGUOUS;
          case 42:
            return BAD_NUMBER_OF_ROWS;
          case 50:
            return VALUE_ERROR;
          case 51:
            return REGEXP_MISMATCH;
          case 52:
            return OUT_OF_RANGE;
          case 53:
            return MISSING_VALUE;
          case 61:
            return MISSING_KEY_DATA;
          case 62:
            return DUPLICATE_KEY_VALUE;
          case 63:
            return MISSING_KEY_TABLE;
          case 64:
            return FILE_TOO_LARGE;
          default:
            return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ErrorType>
      internalGetValueMap() {
        return internalValueMap;
      }

      private static final com.google.protobuf.Internal.EnumLiteMap<
              ErrorType> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<ErrorType>() {
                public ErrorType findValueByNumber(int number) {
                  return ErrorType.forNumber(number);
                }
              };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
      getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }

      public final com.google.protobuf.Descriptors.EnumDescriptor
      getDescriptorForType() {
        return getDescriptor();
      }

      public static final com.google.protobuf.Descriptors.EnumDescriptor
      getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.getDescriptor().getEnumTypes().get(0);
      }

      private static final ErrorType[] VALUES = values();

      public static ErrorType valueOf(
              com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
                  "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private ErrorType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:csvspec.CsvErrorProto.ErrorType)
    }

    private int bitField0_;
    public static final int ERRORTYPE_FIELD_NUMBER = 1;
    private int errortype_;

    /**
     * <pre>
     * The type of the error.
     * </pre>
     *
     * <code>required .csvspec.CsvErrorProto.ErrorType errortype = 1;</code>
     */
    public boolean hasErrortype() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     * <pre>
     * The type of the error.
     * </pre>
     *
     * <code>required .csvspec.CsvErrorProto.ErrorType errortype = 1;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.ErrorType getErrortype() {
      @SuppressWarnings("deprecation")
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.ErrorType result = org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.ErrorType.valueOf(errortype_);
      return result == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.ErrorType.MISSING_TABLE : result;
    }

    public static final int LOCATION_FIELD_NUMBER = 2;
    private org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto location_;
    /**
     * <pre>
     * The location of the error, or locations rather, since multiple linenumbers
     * may be specified in a CsvErrorLocationProto.
     * </pre>
     *
     * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
     */
    public boolean hasLocation() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     * <pre>
     * The location of the error, or locations rather, since multiple linenumbers
     * may be specified in a CsvErrorLocationProto.
     * </pre>
     *
     * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto getLocation() {
      return location_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.getDefaultInstance() : location_;
    }

    /**
     * <pre>
     * The location of the error, or locations rather, since multiple linenumbers
     * may be specified in a CsvErrorLocationProto.
     * </pre>
     *
     * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProtoOrBuilder getLocationOrBuilder() {
      return location_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.getDefaultInstance() : location_;
    }

    public static final int OTHERLOCATION_FIELD_NUMBER = 3;
    private org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto otherlocation_;

    /**
     * <pre>
     * If this is a cross-reference error, the referred location may be specified
     * here.
     * </pre>
     *
     * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
     */
    public boolean hasOtherlocation() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * If this is a cross-reference error, the referred location may be specified
     * here.
     * </pre>
     *
     * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto getOtherlocation() {
      return otherlocation_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.getDefaultInstance() : otherlocation_;
    }

    /**
     * <pre>
     * If this is a cross-reference error, the referred location may be specified
     * here.
     * </pre>
     *
     * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProtoOrBuilder getOtherlocationOrBuilder() {
      return otherlocation_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.getDefaultInstance() : otherlocation_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasErrortype()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (hasLocation()) {
        if (!getLocation().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasOtherlocation()) {
        if (!getOtherlocation().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, errortype_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getLocation());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getOtherlocation());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, errortype_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getLocation());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(3, getOtherlocation());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto)) {
        return super.equals(obj);
      }
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto other = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto) obj;

      if (hasErrortype() != other.hasErrortype()) return false;
      if (hasErrortype()) {
        if (errortype_ != other.errortype_) return false;
      }
      if (hasLocation() != other.hasLocation()) return false;
      if (hasLocation()) {
        if (!getLocation()
            .equals(other.getLocation())) return false;
      }
      if (hasOtherlocation() != other.hasOtherlocation()) return false;
      if (hasOtherlocation()) {
        if (!getOtherlocation()
                .equals(other.getOtherlocation())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasErrortype()) {
        hash = (37 * hash) + ERRORTYPE_FIELD_NUMBER;
        hash = (53 * hash) + errortype_;
      }
      if (hasLocation()) {
        hash = (37 * hash) + LOCATION_FIELD_NUMBER;
        hash = (53 * hash) + getLocation().hashCode();
      }
      if (hasOtherlocation()) {
        hash = (37 * hash) + OTHERLOCATION_FIELD_NUMBER;
        hash = (53 * hash) + getOtherlocation().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto parseDelimitedFrom(
            java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
              ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csvspec.CsvErrorProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csvspec.CsvErrorProto)
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorProto_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.Builder.class);
      }

      // Construct using org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
              com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getLocationFieldBuilder();
          getOtherlocationFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        errortype_ = 10;
        bitField0_ = (bitField0_ & ~0x00000001);
        if (locationBuilder_ == null) {
          location_ = null;
        } else {
          locationBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (otherlocationBuilder_ == null) {
          otherlocation_ = null;
        } else {
          otherlocationBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
      getDescriptorForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorProto_descriptor;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto getDefaultInstanceForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto build() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto buildPartial() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto result = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.errortype_ = errortype_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          if (locationBuilder_ == null) {
            result.location_ = location_;
          } else {
            result.location_ = locationBuilder_.build();
          }
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          if (otherlocationBuilder_ == null) {
            result.otherlocation_ = otherlocation_;
          } else {
            result.otherlocation_ = otherlocationBuilder_.build();
          }
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(
              com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(
              com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto) {
          return mergeFrom((org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto other) {
        if (other == org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.getDefaultInstance())
          return this;
        if (other.hasErrortype()) {
          setErrortype(other.getErrortype());
        }
        if (other.hasLocation()) {
          mergeLocation(other.getLocation());
        }
        if (other.hasOtherlocation()) {
          mergeOtherlocation(other.getOtherlocation());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasErrortype()) {
          return false;
        }
        if (hasLocation()) {
          if (!getLocation().isInitialized()) {
            return false;
          }
        }
        if (hasOtherlocation()) {
          if (!getOtherlocation().isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private int errortype_ = 10;

      /**
       * <pre>
       * The type of the error.
       * </pre>
       *
       * <code>required .csvspec.CsvErrorProto.ErrorType errortype = 1;</code>
       */
      public boolean hasErrortype() {
        return ((bitField0_ & 0x00000001) != 0);
      }

      /**
       * <pre>
       * The type of the error.
       * </pre>
       *
       * <code>required .csvspec.CsvErrorProto.ErrorType errortype = 1;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.ErrorType getErrortype() {
        @SuppressWarnings("deprecation")
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.ErrorType result = org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.ErrorType.valueOf(errortype_);
        return result == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.ErrorType.MISSING_TABLE : result;
      }

      /**
       * <pre>
       * The type of the error.
       * </pre>
       *
       * <code>required .csvspec.CsvErrorProto.ErrorType errortype = 1;</code>
       */
      public Builder setErrortype(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.ErrorType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        errortype_ = value.getNumber();
        onChanged();
        return this;
      }

      /**
       * <pre>
       * The type of the error.
       * </pre>
       *
       * <code>required .csvspec.CsvErrorProto.ErrorType errortype = 1;</code>
       */
      public Builder clearErrortype() {
        bitField0_ = (bitField0_ & ~0x00000001);
        errortype_ = 10;
        onChanged();
        return this;
      }

      private org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto location_;
      private com.google.protobuf.SingleFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProtoOrBuilder> locationBuilder_;

      /**
       * <pre>
       * The location of the error, or locations rather, since multiple linenumbers
       * may be specified in a CsvErrorLocationProto.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
       */
      public boolean hasLocation() {
        return ((bitField0_ & 0x00000002) != 0);
      }

      /**
       * <pre>
       * The location of the error, or locations rather, since multiple linenumbers
       * may be specified in a CsvErrorLocationProto.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto getLocation() {
        if (locationBuilder_ == null) {
          return location_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.getDefaultInstance() : location_;
        } else {
          return locationBuilder_.getMessage();
        }
      }

      /**
       * <pre>
       * The location of the error, or locations rather, since multiple linenumbers
       * may be specified in a CsvErrorLocationProto.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
       */
      public Builder setLocation(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto value) {
        if (locationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          location_ = value;
          onChanged();
        } else {
          locationBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }

      /**
       * <pre>
       * The location of the error, or locations rather, since multiple linenumbers
       * may be specified in a CsvErrorLocationProto.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
       */
      public Builder setLocation(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.Builder builderForValue) {
        if (locationBuilder_ == null) {
          location_ = builderForValue.build();
          onChanged();
        } else {
          locationBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }

      /**
       * <pre>
       * The location of the error, or locations rather, since multiple linenumbers
       * may be specified in a CsvErrorLocationProto.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
       */
      public Builder mergeLocation(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto value) {
        if (locationBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
                  location_ != null &&
                  location_ != org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.getDefaultInstance()) {
            location_ =
                    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.newBuilder(location_).mergeFrom(value).buildPartial();
          } else {
            location_ = value;
          }
          onChanged();
        } else {
          locationBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }

      /**
       * <pre>
       * The location of the error, or locations rather, since multiple linenumbers
       * may be specified in a CsvErrorLocationProto.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
       */
      public Builder clearLocation() {
        if (locationBuilder_ == null) {
          location_ = null;
          onChanged();
        } else {
          locationBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * The location of the error, or locations rather, since multiple linenumbers
       * may be specified in a CsvErrorLocationProto.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.Builder getLocationBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getLocationFieldBuilder().getBuilder();
      }

      /**
       * <pre>
       * The location of the error, or locations rather, since multiple linenumbers
       * may be specified in a CsvErrorLocationProto.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProtoOrBuilder getLocationOrBuilder() {
        if (locationBuilder_ != null) {
          return locationBuilder_.getMessageOrBuilder();
        } else {
          return location_ == null ?
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.getDefaultInstance() : location_;
        }
      }

      /**
       * <pre>
       * The location of the error, or locations rather, since multiple linenumbers
       * may be specified in a CsvErrorLocationProto.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto location = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProtoOrBuilder>
      getLocationFieldBuilder() {
        if (locationBuilder_ == null) {
          locationBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProtoOrBuilder>(
                  getLocation(),
                  getParentForChildren(),
                  isClean());
          location_ = null;
        }
        return locationBuilder_;
      }

      private org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto otherlocation_;
      private com.google.protobuf.SingleFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProtoOrBuilder> otherlocationBuilder_;

      /**
       * <pre>
       * If this is a cross-reference error, the referred location may be specified
       * here.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
       */
      public boolean hasOtherlocation() {
        return ((bitField0_ & 0x00000004) != 0);
      }

      /**
       * <pre>
       * If this is a cross-reference error, the referred location may be specified
       * here.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto getOtherlocation() {
        if (otherlocationBuilder_ == null) {
          return otherlocation_ == null ? org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.getDefaultInstance() : otherlocation_;
        } else {
          return otherlocationBuilder_.getMessage();
        }
      }

      /**
       * <pre>
       * If this is a cross-reference error, the referred location may be specified
       * here.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
       */
      public Builder setOtherlocation(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto value) {
        if (otherlocationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          otherlocation_ = value;
          onChanged();
        } else {
          otherlocationBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }

      /**
       * <pre>
       * If this is a cross-reference error, the referred location may be specified
       * here.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
       */
      public Builder setOtherlocation(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.Builder builderForValue) {
        if (otherlocationBuilder_ == null) {
          otherlocation_ = builderForValue.build();
          onChanged();
        } else {
          otherlocationBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }

      /**
       * <pre>
       * If this is a cross-reference error, the referred location may be specified
       * here.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
       */
      public Builder mergeOtherlocation(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto value) {
        if (otherlocationBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
                  otherlocation_ != null &&
                  otherlocation_ != org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.getDefaultInstance()) {
            otherlocation_ =
                    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.newBuilder(otherlocation_).mergeFrom(value).buildPartial();
          } else {
            otherlocation_ = value;
          }
          onChanged();
        } else {
          otherlocationBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }

      /**
       * <pre>
       * If this is a cross-reference error, the referred location may be specified
       * here.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
       */
      public Builder clearOtherlocation() {
        if (otherlocationBuilder_ == null) {
          otherlocation_ = null;
          onChanged();
        } else {
          otherlocationBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      /**
       * <pre>
       * If this is a cross-reference error, the referred location may be specified
       * here.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.Builder getOtherlocationBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getOtherlocationFieldBuilder().getBuilder();
      }

      /**
       * <pre>
       * If this is a cross-reference error, the referred location may be specified
       * here.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProtoOrBuilder getOtherlocationOrBuilder() {
        if (otherlocationBuilder_ != null) {
          return otherlocationBuilder_.getMessageOrBuilder();
        } else {
          return otherlocation_ == null ?
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.getDefaultInstance() : otherlocation_;
        }
      }

      /**
       * <pre>
       * If this is a cross-reference error, the referred location may be specified
       * here.
       * </pre>
       *
       * <code>optional .csvspec.CsvErrorLocationProto otherlocation = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProtoOrBuilder>
      getOtherlocationFieldBuilder() {
        if (otherlocationBuilder_ == null) {
          otherlocationBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorLocationProtoOrBuilder>(
                  getOtherlocation(),
                  getParentForChildren(),
                  isClean());
          otherlocation_ = null;
        }
        return otherlocationBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csvspec.CsvErrorProto)
    }

    // @@protoc_insertion_point(class_scope:csvspec.CsvErrorProto)
    private static final org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto();
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<CsvErrorProto>
            PARSER = new com.google.protobuf.AbstractParser<CsvErrorProto>() {
      @java.lang.Override
      public CsvErrorProto parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return new CsvErrorProto(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CsvErrorProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CsvErrorProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CsvErrorProtosOrBuilder extends
          // @@protoc_insertion_point(interface_extends:csvspec.CsvErrorProtos)
          com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
     */
    java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto> 
        getErrorList();
    /**
     * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto getError(int index);
    /**
     * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
     */
    int getErrorCount();

    /**
     * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
     */
    java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtoOrBuilder>
    getErrorOrBuilderList();

    /**
     * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
     */
    org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtoOrBuilder getErrorOrBuilder(
            int index);
  }

  /**
   * Protobuf type {@code csvspec.CsvErrorProtos}
   */
  public static final class CsvErrorProtos extends
          com.google.protobuf.GeneratedMessageV3 implements
          // @@protoc_insertion_point(message_implements:csvspec.CsvErrorProtos)
          CsvErrorProtosOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use CsvErrorProtos.newBuilder() to construct.
    private CsvErrorProtos(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private CsvErrorProtos() {
      error_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
            UnusedPrivateParameter unused) {
      return new CsvErrorProtos();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }

    private CsvErrorProtos(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
              com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                error_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto>();
                mutable_bitField0_ |= 0x00000001;
              }
              error_.add(
                      input.readMessage(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                      input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
                e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          error_ = java.util.Collections.unmodifiableList(error_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor
    getDescriptor() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorProtos_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
    internalGetFieldAccessorTable() {
      return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorProtos_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
                  org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos.Builder.class);
    }

    public static final int ERROR_FIELD_NUMBER = 1;
    private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto> error_;
    /**
     * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
     */
    public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto> getErrorList() {
      return error_;
    }
    /**
     * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
     */
    public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtoOrBuilder> 
        getErrorOrBuilderList() {
      return error_;
    }

    /**
     * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
     */
    public int getErrorCount() {
      return error_.size();
    }

    /**
     * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto getError(int index) {
      return error_.get(index);
    }

    /**
     * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
     */
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtoOrBuilder getErrorOrBuilder(
            int index) {
      return error_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getErrorCount(); i++) {
        if (!getError(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      for (int i = 0; i < error_.size(); i++) {
        output.writeMessage(1, error_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < error_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(1, error_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos)) {
        return super.equals(obj);
      }
      org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos other = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos) obj;

      if (!getErrorList()
              .equals(other.getErrorList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getErrorCount() > 0) {
        hash = (37 * hash) + ERROR_FIELD_NUMBER;
        hash = (53 * hash) + getErrorList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
              ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     * Protobuf type {@code csvspec.CsvErrorProtos}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:csvspec.CsvErrorProtos)
            org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtosOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorProtos_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorProtos_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos.class, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos.Builder.class);
      }

      // Construct using org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
              com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getErrorFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (errorBuilder_ == null) {
          error_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          errorBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
      getDescriptorForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.internal_static_csvspec_CsvErrorProtos_descriptor;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos getDefaultInstanceForType() {
        return org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos.getDefaultInstance();
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos build() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos buildPartial() {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos result = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos(this);
        int from_bitField0_ = bitField0_;
        if (errorBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            error_ = java.util.Collections.unmodifiableList(error_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.error_ = error_;
        } else {
          result.error_ = errorBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(
              com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(
              com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos) {
          return mergeFrom((org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos other) {
        if (other == org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos.getDefaultInstance()) return this;
        if (errorBuilder_ == null) {
          if (!other.error_.isEmpty()) {
            if (error_.isEmpty()) {
              error_ = other.error_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureErrorIsMutable();
              error_.addAll(other.error_);
            }
            onChanged();
          }
        } else {
          if (!other.error_.isEmpty()) {
            if (errorBuilder_.isEmpty()) {
              errorBuilder_.dispose();
              errorBuilder_ = null;
              error_ = other.error_;
              bitField0_ = (bitField0_ & ~0x00000001);
              errorBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getErrorFieldBuilder() : null;
            } else {
              errorBuilder_.addAllMessages(other.error_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        for (int i = 0; i < getErrorCount(); i++) {
          if (!getError(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto> error_ =
        java.util.Collections.emptyList();
      private void ensureErrorIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          error_ = new java.util.ArrayList<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto>(error_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtoOrBuilder> errorBuilder_;

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto> getErrorList() {
        if (errorBuilder_ == null) {
          return java.util.Collections.unmodifiableList(error_);
        } else {
          return errorBuilder_.getMessageList();
        }
      }

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public int getErrorCount() {
        if (errorBuilder_ == null) {
          return error_.size();
        } else {
          return errorBuilder_.getCount();
        }
      }

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto getError(int index) {
        if (errorBuilder_ == null) {
          return error_.get(index);
        } else {
          return errorBuilder_.getMessage(index);
        }
      }

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public Builder setError(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto value) {
        if (errorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureErrorIsMutable();
          error_.set(index, value);
          onChanged();
        } else {
          errorBuilder_.setMessage(index, value);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public Builder setError(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.Builder builderForValue) {
        if (errorBuilder_ == null) {
          ensureErrorIsMutable();
          error_.set(index, builderForValue.build());
          onChanged();
        } else {
          errorBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public Builder addError(org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto value) {
        if (errorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureErrorIsMutable();
          error_.add(value);
          onChanged();
        } else {
          errorBuilder_.addMessage(value);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public Builder addError(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto value) {
        if (errorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureErrorIsMutable();
          error_.add(index, value);
          onChanged();
        } else {
          errorBuilder_.addMessage(index, value);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public Builder addError(
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.Builder builderForValue) {
        if (errorBuilder_ == null) {
          ensureErrorIsMutable();
          error_.add(builderForValue.build());
          onChanged();
        } else {
          errorBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public Builder addError(
              int index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.Builder builderForValue) {
        if (errorBuilder_ == null) {
          ensureErrorIsMutable();
          error_.add(index, builderForValue.build());
          onChanged();
        } else {
          errorBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public Builder addAllError(
              java.lang.Iterable<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto> values) {
        if (errorBuilder_ == null) {
          ensureErrorIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
                  values, error_);
          onChanged();
        } else {
          errorBuilder_.addAllMessages(values);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public Builder clearError() {
        if (errorBuilder_ == null) {
          error_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          errorBuilder_.clear();
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public Builder removeError(int index) {
        if (errorBuilder_ == null) {
          ensureErrorIsMutable();
          error_.remove(index);
          onChanged();
        } else {
          errorBuilder_.remove(index);
        }
        return this;
      }

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.Builder getErrorBuilder(
              int index) {
        return getErrorFieldBuilder().getBuilder(index);
      }

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtoOrBuilder getErrorOrBuilder(
              int index) {
        if (errorBuilder_ == null) {
          return error_.get(index);
        } else {
          return errorBuilder_.getMessageOrBuilder(index);
        }
      }

      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public java.util.List<? extends org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtoOrBuilder>
      getErrorOrBuilderList() {
        if (errorBuilder_ != null) {
          return errorBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(error_);
        }
      }
      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.Builder addErrorBuilder() {
        return getErrorFieldBuilder().addBuilder(
            org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.getDefaultInstance());
      }
      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.Builder addErrorBuilder(
          int index) {
        return getErrorFieldBuilder().addBuilder(
            index, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.getDefaultInstance());
      }
      /**
       * <code>repeated .csvspec.CsvErrorProto error = 1;</code>
       */
      public java.util.List<org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.Builder> 
           getErrorBuilderList() {
        return getErrorFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtoOrBuilder> 
          getErrorFieldBuilder() {
        if (errorBuilder_ == null) {
          errorBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProto.Builder, org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtoOrBuilder>(
                  error_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          error_ = null;
        }
        return errorBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csvspec.CsvErrorProtos)
    }

    // @@protoc_insertion_point(class_scope:csvspec.CsvErrorProtos)
    private static final org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos();
    }

    public static org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<CsvErrorProtos>
        PARSER = new com.google.protobuf.AbstractParser<CsvErrorProtos>() {
      @java.lang.Override
      public CsvErrorProtos parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CsvErrorProtos(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CsvErrorProtos> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CsvErrorProtos> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mobilitydata.gtfsvalidator.protos.GtfsSpecificationProto.CsvErrorProtos getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csvspec_ColumnInputType_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csvspec_ColumnInputType_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csvspec_SupersetKeySpecProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csvspec_SupersetKeySpecProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csvspec_NamedValueProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csvspec_NamedValueProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csvspec_ColumnCacheProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csvspec_ColumnCacheProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csvspec_ColumnSpecProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csvspec_ColumnSpecProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csvspec_KeySpecProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csvspec_KeySpecProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csvspec_CsvSpecProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csvspec_CsvSpecProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csvspec_CsvSpecProtos_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csvspec_CsvSpecProtos_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csvspec_CsvErrorColumnProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csvspec_CsvErrorColumnProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csvspec_CsvErrorLinesProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csvspec_CsvErrorLinesProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csvspec_CsvErrorLocationProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csvspec_CsvErrorLocationProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csvspec_CsvErrorProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csvspec_CsvErrorProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csvspec_CsvErrorProtos_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csvspec_CsvErrorProtos_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\rcsvspec.proto\022\007csvspec\"\267\002\n\017ColumnInput" +
      "Type\0220\n\004type\030\001 \002(\0162\".csvspec.ColumnInput" +
      "Type.InputType\"\361\001\n\tInputType\022\032\n\026INPUT_TY" +
      "PE_UNSPECIFIED\020\000\022\010\n\004TEXT\020\001\022\t\n\005COLOR\020\002\022\t\n" +
      "\005FLOAT\020\003\022\010\n\004DATE\020\004\022\010\n\004TIME\020\005\022\021\n\rCURRENCY" +
      "_CODE\020\006\022\t\n\005EMAIL\020\007\022\010\n\004ENUM\020\010\022\006\n\002ID\020\t\022\021\n\r" +
      "LANGUAGE_CODE\020\n\022\014\n\010LATITUDE\020\013\022\r\n\tLONGITU" +
      "DE\020\014\022\013\n\007INTEGER\020\r\022\020\n\014PHONE_NUMBER\020\016\022\014\n\010T" +
      "IMEZONE\020\017\022\007\n\003URL\020\020\"g\n\024SupersetKeySpecPro" +
      "to\022\017\n\007csvname\030\001 \002(\t\022\017\n\007keyname\030\002 \002(\t\022-\n\036" +
      "restrictnulltosingleforeignkey\030\003 \001(\010:\005fa" +
      "lse\"X\n\017NamedValueProto\022\014\n\004name\030\001 \002(\t\022\020\n\010" +
      "intvalue\030\002 \001(\003\022\023\n\013stringvalue\030\003 \001(\t\022\020\n\010e" +
      "numtype\030\004 \001(\t\"K\n\020ColumnCacheProto\022\034\n\rcac" +
      "he_numbers\030\001 \001(\010:\005false\022\031\n\ncache_keys\030\002 " +
      "\001(\010:\005false\"\357\003\n\017ColumnSpecProto\022\014\n\004name\030\001" +
      " \002(\t\022\024\n\014originalname\030\002 \001(\t\022\016\n\006number\030\003 \001" +
      "(\005\022\034\n\rinheritfields\030\017 \001(\010:\005false\022\026\n\010requ" +
      "ired\030\004 \001(\010:\004true\022\023\n\tnullvalue\030\005 \001(\t:\000\022\035\n" +
      "\016value_required\030\021 \001(\010:\005false\022&\n\004type\030\006 \001" +
      "(\0132\030.csvspec.ColumnInputType\022\016\n\006intmin\030\007" +
      " \001(\005\022\016\n\006intmax\030\010 \001(\005\022\020\n\010floatmin\030\r \001(\002\022\020" +
      "\n\010floatmax\030\016 \001(\002\022,\n\nnamedvalue\030\020 \003(\0132\030.c" +
      "svspec.NamedValueProto\022\023\n\013matchregexp\030\t " +
      "\001(\t\022\033\n\014uniquevalues\030\n \001(\010:\005false\0222\n\013supe" +
      "rsetkey\030\013 \003(\0132\035.csvspec.SupersetKeySpecP" +
      "roto\022(\n\005cache\030\014 \001(\0132\031.csvspec.ColumnCach" +
      "eProto\022\024\n\014field_number\030\022 \001(\005\"\201\001\n\014KeySpec" +
      "Proto\022\014\n\004name\030\001 \002(\t\022\022\n\ncolumnname\030\002 \003(\t\022" +
      "\033\n\014uniquevalues\030\003 \001(\010:\005false\0222\n\013superset" +
      "key\030\004 \003(\0132\035.csvspec.SupersetKeySpecProto" +
      "\"\364\003\n\014CsvSpecProto\022\014\n\004name\030\001 \002(\t\022\020\n\010filen" +
      "ame\030\002 \001(\t\022\034\n\rinheritfields\030\014 \001(\010:\005false\022" +
      "\"\n\023inheritinputcolumns\030\r \001(\010:\005false\022\032\n\013i" +
      "nheritkeys\030\017 \001(\010:\005false\022\026\n\010required\030\003 \001(" +
      "\010:\004true\022\027\n\thasheader\030\004 \001(\010:\004true\022\027\n\010enco" +
      "ding\030\005 \001(\t:\005UTF-8\022(\n\006column\030\006 \003(\0132\030.csvs" +
      "pec.ColumnSpecProto\022\"\n\003key\030\007 \003(\0132\025.csvsp" +
      "ec.KeySpecProto\022\021\n\tresortkey\030\010 \001(\t\022\032\n\022re" +
      "quiresortedonkey\030\t \003(\t\022,\n\nnamedvalue\030\020 \003" +
      "(\0132\030.csvspec.NamedValueProto\022.\n&strip_pr" +
      "otected_whitespace_from_values\030\022 \001(\010\022/\n\014" +
      "column_cache\030\023 \001(\0132\031.csvspec.ColumnCache" +
      "ProtoJ\004\010\n\020\013J\004\010\013\020\014J\004\010\016\020\017\"\343\001\n\rCsvSpecProto" +
      "s\022\024\n\014templatefile\030\002 \001(\t\022&\n\007csvspec\030\001 \003(\013" +
      "2\025.csvspec.CsvSpecProto\022,\n\nnamedvalue\030\003 " +
      "\003(\0132\030.csvspec.NamedValueProto\0225\n&strip_p" +
      "rotected_whitespace_from_values\030\004 \001(\010:\005f" +
      "alse\022/\n\014column_cache\030\005 \001(\0132\031.csvspec.Col" +
      "umnCacheProto\"s\n\023CsvErrorColumnProto\022\r\n\005" +
      "index\030\001 \001(\005\022\014\n\004type\030\002 \001(\005\022\024\n\014originalnam" +
      "e\030\003 \001(\t\022)\n\007colspec\030\004 \001(\0132\030.csvspec.Colum" +
      "nSpecProto\"8\n\022CsvErrorLinesProto\022\021\n\tstar" +
      "tline\030\001 \002(\005\022\017\n\007endline\030\002 \001(\005\"\315\001\n\025CsvErro" +
      "rLocationProto\022\017\n\007csvname\030\001 \001(\t\022\023\n\013csvfi" +
      "lename\030\002 \001(\t\022\017\n\007keyname\030\003 \001(\t\022,\n\006column\030" +
      "\004 \003(\0132\034.csvspec.CsvErrorColumnProto\022\022\n\nl" +
      "inenumber\030\005 \003(\005\022.\n\tlinerange\030\006 \003(\0132\033.csv" +
      "spec.CsvErrorLinesProto\022\013\n\003row\030\007 \003(\005\"\227\005\n" +
      "\rCsvErrorProto\0223\n\terrortype\030\001 \002(\0162 .csvs" +
      "pec.CsvErrorProto.ErrorType\0220\n\010location\030" +
      "\002 \001(\0132\036.csvspec.CsvErrorLocationProto\0225\n" +
      "\rotherlocation\030\003 \001(\0132\036.csvspec.CsvErrorL" +
      "ocationProto\"\347\003\n\tErrorType\022\021\n\rMISSING_TA" +
      "BLE\020\n\022\023\n\017SPLITTING_ERROR\020\024\022\033\n\027CONTAINS_N" +
      "ULL_CHARACTER\020\025\022\035\n\025UTF8_CONVERSION_ERROR" +
      "\020\026\032\002\010\001\022\020\n\014INVALID_UTF8\020\027\022\031\n\025DUPLICATE_CO" +
      "LUMN_NAME\020\030\022\030\n\024BAD_NUMBER_OF_VALUES\020\031\022\022\n" +
      "\016FILE_CORRUPTED\020\032\022\027\n\023UNEXPECTED_LOCATION" +
      "\020\033\022\022\n\016MISSING_COLUMN\020\036\022\017\n\013MISSING_KEY\020\037\022" +
      "\014\n\010UNSORTED\020(\022\022\n\016NON_CONTIGUOUS\020)\022\026\n\022BAD" +
      "_NUMBER_OF_ROWS\020*\022\017\n\013VALUE_ERROR\0202\022\023\n\017RE" +
      "GEXP_MISMATCH\0203\022\020\n\014OUT_OF_RANGE\0204\022\021\n\rMIS" +
      "SING_VALUE\0205\022\024\n\020MISSING_KEY_DATA\020=\022\027\n\023DU" +
      "PLICATE_KEY_VALUE\020>\022\025\n\021MISSING_KEY_TABLE" +
      "\020?\022\022\n\016FILE_TOO_LARGE\020@\"7\n\016CsvErrorProtos" +
      "\022%\n\005error\030\001 \003(\0132\026.csvspec.CsvErrorProtoB" +
      "?\n%org.mobilitydata.gtfsvalidator.protos" +
      "B\026GtfsSpecificationProto"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_csvspec_ColumnInputType_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_csvspec_ColumnInputType_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csvspec_ColumnInputType_descriptor,
        new java.lang.String[] { "Type", });
    internal_static_csvspec_SupersetKeySpecProto_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_csvspec_SupersetKeySpecProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csvspec_SupersetKeySpecProto_descriptor,
        new java.lang.String[] { "Csvname", "Keyname", "Restrictnulltosingleforeignkey", });
    internal_static_csvspec_NamedValueProto_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_csvspec_NamedValueProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csvspec_NamedValueProto_descriptor,
        new java.lang.String[] { "Name", "Intvalue", "Stringvalue", "Enumtype", });
    internal_static_csvspec_ColumnCacheProto_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_csvspec_ColumnCacheProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csvspec_ColumnCacheProto_descriptor,
        new java.lang.String[] { "CacheNumbers", "CacheKeys", });
    internal_static_csvspec_ColumnSpecProto_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_csvspec_ColumnSpecProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csvspec_ColumnSpecProto_descriptor,
        new java.lang.String[] { "Name", "Originalname", "Number", "Inheritfields", "Required", "Nullvalue", "ValueRequired", "Type", "Intmin", "Intmax", "Floatmin", "Floatmax", "Namedvalue", "Matchregexp", "Uniquevalues", "Supersetkey", "Cache", "FieldNumber", });
    internal_static_csvspec_KeySpecProto_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_csvspec_KeySpecProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csvspec_KeySpecProto_descriptor,
        new java.lang.String[] { "Name", "Columnname", "Uniquevalues", "Supersetkey", });
    internal_static_csvspec_CsvSpecProto_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_csvspec_CsvSpecProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csvspec_CsvSpecProto_descriptor,
        new java.lang.String[] { "Name", "Filename", "Inheritfields", "Inheritinputcolumns", "Inheritkeys", "Required", "Hasheader", "Encoding", "Column", "Key", "Resortkey", "Requiresortedonkey", "Namedvalue", "StripProtectedWhitespaceFromValues", "ColumnCache", });
    internal_static_csvspec_CsvSpecProtos_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_csvspec_CsvSpecProtos_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csvspec_CsvSpecProtos_descriptor,
        new java.lang.String[] { "Templatefile", "Csvspec", "Namedvalue", "StripProtectedWhitespaceFromValues", "ColumnCache", });
    internal_static_csvspec_CsvErrorColumnProto_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_csvspec_CsvErrorColumnProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csvspec_CsvErrorColumnProto_descriptor,
        new java.lang.String[] { "Index", "Type", "Originalname", "Colspec", });
    internal_static_csvspec_CsvErrorLinesProto_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_csvspec_CsvErrorLinesProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csvspec_CsvErrorLinesProto_descriptor,
        new java.lang.String[] { "Startline", "Endline", });
    internal_static_csvspec_CsvErrorLocationProto_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_csvspec_CsvErrorLocationProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csvspec_CsvErrorLocationProto_descriptor,
        new java.lang.String[] { "Csvname", "Csvfilename", "Keyname", "Column", "Linenumber", "Linerange", "Row", });
    internal_static_csvspec_CsvErrorProto_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_csvspec_CsvErrorProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csvspec_CsvErrorProto_descriptor,
        new java.lang.String[] { "Errortype", "Location", "Otherlocation", });
    internal_static_csvspec_CsvErrorProtos_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_csvspec_CsvErrorProtos_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csvspec_CsvErrorProtos_descriptor,
        new java.lang.String[] { "Error", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
