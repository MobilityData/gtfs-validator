// Code generated by gradle generateViewerAssets; DO NOT EDIT.
/*
 * Copyright 2020-2021 Google LLC, MobilityData IO
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Snabbdom license.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Simon Friis Vindum
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package org.mobilitydata.gtfsvalidator.viewer;

public class ViewerAssets {
  public static String IndexCss() {
    return "/* Validator  */\n"
        + "\n"
        + "body {\n"
        + "    font-family: Arial, sans-serif;\n"
        + "}\n"
        + "h2 {\n"
        + "    width:100%;\n"
        + "    padding:15px;\n"
        + "    position:relative;\n"
        + "}\n"
        + "\n"
        + "button {\n"
        + "    color: #fff;\n"
        + "    background-color: #909090;\n"
        + "    border: none;\n"
        + "    padding: 8px 16px;\n"
        + "    vertical-align: middle;\n"
        + "    text-align: center;\n"
        + "    cursor: pointer\n"
        + "}\n"
        + "\n"
        + ".severity-error {\n"
        + "    background: #f7a7a3;\n"
        + "}\n"
        + "\n"
        + ".severity-warning {\n"
        + "    background: #ffd48a;\n"
        + "}\n"
        + "\n"
        + ".severity-info {\n"
        + "    background: #ebebeb;\n"
        + "}\n"
        + "\n"
        + ".severity-unknown {\n"
        + "    background: #fff;\n"
        + "}\n"
        + "\n"
        + "pre { background: #ddd; }\n"
        + "\n"
        + "\n"
        + "/* Form */\n"
        + "h1 {\n"
        + "    margin:20px auto;\n"
        + "    padding:30px;\n"
        + "    text-align: center;\n"
        + "}\n"
        + "\n"
        + "form.table-like {\n"
        + "    display: table;\n"
        + "}\n"
        + "\n"
        + "div.row-like {\n"
        + "    display: table-row;\n"
        + "}\n"
        + "\n"
        + "label, input {\n"
        + "    display: table-cell;\n"
        + "    margin-bottom: 10px;\n"
        + "}\n"
        + "\n"
        + "label {\n"
        + "    padding-right: 10px;\n"
        + "}\n"
        + "\n";
  }

  public static String IndexJs() {
    return "let h = snabbdom.h // For convenience.\n"
        + "\n"
        + "ReportView = {\n"
        + "    // Report Viewer State.\n"
        + "    container: null, // The DOM node we render into. Used for the first render.\n"
        + "    vnode: null, // Previous vnode. Snabbdom uses this to calculate the diff.\n"
        + "    showNotice: report.notices.map(()=>false), // Should this notice # be shown?\n"
        + "\n"
        + "    patch: snabbdom.init([ \n"
        + "        // Initialize Snabbdom patch function with chosen modules.\n"
        + "        snabbdom.classModule, // Makes it easy to toggle classes.\n"
        + "        snabbdom.propsModule, // For setting properties on DOM elements.\n"
        + "        snabbdom.styleModule, // Handles styling on elements with support for animations.\n"
        + "        snabbdom.eventListenersModule, // Attaches event listeners.\n"
        + "    ]),\n"
        + "\n"
        + "    showNoticeButton: function(i) {\n"
        + "        // Toggle button to show/hide a notice #.\n"
        + "        if (ReportView.showNotice[i]) {\n"
        + "            return h('button',\n"
        + "                { on: { click: () => ReportView.toggleShowNotice(i) } },\n"
        + "                'Hide Details <<'\n"
        + "            )\n"
        + "        } else {\n"
        + "            return h('button',\n"
        + "                { on: { click: () => ReportView.toggleShowNotice(i) } },\n"
        + "                'Show Details >> '\n"
        + "            )\n"
        + "        }\n"
        + "    },\n"
        + "\n"
        + "    toggleShowNotice: i => {\n"
        + "        console.log(\"toggleShowNotice(\", i, \")\")\n"
        + "        ReportView.showNotice[i] = ! ReportView.showNotice[i]\n"
        + "        ReportView.render()\n"
        + "    },\n"
        + "\n"
        + "    view: () => h(\"div\",\n"
        + "        // The global variable \"report\" is defined in report.json.js, included\n"
        + "        // by the index.html page.\n"
        + "        report.notices.map((x,i) => {\n"
        + "            let severity_class = \"severity-unknown\"\n"
        + "            let header_text = x.code \n"
        + "            if (x.severity != null) {\n"
        + "                // Apply a corresponding CSS class for this severity.\n"
        + "                severity_class = \"severity-\" + x.severity.toLowerCase()\n"
        + "                header_text = x.code + \" (\" + x.severity.toLowerCase() + \")\"\n"
        + "            }\n"
        + "            return h(\"div\", [\n"
        + "                h(`h2.${severity_class}`, header_text),\n"
        + "                ReportView.showNoticeButton(i),\n"
        + "                ReportView.showNotice[i] ? NoticeDetails.view(x) : h(\"!\", \"This notice is currently hidden.\"),\n"
        + "            ])\n"
        + "        }),\n"
        + "    ),\n"
        + "\n"
        + "    render: function()  {\n"
        + "        if (ReportView.container == null) {\n"
        + "            // Initialize container to the DOM element on our first call.\n"
        + "            ReportView.container = document.getElementById(\"container\");\n"
        + "        }\n"
        + "        if (ReportView.vnode == null) {\n"
        + "            // Initialize vnode to the empty DOM element on our first call.\n"
        + "            ReportView.vnode = ReportView.container\n"
        + "        }\n"
        + "        let newVnode = ReportView.view()\n"
        + "        ReportView.patch(ReportView.vnode, newVnode);\n"
        + "        ReportView.vnode = newVnode\n"
        + "    }\n"
        + "}\n"
        + "\n"
        + "// Multiple error reports use this field combination.\n"
        + "var NoticeDetailsGenericFieldValueCodeView = n => h(\"ul\",\n"
        + "    n.sampleNotices.map(y => h(\"li\", \n"
        + "        `column: ${y.fieldName} value:\"${y.fieldValue}\" (${y.filename}:${y.csvRowNumber}) `,\n"
        + "    ))) \n"
        + "\n"
        + "var NoticeDetails = {\n"
        + "    view: function (notice) {\n"
        + "        // View for a single notice within the report.\n"
        + "        if (NoticeDetails.codeView[notice.code] != null) {\n"
        + "            // Use a specialized view for this code if one exists.\n"
        + "            return NoticeDetails.codeView[notice.code](notice)\n"
        + "        }\n"
        + "        // Otherwise use a a generic view.\n"
        + "        return NoticeDetails.genericCodeView(notice)\n"
        + "    },\n"
        + "\n"
        + "    genericCodeView: (notice) => h(\"div\", {}, [\n"
        + "        h(\"ul\",\n"
        + "            notice.sampleNotices.map((y) => {\n"
        + "                let filename = y.filename\n"
        + "                let csvRowNumber = y.csvRowNumber\n"
        + "                if (filename == null) {\n"
        + "                    filename = 'unspecified filename'\n"
        + "                }\n"
        + "                if (csvRowNumber == null) {\n"
        + "                    csvRowNumber = ''\n"
        + "                }\n"
        + "                return h(\"li\", `(${y.filename}:${y.csvRowNumber})`)\n"
        + "            },\n"
        + "            )), \n"
        + "        h(\"pre\", JSON.stringify(notice, true, \"  \")),\n"
        + "    ]),\n"
        + "\n"
        + "    codeView: {\n"
        + "        // Functions indexed by notice code. See gtfs-validator/docs/NOTICES.md.\n"
        + "        //\n"
        + "        \n"
        + "        attribution_without_role: n => h(\"div\", [\n"
        + "            h(\"p\", \"Validates that an attribution has at least one role: is_producer, is_operator, or is_authority.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `attribution_id: ${y.attributionId} (attributions.txt:${y.csvRowNumber}) `,\n"
        + "            )))\n"
        + "        ]),\n"
        + "\n"
        + "        block_trips_with_overlapping_stop_times: n => {\n"
        + "            let filename = \"trips.txt\"\n"
        + "            return h(\"div\", [\n"
        + "                h(\"p\", \"Describes two trips with the same block id that have overlapping stop times.\"),\n"
        + "                h(\"ul\",\n"
        + "                    n.sampleNotices.map(y => h(\"li\", `\n"
        + "                        block ${y.blockId} used by trip_id ${y.tripIdA} (${y.filename}:${y.csvRowNumberA}) \n"
        + "                        overlaps on ${y.intersection} with\n"
        + "                        use by trip_id ${y.tripIdB} (${y.filename}:${y.csvRowNumberB}) \n"
        + "                        `)))\n"
        + "            ])\n"
        + "        },\n"
        + "\n"
        + "        csv_parsing_failed: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", `At char ${y.charIndex} of ${y.filename}:${y.lineIndex}, ${y.message}`))\n"
        + "        ),\n"
        + "\n"
        + "        decreasing_or_equal_shape_distance: n=> {\n"
        + "            let filename = \"shapes.txt\"\n"
        + "            return h(\"div\", [\n"
        + "                h(\"p\", \"When sorted on `shapes.shape_pt_sequence` key, shape points should have strictly increasing values for `shapes.shape_dist_traveled\"),\n"
        + "                h(\"p\", \"Values must increase along with shape_pt_sequence. For more information, please vist:\"),\n"
        + "                h(\"a\", { props: { href: \"http://gtfs.org/reference/static/#shapestxt.\" } }, \"http://gtfs.org/reference/static/#shapestxt.\"),\n"
        + "                h(\"p\",\n"
        + "                    n.sampleNotices.map(y => h(\"\", [\n"
        + "                        h(\"p\", { style: { fontWeight: \"bold\"} }, `shape_id: ${y.shapeId}`),\n"
        + "                        h(\"ul\", [\n"
        + "                            h(\"li\", ` shape_pt_sequence=${y.shapePtSequence} (${y.filename}:${y.csvRowNumber})`),\n"
        + "                            h(\"li\", `distance ${y.shapeDistTraveled} is <= ${y.prevShapeDistTraveled} at shape_pt_sequence=${y.prevShapePtSequence} (${y.filename}:${y.prevCsvRowNumber})`)\n"
        + "                        ])\n"
        + "                    ]\n"
        + "                )))\n"
        + "            ])\n"
        + "        },\n"
        + "\n"
        + "        decreasing_or_equal_stop_time_distance: n => {\n"
        + "            let filename = \"stop_times.txt\"\n"
        + "            return h(\"div\", [\n"
        + "                h(\"p\", \"When sorted on `stops.stop_sequence` key, stop times should have strictly increasing values for `stops.shape_dist_traveled`\"),\n"
        + "                h(\"p\", \"Values used for shape_dist_traveled must increase along with stop_sequence. For more information, please vist:\"),\n"
        + "                h(\"a\", { props: { href: \"http://gtfs.org/reference/static/#stoptimestxt\" } }, \"http://gtfs.org/reference/static/#stoptimestxt\"),\n"
        + "                h(\"p\",\n"
        + "                    n.sampleNotices.map(y => h(\"p\", [\n"
        + "                        h(\"p\", { style: { fontWeight: \"bold\"} }, `trip_id: ${y.tripId}`),\n"
        + "                        h(\"ul\", [\n"
        + "                            h(\"li\", ` stop_sequence=${y.stopSequence} (stop_times.txt:${y.csvRowNumber})`),\n"
        + "                            h(\"li\", `distance ${y.shapeDistTraveled} is <= ${y.prevStopTimeDistTraveled} at stop_sequence=${y.prevStopSequence} (stop_times.txt:${y.prevCsvRowNumber})`)\n"
        + "                        ]) \n"
        + "                    ]\n"
        + "                )))\n"
        + "            ])\n"
        + "        },\n"
        + "\n"
        + "        duplicated_column: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", `\"${y.fieldName}\" (${y.filename} #${y.firstIndex} is duplicate to #${y.secondIndex})`))),\n"
        + "\n"
        + "\n"
        + "\n"
        + "        duplicate_fare_rule_zone_id_fields: n => {\n"
        + "            let filename = \"fare_rules.txt\"\n"
        + "            return h(\"div\", [\n"
        + "                h(\"p\", \"Rows from \\\"fare_rules.txtn\\\" must be unique based on \\\"fare_rules.route_idn\\\", \\\"fare_rules.origin_id\\\", \\\"fare_rules.contains_id\\\" and \\\"fare_rules.destination_id\\\"\"),\n"
        + "                h(\"ul\",\n"
        + "                n.sampleNotices.map(y => h(\"li\", `\n"
        + "                fare_id: ${y.fareId} (${y.filename}:${y.csvRowNumber}) has duplicate zones to fare_id: ${y.previousFareId} (${y.filename}:${y.previousCsvRowNumber})`)))\n"
        + "            ])\n"
        + "        },\n"
        + "\n"
        + "        duplicate_key: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", `\n"
        + "                ${y.fieldName1} ${y.fieldValue1} (${y.filename}:${y.oldCsvRowNumber}) is duplicate to ${y.fieldName2} ${y.fieldValue2} (${y.filename}:${y.newCsvRowNumber})`))),\n"
        + "\n"
        + "        duplicate_route_name: n => h(\"div\", [\n"
        + "            h(\"p\", \"Describes two routes that have the same long and short names, route type and belong to the same agency.\"),\n"
        + "            h(\"ul\",\n"
        + "                n.sampleNotices.map(y => h(\"li\", \n"
        + "                    `route_id ${y.routeId1} \"${y.routeLongName1}\" (routes.txt:${y.csvRowNumber1}) has a duplicate id, short name or long name of route_id ${y.routeId2} \"${y.routeLongName2}\" (routes.txt:${y.csvRowNumber2})`,\n"
        + "                )))\n"
        + "        ]), \n"
        + "\n"
        + "        empty_column_name: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", `\"No column name for (${y.filename} #${y.index})`))),\n"
        + "\n"
        + "        empty_row: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", `\"No row in (${y.filename}:${y.csvRowNumber}})`))),\n"
        + "\n"
        + "        empty_file: n => h(\"ul\",\n"
        + "            n.sampleNotices.map((y) => h(\"li\", `\"${y.filename}\"`))), \n"
        + "\n"
        + "        fast_travel_between_consecutive_stops: n => h(\"ul\",\n"
        + "                n.sampleNotices.map(y => h(\"li\", [\n"
        + "                    h(\"p\", [\n"
        + "                        h(\"text\", `trip_id: ${y.tripId} route ${y.routeId} (trips.txt:${y.tripCsvRowNumber})`),\n"
        + "                        h(\"text\", `stop_id ${y.stopId1} \"${y.stopName1}\" stop_sequence=${y.stopSequence1} lat/lon ${y.match1} departed ${y.departureTime1} (stop_times.txt:${y.csvRowNumber1})`),\n"
        + "                        h(\"text\", `arrived ${y.arrivalTime2} stop_id ${y.stopId2} \"${y.stopName2}\" stop_sequence=${y.stopSequence2} lat/lon ${y.match2} (stop_times.txt:${y.csvRowNumber2})`),\n"
        + "                        h(\"text\", `a distance of ${y.distance}km with a speed of ${y.speedKph}km/h.`)\n"
        + "                    ])\n"
        + "                ]\n"
        + "            ))), \n"
        + "\n"
        + "        fast_travel_between_far_stops: n => h(\"div\", [\n"
        + "            h(\"p\", \"Describes a trip where the transit vehicle moves too fast between two far stops.\"),\n"
        + "            h(\"p\", \"This normally indicates a more serious problem than too fast travel between consecutive stops.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `trip_id: ${y.tripId} route ${y.routeId} (trips.txt:${y.tripCsvRowNumber}) \n"
        + "                stop_id ${y.stopId1} \"${y.stopName1}\" stop_sequence=${y.stopSequence1} lat/lon ${y.match1} departed ${y.departureTime1} (stop_times.txt:${y.csvRowNumber1})\n"
        + "                arrived ${y.arrivalTime2} stop_id ${y.stopId2} \"${y.stopName2}\" stop_sequence=${y.stopSequence2} lat/lon ${y.match2} (stop_times.txt:${y.csvRowNumber2})\n"
        + "                a distance of ${y.distance}km with a speed of ${y.speedKph}km/h.`,\n"
        + "            ))) \n"
        + "        ]), \n"
        + "\n"
        + "        feed_expiration_date: n => h(\"div\", [\n"
        + "            h(\"p\", \"Validates a feed's expiration date: 1) At any time, the published GTFS dataset should be valid for at least the next 7 days 2) If possible, the GTFS dataset should cover at least the next 30 days of service.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", `\n"
        + "                Feed ended ${y.feedEndDate}, suggested end date ${y.suggestedExpirationDate}\n"
        + "                (feed_info.txt:#${y.csvRowNumber})`)))\n"
        + "        ]),\n"
        + "\n"
        + "        feed_info_lang_and_agency_mismatch: n => h(\"div\", [\n"
        + "            h(\"p\", \"agency.agency_lang and feed_info.feed_lang do not match.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map((y) => h(\"li\",\n"
        + "                 `Agency ${y.agencyId} language \"${y.agencyLang}\" was expected to match \n"
        + "                feed language \"${y.feedLang}\" (agency.txt:${y.csvRowNumber})`)))\n"
        + "        ]),\n"
        + "        \n"
        + "        foreign_key_violation: n => h(\"div\", [\n"
        + "            h(\"p\", \"Validates that service_id field in \\\"trips.txt\\\" references a valid service_id in \\\"calendar.txt\\\" or \\\"calendar_date.txt\\\"\"),\n"
        + "            h(\"ul\",\n"
        + "                n.sampleNotices.map((y) => h(\"li\", `\n"
        + "                    \"${y.fieldValue}\" (${y.parentFilename}:${y.csvRowNumber} @ ${y.parentFieldName}) -> \n"
        + "                    (${y.childFilename} @ ${y.childFieldName})`)))\n"
        + "        ]),\n"
        + "\n"
        + "        inconsistent_agency_lang: n => h(\"div\", [\n"
        + "            h(\"p\", \"Inconsistent language among agencies.\"),\n"
        + "            h(\"ul\",\n"
        + "                n.sampleNotices.map((y) => h(\"li\",\n"
        + "                    `Language ${y.actual}\" was expected to be \"${y.expected}\" (agency.txt:${y.csvRowNumber})`)))\n"
        + "        ]),\n"
        + "\n"
        + "        inconsistent_agency_timezone: n => h(\"div\", [\n"
        + "            h(\"p\", \"Inconsistent timezone among agencies.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map((y) => h(\"li\",\n"
        + "                 `Time zone \"${y.actual}\" was expected to be \"${y.expected}\" (agency.txt:${y.csvRowNumber})`)))\n"
        + "        ]),\n"
        + "\n"
        + "        invalid_color: NoticeDetailsGenericFieldValueCodeView,\n"
        + "        invalid_currency: NoticeDetailsGenericFieldValueCodeView,\n"
        + "        invalid_date: NoticeDetailsGenericFieldValueCodeView,\n"
        + "        invalid_email: NoticeDetailsGenericFieldValueCodeView,\n"
        + "        invalid_float: NoticeDetailsGenericFieldValueCodeView,\n"
        + "        invalid_integer: NoticeDetailsGenericFieldValueCodeView,\n"
        + "        invalid_language_code: NoticeDetailsGenericFieldValueCodeView,\n"
        + "        invalid_phone_number: NoticeDetailsGenericFieldValueCodeView,\n"
        + "\n"
        + "        invalid_row_length: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `Length: \"${y.rowLength}\" (${y.filename}:${y.csvRowNumber} #${y.headerCount}) `,\n"
        + "            ))), \n"
        + "\n"
        + "        invalid_time: NoticeDetailsGenericFieldValueCodeView,\n"
        + "        invalid_timezone: NoticeDetailsGenericFieldValueCodeView,\n"
        + "        invalid_url: NoticeDetailsGenericFieldValueCodeView,\n"
        + "\n"
        + "        i_o_error: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `exception: \"${y.exception}\" message: \"${y.message}\"`,\n"
        + "            ))),\n"
        + "\n"
        + "        leading_or_trailing_whitespaces: NoticeDetailsGenericFieldValueCodeView,\n"
        + "\n"
        + "        location_with_unexpected_stop_time: n => h(\"div\", [\n"
        + "            h(\"p\", \"Describes a location in stops.txt that is not a stop but has a stop time associated.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `stop_id: ${y.stopId} \"${y.stopName}\" (stops.txt:${y.csvRowNumber}) and (stop_times.txt${y.stopTimeCsvRowNumber})`,\n"
        + "            )))\n"
        + "        ]),\n"
        + "\n"
        + "        location_without_parent_station: n => h(\"div\", [\n"
        + "            h(\"p\", \"A location that must have `parent_station` field does not have it.\"),\n"
        + "            h(\"p\", \"The following location types must have `parent_station`: entrance, generic node, boarding area.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `stop_id: ${y.stopId} \"${y.stopName}\" location_type: ${y.locationType} (stops.txt:${y.csvRowNumber})`,\n"
        + "            )))\n"
        + "        ]),\n"
        + "        \n"
        + "\n"
        + "        missing_calendar_and_calendar_date_files: n => h(\"p\", \"Both the calendar.txt and calendar_dates.txt files are missing.\"),\n"
        + "\n"
        + "        missing_feed_info_date: n => h(\"div\", [\n"
        + "            h(\"p\", \"Even though `feed_info.start_date` and `feed_info.end_date` are optional, if one field is provided the second one should also be provided.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `column: ${y.fieldName} (feed_info.txt:${y.csvRowNumber}) `,\n"
        + "            )))\n"
        + "        ]),\n"
        + "\n"
        + "        missing_level_id: n => h(\"div\", [\n"
        + "            h(\"p\", \"A row from stops.txt is linked to a row from pathways.txt with pathways.pathway_mode=5 but has no value for stops.level_id.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", `stop_id: ${y.stopId} (levels.txt:${y.csvRowNumber})`)))\n"
        + "        ]), \n"
        + "        \n"
        + "\n"
        + "        missing_required_column: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `column: ${y.fieldName} (${y.filename}) `,\n"
        + "            ))), \n"
        + "\n"
        + "        missing_required_field: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `column: ${y.fieldName} (${y.filename}:${y.csvRowNumber}) `,\n"
        + "            ))), \n"
        + "\n"
        + "        missing_required_file:  n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `column: ${y.fieldName} (${y.filename}:${y.csvRowNumber}) `,\n"
        + "            ))), \n"
        + "\n"
        + "        missing_timepoint_column: n => h(\"div\", [\n"
        + "            h(\"p\", \"Column stop_times.timepoint is missing.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", `${y.filename}`,)))\n"
        + "        ]),\n"
        + "        \n"
        + "        missing_timepoint_value: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", `trip_id ${y.tripId} stop_sequence=${y.stopSequence} (stop_times.txt:${y.csvRowNumber})`,))),\n"
        + "\n"
        + "        missing_trip_edge: n => h(\"div\", [\n"
        + "            h(\"p\", \"First and last stop of a trip must define both `arrival_time` and `departure_time` fields.\"),\n"
        + "            h(\"p\", \"If there are not separate times for arrival and departure at a stop, enter the same value for arrival_time and departure_time.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `trip_id: ${y.tripId} - stop_sequence=${y.stopSequence} (${y.filename}:${y.csvRowNumber})`,\n"
        + "            )))\n"
        + "        ]), \n"
        + "\n"
        + "        more_than_one_entity: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", `Found ${y.entityCount} entities in (${y.filename})`,))), \n"
        + "\n"
        + "        new_line_in_value: NoticeDetailsGenericFieldValueCodeView,\n"
        + "\n"
        + "        number_out_of_range: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `column: ${y.fieldName} value:\"${y.fieldValue}\" type ${y.fieldType} (${y.filename}:${y.csvRowNumber}) `,\n"
        + "            ))), \n"
        + "\n"
        + "        non_ascii_or_non_printable_char: NoticeDetailsGenericFieldValueCodeView,\n"
        + "\n"
        + "        overlapping_frequency: n => {\n"
        + "            let filename = \"frequencies.txt\"\n"
        + "            return  h(\"div\", [\n"
        + "                h(\"p\", \"Two frequency entries referring to the same trip may not have an overlapping time range.\"),\n"
        + "                h(\"p\", \"Two entries X and Y are considered to directly overlap if <i>X.start_time &lt;= Y.start_time</i> and <i>Y.start_time &lt;X.end_time</i>\"),\n"
        + "                h(\"ul\",\n"
        + "                n.sampleNotices.map(y => h(\"li\", `\n"
        + "                    trip_id: ${y.tripId} start time ${y.currStartTime} (${y.filename}:${y.currCsvRowNumber}) \n"
        + "                    overlaps with end time ${y.prevEndTime} (${y.filename}:${y.prevCsvRowNumber}) \n"
        + "                    `))) \n"
        + "            ])\n"
        + "        },\n"
        + "\n"
        + "        pathway_dangling_generic_node: n => h(\"div\", [\n"
        + "            h(\"p\", \"Describes a dangling generic node, i.e. that has only one incident location in a pathway graph.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => {\n"
        + "                return h(\"li\", \n"
        + "                    `stop_id ${y.stopId} \"${y.stopName}\" parent ${y.parentStation} (pathways.txt:${y.csvRowNumber})`,\n"
        + "                )\n"
        + "            }))\n"
        + "        ]), \n"
        + "\n"
        + "        pathway_loop: n => h(\"div\", [\n"
        + "            h(\"p\", \"Validates that pathway is not a loop, i.e. it does not start and end at the same location.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => {\n"
        + "                return h(\"li\", \n"
        + "                    `stop_id ${y.stopId} pathway_id \"${y.pathwayId}\" (pathways.txt:${y.csvRowNumber})`\n"
        + "                )\n"
        + "            }))\n"
        + "        ]),\n"
        + "\n"
        + "        pathway_unreachable_location: n => h(\"div\", [\n"
        + "            h(\"p\", \"Describes a location that is not reachable at least in one direction: from the entrances or to the exits.\"),\n"
        + "            h(\"ul\",\n"
        + "                n.sampleNotices.map(y => {\n"
        + "                    let unreachables = ''\n"
        + "                    if (!!y.hasEntrance && !y.hasExit) {\n"
        + "                        unreachables = \"is not reachable from the entrance nor the exit\"\n"
        + "                    } else if (!y.hasEntrance) {\n"
        + "                        unreachables = \"is not reachable from the entrance\"\n"
        + "                    } else if (!y.hasExit) {\n"
        + "                        unreachables = \"is not reachable from the exit\"\n"
        + "                    }\n"
        + "                    return h(\"li\", \n"
        + "                        `stop_id ${y.stopId} (type ${y.locationType}) \"${y.stopName}\" ${unreachables} \n"
        + "                        from ${y.parentStation} (pathways.txt:${y.csvRowNumber})`\n"
        + "                    )\n"
        + "                }))\n"
        + "        ]),\n"
        + "\n"
        + "        platform_without_parent_station: n => h(\"div\", [\n"
        + "            h(\"p\", \"A platform has no parent_station field set.\"),\n"
        + "            h(\"p\", \"This is different from LocationWithoutParentStationNotice since it is less severe.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `stop_id: ${y.stopId} \"${y.stopName}\" location_type: ${y.locationType} (stops.txt:${y.csvRowNumber})`,\n"
        + "            )))\n"
        + "        ]),\n"
        + "        \n"
        + "\n"
        + "        point_near_origin: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => {\n"
        + "                return h(\"p\", [\n"
        + "                    h(\"li\", `Latitude ${y.lonFieldName} ${y.lonFieldValue}`),\n"
        + "                    h(\"li\", `Longitude ${y.latFieldName} ${y.latFieldValue} `),\n"
        + "                    h(\"li\", `(${y.filename}:${y.csvRowNumber})`)\n"
        + "                ])\n"
        + "            })), \n"
        + "\n"
        + "        route_both_short_and_long_name_missing: n => h(\"div\", [\n"
        + "            h(\"p\", \"Both `routes.route_short_name` and `routes.route_long_name` are missing for a route.\"),\n"
        + "            h(\"ul\", \n"
        + "            n.sampleNotices.map(y => h(\"li\", `(routes.txt:${y.csvRowNumber}) `)))\n"
        + "            ]), \n"
        + "\n"
        + "        route_color_contrast: n => h(\"div\", [\n"
        + "            h(\"p\", \"The color difference between route_color and route_text_color should provide sufficient contrast when viewed on a black and white screen. For more information, please visit:\"),\n"
        + "            h(\"a\", { props: { href: \"http://gtfs.org/best-practices/#routestxt\" } }, \"http://gtfs.org/best-practices/#routestxt\"),\n"
        + "            h(\"ul\", \n"
        + "                n.sampleNotices.map(y => h(\"p\", [\n"
        + "                    h(\"li\", `route_id: ${y.routeId}`),\n"
        + "                    h(\"li\", `text color \"${y.routeTextColor}\" & color \"${y.routeColor}\" (routes.txt:${y.csvRowNumber}) `)\n"
        + "                ])\n"
        + "            ))\n"
        + "            ]), \n"
        + "\n"
        + "        route_short_and_long_name_equal: n => h(\"div\", [\n"
        + "            h(\"p\", \"Short and long name are equal for a single route.\"),\n"
        + "            h(\"ul\", \n"
        + "            n.sampleNotices.map(y => h(\"li\", `route_id: ${y.routeId} (routes.txt:${y.csvRowNumber}) `)))\n"
        + "            ]),\n"
        + "\n"
        + "        route_short_name_too_long: n => h(\"div\", [\n"
        + "            h(\"p\", \"Short name of a single route is too long (more than 12 characters. For more information, please visit:\"),\n"
        + "            h(\"a\", { props: { href: \"http://gtfs.org/best-practices/#routestxt\" } }, \"http://gtfs.org/best-practices/#routestxt\"),\n"
        + "            h(\"ul\", \n"
        + "            n.sampleNotices.map(y => h(\"li\", `route_id: ${y.routeId} (routes.txt:${y.csvRowNumber}) `)))\n"
        + "            ]), \n"
        + "\n"
        + "        runtime_exception_in_loader_error: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `exception: \"${y.exception}\" message: \"${y.message}\"${y.stopName}\" (${y.filename}`,\n"
        + "            ))),\n"
        + "\n"
        + "        runtime_exception_in_validator_error: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `validator \"${y.validator}\" exception: \"${y.exception}\" message: \"${y.message}\"`,\n"
        + "            ))),\n"
        + "\n"
        + "        same_name_and_description_for_route: n => h(\"div\", [\n"
        + "            h(\"p\", \"A single route has identical values for routes.route_desc and route_long_name or route_short_name.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", `route_id: ${y.routeId} ${y.specifiedField} (routes.txt:${y.csvRowNumber}) `\n"
        + "            )))\n"
        + "        ]),\n"
        + "\n"
        + "        same_name_and_description_for_stop: n => h(\"div\", [\n"
        + "            h(\"p\", \"A stop has an identical value in stops.route_desc and stops.stop_name.\"),\n"
        + "            h(\"p\", \"Do not simply duplicate the name of the location. For more informantion, please visit:\"),\n"
        + "            h(\"a\", { props: { href: \"http://gtfs.org/reference/static#stopstxt\" } }, \"http://gtfs.org/reference/static#stopstxt\"),\n"
        + "            h(\"ul\", \n"
        + "            n.sampleNotices.map(y => h(\"li\", `stop_id: ${y.stopId} \"${y.stopDesc}\" (stops.txt:${y.csvRowNumber}) `)))\n"
        + "            ]), \n"
        + "\n"
        + "        same_route_and_agency_url: n => h(\"div\", [\n"
        + "            h(\"p\", \"A Route uses the same URL in routes.route_url as has the Agency in agency.txt.\"),\n"
        + "            h(\"ul\", \n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `route_id: ${y.routeId} (routes.txt:${y.routeCsvRowNumber}) agency_id: ${y.agencyId} (agency.txt:${y.agencyCsvRowNumber}) `)))\n"
        + "        ]), \n"
        + "\n"
        + "        same_stop_and_agency_url: n => h(\"div\", [\n"
        + "            h(\"p\", \"A Stop uses the same URL in stops.stop_url as uses an Agency in agency.txt.\"),\n"
        + "            h(\"ul\", \n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `stop_id: ${y.stopId} (stops.txt:${y.stopCsvRowNumber}) agency_id: ${y.agencyId} (agency.txt:${y.agencyCsvRowNumber}) `))) \n"
        + "            ]),\n"
        + "\n"
        + "        same_stop_and_route_url: n => h(\"div\", [\n"
        + "            h(\"p\", \"A Stop uses the same URL for stops.stop_url as uses a Route in routes.txt.\"),\n"
        + "            h(\"ul\", \n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `stop_id: ${y.stopId} (stops.txt:${y.stopCsvRowNumber}) route_id: ${y.routeId} (route.txt:${y.routeCsvRowNumber}) `)))\n"
        + "            ]), \n"
        + "\n"
        + "        start_and_end_range_equal: n => h(\"ul\", \n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `Value ${y.value} is the same in ${y.startFieldName} and ${y.endFieldName} (${y.filename}:${y.csvRowNumber}) `))), \n"
        + "\n"
        + "        start_and_end_range_out_of_order: n => h(\"ul\", \n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `Value \"${y.value}\" of ${y.startFieldName} is out of order with respect to\n"
        + "                value \"${y.endValue}\" of ${y.endFieldName} for service_id ${y.entityId} (${y.filename}:${y.csvRowNumber}) `))), \n"
        + "\n"
        + "        station_with_parent_station: n => h(\"div\", [\n"
        + "            h(\"p\", \"A station has `parent_station` field set.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `Station ${y.stopId} \"${y.stopName}\" has a parent ${y.parentStation} (stops.txt:${y.csvRowNumber})`)))\n"
        + "            ]),\n"
        + "\n"
        + "        stop_has_too_many_matches_for_shape: n => h(\"div\", [\n"
        + "            h(\"p\", \"Describes a stop entry that has many potential matches to the trip's path of travel, as defined by the shape entry in shapes.txt.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `trip_id: ${y.tripId} shape_id ${y.shapeId} (trips.txt:${y.tripCsvRowNumber}) \n"
        + "                stop_id ${y.stopId} \"${y.stopName}\" lat/lon ${y.match} maches ${y.matchCount} times (stop_times.txt:${y.stopTimeCsvRowNumber})`,\n"
        + "            )))\n"
        + "        ]),\n"
        + "\n"
        + "        stops_match_shape_out_of_order: n => h(\"div\", [\n"
        + "            h(\"p\", \"Two stop entries in stop_times.txt appear in a different orderering than their shape would indicate in the shapes.txt file.\"),\n"
        + "            h(\"p\", \"This could indicate a problem with the location of the stops, the path of the shape, or the sequence of the stops for their trip.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `trip_id: ${y.tripId} shape_id ${y.shapeId} (trips.txt:${y.tripCsvRowNumber}) \n"
        + "                stop_id ${y.stopId1} \"${y.stopName1}\" lat/lon ${y.match1} (stop_times.txt:${y.stopTimeCsvRowNumber1})\n"
        + "                stop_id ${y.stopId2} \"${y.stopName2}\" lat/lon ${y.match2} (stop_times.txt:${y.stopTimeCsvRowNumber2})`,\n"
        + "            )))\n"
        + "            ]), \n"
        + "\n"
        + "        stop_time_timepoint_without_times: n => h(\"div\", [\n"
        + "            h(\"p\", \"Timepoint without a departure time or arrival time.\"),\n"
        + "            h(\"ul\",\n"
        + "                n.sampleNotices.map(y => h(\"p\", [\n"
        + "                    h(\"li\", { style: { fontWeight: \"bold\", listStyleType: \"none\", paddingLeft: 0} }, `trip_id: ${y.tripId}`),\n"
        + "                    h(\"li\", { style: { listStyleType: \"none\"} }, `stop_sequence=${y.stopSequence} missing ${y.specifiedField} (stop_times.txt:${y.csvRowNumber})`)\n"
        + "                ]))\n"
        + "            )    \n"
        + "        ]), \n"
        + "\n"
        + "        stop_time_with_arrival_before_previous_departure_time: n => h(\"div\", [\n"
        + "            h(\"p\", \"Two stop times are out of order.\"),\n"
        + "            h(\"p\",\n"
        + "                n.sampleNotices.map(y => h(\"p\", [\n"
        + "                    h(\"p\", { style: { fontWeight: \"bold\"} }, `trip_id: ${y.tripId}`),\n"
        + "                    h(\"ul\", [\n"
        + "                        h(\"li\", `stop_sequence=${y.stopSequence}`),\n"
        + "                        h(\"li\", `arrival ${y.arrivalTime} (stop_times.txt:${y.csvRowNumber})\\nis before previous departure ${y.departureTime} (stop_times.txt:${y.prevCsvRowNumber})`)\n"
        + "                    ])\n"
        + "                ]\n"
        + "            )))\n"
        + "        ]),\n"
        + "\n"
        + "        stop_time_with_only_arrival_or_departure_time: n =>  h(\"div\", [\n"
        + "            h(\"p\", \"Missing stop_times.arrival_time or stop_times.departure_time\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `trip_id: ${y.tripId} - stop_sequence=${y.stopSequence} has only ${y.specifiedField} (stop_times.txt:${y.csvRowNumber})`,\n"
        + "            )))\n"
        + "            ]),\n"
        + "\n"
        + "        // stop_too_far_from_trip_shape: \n"
        + "        // Notices.md has this but it's been deprecated per MIGRATION_V2_V3.md\n"
        + "\n"
        + "        stop_too_far_from_shape_using_user_distance: n => h(\"div\", [\n"
        + "            h(\"p\", \"Describes a stop time entry that is a large distance away from the location of the shape in shapes.txt as defined by shape_dist_traveled values.\"),\n"
        + "            h(\"p\", \"This potentially indicates a problem with the location of the stop or the use of shape_dist_traveled values.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `trip_id: ${y.tripId} shape_id ${y.shapeId} (trips.txt:${y.tripCsvRowNumber}) \n"
        + "                stop_id ${y.stopId} \"${y.stopName}\" lat/lon ${y.match} is ${y.geoDistanceToShape} from shape (stop_times.txt:${y.stopTimeCsvRowNumber})`,\n"
        + "            )))\n"
        + "        ]), \n"
        + "\n"
        + "        stop_too_far_from_shape: n => h(\"div\", [\n"
        + "            h(\"p\", \"Describes a stop time entry that is a large distance away from the trip's path of travel, as defined by the shape entry in shapes.txt.\"),\n"
        + "            h(\"p\", \"This potentially indicates a problem with the location of the stop or the path of the shape.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `trip_id: ${y.tripId} shape_id ${y.shapeId} (trips.txt:${y.tripCsvRowNumber}) \n"
        + "                stop_id ${y.stopId} \"${y.stopName}\" lat/lon ${y.match} is ${y.geoDistanceToShape} from shape (stop_times.txt:${y.stopTimeCsvRowNumber})`,\n"
        + "            )))\n"
        + "        ]), \n"
        + "\n"
        + "        stop_without_stop_time: n => {\n"
        + "            let filename = \"stop_times.txt\"\n"
        + "            return h(\"div\", [\n"
        + "                h(\"p\", \"Describes a stop that does not have any stop time associated.\"),\n"
        + "                h(\"ul\",\n"
        + "                n.sampleNotices.map(y => h(\"li\", \n"
        + "                    `stop_id: ${y.stopId} \"${y.stopName}\" (${y.filename}:${y.csvRowNumber}) `\n"
        + "                )))\n"
        + "            ])\n"
        + "        },\n"
        + "        \n"
        + "        // too_fast_travel: \n"
        + "        // Notices.md has this but it's been deprecated per MIGRATION_V2_V3.md\n"
        + "\n"
        + "        stop_without_zone_id: n => {\n"
        + "            let filename = \"stops.txt\"\n"
        + "            return h(\"div\", [\n"
        + "                h(\"p\", \"All all stops and platforms (location_type = 0) should have stops.zone_id assigned.\"),\n"
        + "                h(\"ul\",\n"
        + "                n.sampleNotices.map(y => h(\"li\", \n"
        + "                    `stop_id: ${y.stopId} \"${y.stopName}\" (${y.filename}:${y.csvRowNumber}) `,\n"
        + "                )))\n"
        + "            ])\n"
        + "        },\n"
        + "\n"
        + "        thread_excecution_error: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `exception: \"${y.exception}\" message: \"${y.message}\"`,\n"
        + "            ))),\n"
        + "\n"
        + "        translation_foreign_key_violation: n => h(\"div\", [\n"
        + "            h(\"p\", \"An entity with the given (record_id, record_sub_id) cannot be found in the referenced table.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `table ${y.tableName} record_id ${y.recordId} record_sub_id ${y.recordSubId} (translations.txt:${y.csvRowNumber}) `,\n"
        + "            )))\n"
        + "        ]), \n"
        + "\n"
        + "        translation_unknown_table_name: n => h(\"div\", [\n"
        + "            h(\"p\", \"A translation references an unknown or missing GTFS table.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `table name: ${y.tableName} (translations.txt:${y.csvRowNumber}) `,\n"
        + "            )))\n"
        + "            ]), \n"
        + "\n"
        + "        translation_unexpected_value: n => h(\"div\", [\n"
        + "            h(\"p\", \"A field in a translations row has value but must be empty.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `column: ${y.fieldName} value:\"${y.fieldValue}\" (translations.txt:${y.csvRowNumber}) `,\n"
        + "            )))\n"
        + "        ]), \n"
        + "\n"
        + "        unexpected_enum_value: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `column: ${y.fieldName} value:\"${y.fieldValue}\" (${y.filename}:${y.csvRowNumber}) `,\n"
        + "            ))), \n"
        + "\n"
        + "        unknown_column: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", `\"${y.fieldName}\" (${y.filename} #${y.index})`))),\n"
        + "\n"
        + "        unknown_file: n => h(\"ul\",\n"
        + "            n.sampleNotices.map((y) => h(\"li\", `\"${y.filename}\"`))), \n"
        + "\n"
        + "        unusable_trip: n => h(\"div\", [\n"
        + "            h(\"p\", \"A Trip should be referred to by at least two Stop Times.\"),\n"
        + "            h(\"ul\",\n"
        + "                n.sampleNotices.map(y => h(\"li\",\n"
        + "                `trip_id: ${y.tripId} (trips.txt:${y.csvRowNumber})`\n"
        + "                )))\n"
        + "            ]),\n"
        + "\n"
        + "        unused_shape: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `shape_id: ${y.shapeId} (shapes.txt:${y.csvRowNumber})`,\n"
        + "            ))), \n"
        + "\n"
        + "        unused_trip: n => h(\"div\", [\n"
        + "            h(\"p\", \"Every Trip in trips.txt should be used by some Stop Time in stop_times.txt\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `trip_id: ${y.tripId} (trips.txt:${y.csvRowNumber})`\n"
        + "            )))\n"
        + "        ]),\n"
        + "\n"
        + "        u_r_i_syntax_error: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `exception: \"${y.exception}\" message: \"${y.message}\"`,\n"
        + "            ))),\n"
        + "\n"
        + "        wrong_parent_location_type: n => h(\"div\", [\n"
        + "            h(\"p\", \"A platform has no `parent_station` field set.\"),\n"
        + "            h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", \n"
        + "                `stop_id: ${y.stopId} \"${y.stopName}\" type ${y.locationType} (stops.txt:${y.csvRowNumber}) \n"
        + "                parent stop_id: ${y.parentStation} \"${y.parentStopName}\" type ${y.parentLocationType} (stops.txt:${y.parentCsvRowNumber})`,\n"
        + "            )))\n"
        + "        ]),\n"
        + "\n"
        + "        wrong_stop_time_stop_location_type: n => h(\"ul\",\n"
        + "            n.sampleNotices.map(y => h(\"li\", `trip_id ${y.tripId} - stop_sequence=${y.stopSequence} \n"
        + "                stop_id: ${y.stopId} type ${y.locationType} (stop_times.txt:${y.csvRowNumber})`,))) \n"
        + "\n"
        + "    },\n"
        + "}\n"
        + "\n";
  }

  public static String SnabbdomBrowserJs() {
    return "(function (global, factory) {\n"
        + "    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n"
        + "    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n"
        + "    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.snabbdom = {}));\n"
        + "})(this, (function (exports) { 'use strict';\n"
        + "\n"
        + "    function createElement(tagName, options) {\n"
        + "        return document.createElement(tagName, options);\n"
        + "    }\n"
        + "    function createElementNS(namespaceURI, qualifiedName, options) {\n"
        + "        return document.createElementNS(namespaceURI, qualifiedName, options);\n"
        + "    }\n"
        + "    function createDocumentFragment() {\n"
        + "        return document.createDocumentFragment();\n"
        + "    }\n"
        + "    function createTextNode(text) {\n"
        + "        return document.createTextNode(text);\n"
        + "    }\n"
        + "    function createComment(text) {\n"
        + "        return document.createComment(text);\n"
        + "    }\n"
        + "    function insertBefore(parentNode, newNode, referenceNode) {\n"
        + "        parentNode.insertBefore(newNode, referenceNode);\n"
        + "    }\n"
        + "    function removeChild(node, child) {\n"
        + "        node.removeChild(child);\n"
        + "    }\n"
        + "    function appendChild(node, child) {\n"
        + "        node.appendChild(child);\n"
        + "    }\n"
        + "    function parentNode(node) {\n"
        + "        return node.parentNode;\n"
        + "    }\n"
        + "    function nextSibling(node) {\n"
        + "        return node.nextSibling;\n"
        + "    }\n"
        + "    function tagName(elm) {\n"
        + "        return elm.tagName;\n"
        + "    }\n"
        + "    function setTextContent(node, text) {\n"
        + "        node.textContent = text;\n"
        + "    }\n"
        + "    function getTextContent(node) {\n"
        + "        return node.textContent;\n"
        + "    }\n"
        + "    function isElement$1(node) {\n"
        + "        return node.nodeType === 1;\n"
        + "    }\n"
        + "    function isText(node) {\n"
        + "        return node.nodeType === 3;\n"
        + "    }\n"
        + "    function isComment(node) {\n"
        + "        return node.nodeType === 8;\n"
        + "    }\n"
        + "    function isDocumentFragment$1(node) {\n"
        + "        return node.nodeType === 11;\n"
        + "    }\n"
        + "    const htmlDomApi = {\n"
        + "        createElement,\n"
        + "        createElementNS,\n"
        + "        createTextNode,\n"
        + "        createDocumentFragment,\n"
        + "        createComment,\n"
        + "        insertBefore,\n"
        + "        removeChild,\n"
        + "        appendChild,\n"
        + "        parentNode,\n"
        + "        nextSibling,\n"
        + "        tagName,\n"
        + "        setTextContent,\n"
        + "        getTextContent,\n"
        + "        isElement: isElement$1,\n"
        + "        isText,\n"
        + "        isComment,\n"
        + "        isDocumentFragment: isDocumentFragment$1,\n"
        + "    };\n"
        + "\n"
        + "    function vnode(sel, data, children, text, elm) {\n"
        + "        const key = data === undefined ? undefined : data.key;\n"
        + "        return { sel, data, children, text, elm, key };\n"
        + "    }\n"
        + "\n"
        + "    const array = Array.isArray;\n"
        + "    function primitive(s) {\n"
        + "        return typeof s === \"string\" ||\n"
        + "            typeof s === \"number\" ||\n"
        + "            s instanceof String ||\n"
        + "            s instanceof Number;\n"
        + "    }\n"
        + "\n"
        + "    function isUndef(s) {\n"
        + "        return s === undefined;\n"
        + "    }\n"
        + "    function isDef(s) {\n"
        + "        return s !== undefined;\n"
        + "    }\n"
        + "    const emptyNode = vnode(\"\", {}, [], undefined, undefined);\n"
        + "    function sameVnode(vnode1, vnode2) {\n"
        + "        var _a, _b;\n"
        + "        const isSameKey = vnode1.key === vnode2.key;\n"
        + "        const isSameIs = ((_a = vnode1.data) === null || _a === void 0 ? void 0 : _a.is) === ((_b = vnode2.data) === null || _b === void 0 ? void 0 : _b.is);\n"
        + "        const isSameSel = vnode1.sel === vnode2.sel;\n"
        + "        return isSameSel && isSameKey && isSameIs;\n"
        + "    }\n"
        + "    /**\n"
        + "     * @todo Remove this function when the document fragment is considered stable.\n"
        + "     */\n"
        + "    function documentFragmentIsNotSupported() {\n"
        + "        throw new Error(\"The document fragment is not supported on this platform.\");\n"
        + "    }\n"
        + "    function isElement(api, vnode) {\n"
        + "        return api.isElement(vnode);\n"
        + "    }\n"
        + "    function isDocumentFragment(api, vnode) {\n"
        + "        return api.isDocumentFragment(vnode);\n"
        + "    }\n"
        + "    function createKeyToOldIdx(children, beginIdx, endIdx) {\n"
        + "        var _a;\n"
        + "        const map = {};\n"
        + "        for (let i = beginIdx; i <= endIdx; ++i) {\n"
        + "            const key = (_a = children[i]) === null || _a === void 0 ? void 0 : _a.key;\n"
        + "            if (key !== undefined) {\n"
        + "                map[key] = i;\n"
        + "            }\n"
        + "        }\n"
        + "        return map;\n"
        + "    }\n"
        + "    const hooks = [\n"
        + "        \"create\",\n"
        + "        \"update\",\n"
        + "        \"remove\",\n"
        + "        \"destroy\",\n"
        + "        \"pre\",\n"
        + "        \"post\",\n"
        + "    ];\n"
        + "    function init$1(modules, domApi, options) {\n"
        + "        const cbs = {\n"
        + "            create: [],\n"
        + "            update: [],\n"
        + "            remove: [],\n"
        + "            destroy: [],\n"
        + "            pre: [],\n"
        + "            post: [],\n"
        + "        };\n"
        + "        const api = domApi !== undefined ? domApi : htmlDomApi;\n"
        + "        for (const hook of hooks) {\n"
        + "            for (const module of modules) {\n"
        + "                const currentHook = module[hook];\n"
        + "                if (currentHook !== undefined) {\n"
        + "                    cbs[hook].push(currentHook);\n"
        + "                }\n"
        + "            }\n"
        + "        }\n"
        + "        function emptyNodeAt(elm) {\n"
        + "            const id = elm.id ? \"#\" + elm.id : \"\";\n"
        + "            // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\n"
        + "            // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\n"
        + "            const classes = elm.getAttribute(\"class\");\n"
        + "            const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\n"
        + "            return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);\n"
        + "        }\n"
        + "        function emptyDocumentFragmentAt(frag) {\n"
        + "            return vnode(undefined, {}, [], undefined, frag);\n"
        + "        }\n"
        + "        function createRmCb(childElm, listeners) {\n"
        + "            return function rmCb() {\n"
        + "                if (--listeners === 0) {\n"
        + "                    const parent = api.parentNode(childElm);\n"
        + "                    api.removeChild(parent, childElm);\n"
        + "                }\n"
        + "            };\n"
        + "        }\n"
        + "        function createElm(vnode, insertedVnodeQueue) {\n"
        + "            var _a, _b, _c, _d;\n"
        + "            let i;\n"
        + "            let data = vnode.data;\n"
        + "            if (data !== undefined) {\n"
        + "                const init = (_a = data.hook) === null || _a === void 0 ? void 0 : _a.init;\n"
        + "                if (isDef(init)) {\n"
        + "                    init(vnode);\n"
        + "                    data = vnode.data;\n"
        + "                }\n"
        + "            }\n"
        + "            const children = vnode.children;\n"
        + "            const sel = vnode.sel;\n"
        + "            if (sel === \"!\") {\n"
        + "                if (isUndef(vnode.text)) {\n"
        + "                    vnode.text = \"\";\n"
        + "                }\n"
        + "                vnode.elm = api.createComment(vnode.text);\n"
        + "            }\n"
        + "            else if (sel !== undefined) {\n"
        + "                // Parse selector\n"
        + "                const hashIdx = sel.indexOf(\"#\");\n"
        + "                const dotIdx = sel.indexOf(\".\", hashIdx);\n"
        + "                const hash = hashIdx > 0 ? hashIdx : sel.length;\n"
        + "                const dot = dotIdx > 0 ? dotIdx : sel.length;\n"
        + "                const tag = hashIdx !== -1 || dotIdx !== -1\n"
        + "                    ? sel.slice(0, Math.min(hash, dot))\n"
        + "                    : sel;\n"
        + "                const elm = (vnode.elm =\n"
        + "                    isDef(data) && isDef((i = data.ns))\n"
        + "                        ? api.createElementNS(i, tag, data)\n"
        + "                        : api.createElement(tag, data));\n"
        + "                if (hash < dot)\n"
        + "                    elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\n"
        + "                if (dotIdx > 0)\n"
        + "                    elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\n"
        + "                for (i = 0; i < cbs.create.length; ++i)\n"
        + "                    cbs.create[i](emptyNode, vnode);\n"
        + "                if (array(children)) {\n"
        + "                    for (i = 0; i < children.length; ++i) {\n"
        + "                        const ch = children[i];\n"
        + "                        if (ch != null) {\n"
        + "                            api.appendChild(elm, createElm(ch, insertedVnodeQueue));\n"
        + "                        }\n"
        + "                    }\n"
        + "                }\n"
        + "                else if (primitive(vnode.text)) {\n"
        + "                    api.appendChild(elm, api.createTextNode(vnode.text));\n"
        + "                }\n"
        + "                const hook = vnode.data.hook;\n"
        + "                if (isDef(hook)) {\n"
        + "                    (_b = hook.create) === null || _b === void 0 ? void 0 : _b.call(hook, emptyNode, vnode);\n"
        + "                    if (hook.insert) {\n"
        + "                        insertedVnodeQueue.push(vnode);\n"
        + "                    }\n"
        + "                }\n"
        + "            }\n"
        + "            else if (((_c = options === null || options === void 0 ? void 0 : options.experimental) === null || _c === void 0 ? void 0 : _c.fragments) && vnode.children) {\n"
        + "                const children = vnode.children;\n"
        + "                vnode.elm = ((_d = api.createDocumentFragment) !== null && _d !== void 0 ? _d : documentFragmentIsNotSupported)();\n"
        + "                for (i = 0; i < cbs.create.length; ++i)\n"
        + "                    cbs.create[i](emptyNode, vnode);\n"
        + "                for (i = 0; i < children.length; ++i) {\n"
        + "                    const ch = children[i];\n"
        + "                    if (ch != null) {\n"
        + "                        api.appendChild(vnode.elm, createElm(ch, insertedVnodeQueue));\n"
        + "                    }\n"
        + "                }\n"
        + "            }\n"
        + "            else {\n"
        + "                vnode.elm = api.createTextNode(vnode.text);\n"
        + "            }\n"
        + "            return vnode.elm;\n"
        + "        }\n"
        + "        function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n"
        + "            for (; startIdx <= endIdx; ++startIdx) {\n"
        + "                const ch = vnodes[startIdx];\n"
        + "                if (ch != null) {\n"
        + "                    api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n"
        + "                }\n"
        + "            }\n"
        + "        }\n"
        + "        function invokeDestroyHook(vnode) {\n"
        + "            var _a, _b;\n"
        + "            const data = vnode.data;\n"
        + "            if (data !== undefined) {\n"
        + "                (_b = (_a = data === null || data === void 0 ? void 0 : data.hook) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a, vnode);\n"
        + "                for (let i = 0; i < cbs.destroy.length; ++i)\n"
        + "                    cbs.destroy[i](vnode);\n"
        + "                if (vnode.children !== undefined) {\n"
        + "                    for (let j = 0; j < vnode.children.length; ++j) {\n"
        + "                        const child = vnode.children[j];\n"
        + "                        if (child != null && typeof child !== \"string\") {\n"
        + "                            invokeDestroyHook(child);\n"
        + "                        }\n"
        + "                    }\n"
        + "                }\n"
        + "            }\n"
        + "        }\n"
        + "        function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n"
        + "            var _a, _b;\n"
        + "            for (; startIdx <= endIdx; ++startIdx) {\n"
        + "                let listeners;\n"
        + "                let rm;\n"
        + "                const ch = vnodes[startIdx];\n"
        + "                if (ch != null) {\n"
        + "                    if (isDef(ch.sel)) {\n"
        + "                        invokeDestroyHook(ch);\n"
        + "                        listeners = cbs.remove.length + 1;\n"
        + "                        rm = createRmCb(ch.elm, listeners);\n"
        + "                        for (let i = 0; i < cbs.remove.length; ++i)\n"
        + "                            cbs.remove[i](ch, rm);\n"
        + "                        const removeHook = (_b = (_a = ch === null || ch === void 0 ? void 0 : ch.data) === null || _a === void 0 ? void 0 : _a.hook) === null || _b === void 0 ? void 0 : _b.remove;\n"
        + "                        if (isDef(removeHook)) {\n"
        + "                            removeHook(ch, rm);\n"
        + "                        }\n"
        + "                        else {\n"
        + "                            rm();\n"
        + "                        }\n"
        + "                    }\n"
        + "                    else {\n"
        + "                        // Text node\n"
        + "                        api.removeChild(parentElm, ch.elm);\n"
        + "                    }\n"
        + "                }\n"
        + "            }\n"
        + "        }\n"
        + "        function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {\n"
        + "            let oldStartIdx = 0;\n"
        + "            let newStartIdx = 0;\n"
        + "            let oldEndIdx = oldCh.length - 1;\n"
        + "            let oldStartVnode = oldCh[0];\n"
        + "            let oldEndVnode = oldCh[oldEndIdx];\n"
        + "            let newEndIdx = newCh.length - 1;\n"
        + "            let newStartVnode = newCh[0];\n"
        + "            let newEndVnode = newCh[newEndIdx];\n"
        + "            let oldKeyToIdx;\n"
        + "            let idxInOld;\n"
        + "            let elmToMove;\n"
        + "            let before;\n"
        + "            while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n"
        + "                if (oldStartVnode == null) {\n"
        + "                    oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n"
        + "                }\n"
        + "                else if (oldEndVnode == null) {\n"
        + "                    oldEndVnode = oldCh[--oldEndIdx];\n"
        + "                }\n"
        + "                else if (newStartVnode == null) {\n"
        + "                    newStartVnode = newCh[++newStartIdx];\n"
        + "                }\n"
        + "                else if (newEndVnode == null) {\n"
        + "                    newEndVnode = newCh[--newEndIdx];\n"
        + "                }\n"
        + "                else if (sameVnode(oldStartVnode, newStartVnode)) {\n"
        + "                    patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n"
        + "                    oldStartVnode = oldCh[++oldStartIdx];\n"
        + "                    newStartVnode = newCh[++newStartIdx];\n"
        + "                }\n"
        + "                else if (sameVnode(oldEndVnode, newEndVnode)) {\n"
        + "                    patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n"
        + "                    oldEndVnode = oldCh[--oldEndIdx];\n"
        + "                    newEndVnode = newCh[--newEndIdx];\n"
        + "                }\n"
        + "                else if (sameVnode(oldStartVnode, newEndVnode)) {\n"
        + "                    // Vnode moved right\n"
        + "                    patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n"
        + "                    api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n"
        + "                    oldStartVnode = oldCh[++oldStartIdx];\n"
        + "                    newEndVnode = newCh[--newEndIdx];\n"
        + "                }\n"
        + "                else if (sameVnode(oldEndVnode, newStartVnode)) {\n"
        + "                    // Vnode moved left\n"
        + "                    patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n"
        + "                    api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n"
        + "                    oldEndVnode = oldCh[--oldEndIdx];\n"
        + "                    newStartVnode = newCh[++newStartIdx];\n"
        + "                }\n"
        + "                else {\n"
        + "                    if (oldKeyToIdx === undefined) {\n"
        + "                        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n"
        + "                    }\n"
        + "                    idxInOld = oldKeyToIdx[newStartVnode.key];\n"
        + "                    if (isUndef(idxInOld)) {\n"
        + "                        // New element\n"
        + "                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n"
        + "                    }\n"
        + "                    else {\n"
        + "                        elmToMove = oldCh[idxInOld];\n"
        + "                        if (elmToMove.sel !== newStartVnode.sel) {\n"
        + "                            api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n"
        + "                        }\n"
        + "                        else {\n"
        + "                            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n"
        + "                            oldCh[idxInOld] = undefined;\n"
        + "                            api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n"
        + "                        }\n"
        + "                    }\n"
        + "                    newStartVnode = newCh[++newStartIdx];\n"
        + "                }\n"
        + "            }\n"
        + "            if (newStartIdx <= newEndIdx) {\n"
        + "                before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n"
        + "                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n"
        + "            }\n"
        + "            if (oldStartIdx <= oldEndIdx) {\n"
        + "                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n"
        + "            }\n"
        + "        }\n"
        + "        function patchVnode(oldVnode, vnode, insertedVnodeQueue) {\n"
        + "            var _a, _b, _c, _d, _e;\n"
        + "            const hook = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.hook;\n"
        + "            (_b = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b === void 0 ? void 0 : _b.call(hook, oldVnode, vnode);\n"
        + "            const elm = (vnode.elm = oldVnode.elm);\n"
        + "            const oldCh = oldVnode.children;\n"
        + "            const ch = vnode.children;\n"
        + "            if (oldVnode === vnode)\n"
        + "                return;\n"
        + "            if (vnode.data !== undefined) {\n"
        + "                for (let i = 0; i < cbs.update.length; ++i)\n"
        + "                    cbs.update[i](oldVnode, vnode);\n"
        + "                (_d = (_c = vnode.data.hook) === null || _c === void 0 ? void 0 : _c.update) === null || _d === void 0 ? void 0 : _d.call(_c, oldVnode, vnode);\n"
        + "            }\n"
        + "            if (isUndef(vnode.text)) {\n"
        + "                if (isDef(oldCh) && isDef(ch)) {\n"
        + "                    if (oldCh !== ch)\n"
        + "                        updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n"
        + "                }\n"
        + "                else if (isDef(ch)) {\n"
        + "                    if (isDef(oldVnode.text))\n"
        + "                        api.setTextContent(elm, \"\");\n"
        + "                    addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n"
        + "                }\n"
        + "                else if (isDef(oldCh)) {\n"
        + "                    removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n"
        + "                }\n"
        + "                else if (isDef(oldVnode.text)) {\n"
        + "                    api.setTextContent(elm, \"\");\n"
        + "                }\n"
        + "            }\n"
        + "            else if (oldVnode.text !== vnode.text) {\n"
        + "                if (isDef(oldCh)) {\n"
        + "                    removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n"
        + "                }\n"
        + "                api.setTextContent(elm, vnode.text);\n"
        + "            }\n"
        + "            (_e = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _e === void 0 ? void 0 : _e.call(hook, oldVnode, vnode);\n"
        + "        }\n"
        + "        return function patch(oldVnode, vnode) {\n"
        + "            let i, elm, parent;\n"
        + "            const insertedVnodeQueue = [];\n"
        + "            for (i = 0; i < cbs.pre.length; ++i)\n"
        + "                cbs.pre[i]();\n"
        + "            if (isElement(api, oldVnode)) {\n"
        + "                oldVnode = emptyNodeAt(oldVnode);\n"
        + "            }\n"
        + "            else if (isDocumentFragment(api, oldVnode)) {\n"
        + "                oldVnode = emptyDocumentFragmentAt(oldVnode);\n"
        + "            }\n"
        + "            if (sameVnode(oldVnode, vnode)) {\n"
        + "                patchVnode(oldVnode, vnode, insertedVnodeQueue);\n"
        + "            }\n"
        + "            else {\n"
        + "                elm = oldVnode.elm;\n"
        + "                parent = api.parentNode(elm);\n"
        + "                createElm(vnode, insertedVnodeQueue);\n"
        + "                if (parent !== null) {\n"
        + "                    api.insertBefore(parent, vnode.elm, api.nextSibling(elm));\n"
        + "                    removeVnodes(parent, [oldVnode], 0, 0);\n"
        + "                }\n"
        + "            }\n"
        + "            for (i = 0; i < insertedVnodeQueue.length; ++i) {\n"
        + "                insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);\n"
        + "            }\n"
        + "            for (i = 0; i < cbs.post.length; ++i)\n"
        + "                cbs.post[i]();\n"
        + "            return vnode;\n"
        + "        };\n"
        + "    }\n"
        + "\n"
        + "    function addNS(data, children, sel) {\n"
        + "        data.ns = \"http://www.w3.org/2000/svg\";\n"
        + "        if (sel !== \"foreignObject\" && children !== undefined) {\n"
        + "            for (let i = 0; i < children.length; ++i) {\n"
        + "                const child = children[i];\n"
        + "                if (typeof child === \"string\")\n"
        + "                    continue;\n"
        + "                const childData = child.data;\n"
        + "                if (childData !== undefined) {\n"
        + "                    addNS(childData, child.children, child.sel);\n"
        + "                }\n"
        + "            }\n"
        + "        }\n"
        + "    }\n"
        + "    function h(sel, b, c) {\n"
        + "        let data = {};\n"
        + "        let children;\n"
        + "        let text;\n"
        + "        let i;\n"
        + "        if (c !== undefined) {\n"
        + "            if (b !== null) {\n"
        + "                data = b;\n"
        + "            }\n"
        + "            if (array(c)) {\n"
        + "                children = c;\n"
        + "            }\n"
        + "            else if (primitive(c)) {\n"
        + "                text = c.toString();\n"
        + "            }\n"
        + "            else if (c && c.sel) {\n"
        + "                children = [c];\n"
        + "            }\n"
        + "        }\n"
        + "        else if (b !== undefined && b !== null) {\n"
        + "            if (array(b)) {\n"
        + "                children = b;\n"
        + "            }\n"
        + "            else if (primitive(b)) {\n"
        + "                text = b.toString();\n"
        + "            }\n"
        + "            else if (b && b.sel) {\n"
        + "                children = [b];\n"
        + "            }\n"
        + "            else {\n"
        + "                data = b;\n"
        + "            }\n"
        + "        }\n"
        + "        if (children !== undefined) {\n"
        + "            for (i = 0; i < children.length; ++i) {\n"
        + "                if (primitive(children[i]))\n"
        + "                    children[i] = vnode(undefined, undefined, undefined, children[i], undefined);\n"
        + "            }\n"
        + "        }\n"
        + "        if (sel[0] === \"s\" &&\n"
        + "            sel[1] === \"v\" &&\n"
        + "            sel[2] === \"g\" &&\n"
        + "            (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")) {\n"
        + "            addNS(data, children, sel);\n"
        + "        }\n"
        + "        return vnode(sel, data, children, text, undefined);\n"
        + "    }\n"
        + "    /**\n"
        + "     * @experimental\n"
        + "     */\n"
        + "    function fragment(children) {\n"
        + "        let c;\n"
        + "        let text;\n"
        + "        if (array(children)) {\n"
        + "            c = children;\n"
        + "        }\n"
        + "        else if (primitive(c)) {\n"
        + "            text = children;\n"
        + "        }\n"
        + "        else if (c && c.sel) {\n"
        + "            c = [children];\n"
        + "        }\n"
        + "        if (c !== undefined) {\n"
        + "            for (let i = 0; i < c.length; ++i) {\n"
        + "                if (primitive(c[i]))\n"
        + "                    c[i] = vnode(undefined, undefined, undefined, c[i], undefined);\n"
        + "            }\n"
        + "        }\n"
        + "        return vnode(undefined, {}, c, text, undefined);\n"
        + "    }\n"
        + "\n"
        + "    function copyToThunk(vnode, thunk) {\n"
        + "        var _a;\n"
        + "        const ns = (_a = thunk.data) === null || _a === void 0 ? void 0 : _a.ns;\n"
        + "        vnode.data.fn = thunk.data.fn;\n"
        + "        vnode.data.args = thunk.data.args;\n"
        + "        thunk.data = vnode.data;\n"
        + "        thunk.children = vnode.children;\n"
        + "        thunk.text = vnode.text;\n"
        + "        thunk.elm = vnode.elm;\n"
        + "        if (ns)\n"
        + "            addNS(thunk.data, thunk.children, thunk.sel);\n"
        + "    }\n"
        + "    function init(thunk) {\n"
        + "        const cur = thunk.data;\n"
        + "        const vnode = cur.fn(...cur.args);\n"
        + "        copyToThunk(vnode, thunk);\n"
        + "    }\n"
        + "    function prepatch(oldVnode, thunk) {\n"
        + "        let i;\n"
        + "        const old = oldVnode.data;\n"
        + "        const cur = thunk.data;\n"
        + "        const oldArgs = old.args;\n"
        + "        const args = cur.args;\n"
        + "        if (old.fn !== cur.fn || oldArgs.length !== args.length) {\n"
        + "            copyToThunk(cur.fn(...args), thunk);\n"
        + "            return;\n"
        + "        }\n"
        + "        for (i = 0; i < args.length; ++i) {\n"
        + "            if (oldArgs[i] !== args[i]) {\n"
        + "                copyToThunk(cur.fn(...args), thunk);\n"
        + "                return;\n"
        + "            }\n"
        + "        }\n"
        + "        copyToThunk(oldVnode, thunk);\n"
        + "    }\n"
        + "    const thunk = function thunk(sel, key, fn, args) {\n"
        + "        if (args === undefined) {\n"
        + "            args = fn;\n"
        + "            fn = key;\n"
        + "            key = undefined;\n"
        + "        }\n"
        + "        return h(sel, {\n"
        + "            key: key,\n"
        + "            hook: { init, prepatch },\n"
        + "            fn: fn,\n"
        + "            args: args,\n"
        + "        });\n"
        + "    };\n"
        + "\n"
        + "    function pre(vnode, newVnode) {\n"
        + "        const attachData = vnode.data.attachData;\n"
        + "        // Copy created placeholder and real element from old vnode\n"
        + "        newVnode.data.attachData.placeholder = attachData.placeholder;\n"
        + "        newVnode.data.attachData.real = attachData.real;\n"
        + "        // Mount real element in vnode so the patch process operates on it\n"
        + "        vnode.elm = vnode.data.attachData.real;\n"
        + "    }\n"
        + "    function post(_, vnode) {\n"
        + "        // Mount dummy placeholder in vnode so potential reorders use it\n"
        + "        vnode.elm = vnode.data.attachData.placeholder;\n"
        + "    }\n"
        + "    function destroy(vnode) {\n"
        + "        // Remove placeholder\n"
        + "        if (vnode.elm !== undefined) {\n"
        + "            vnode.elm.parentNode.removeChild(vnode.elm);\n"
        + "        }\n"
        + "        // Remove real element from where it was inserted\n"
        + "        vnode.elm = vnode.data.attachData.real;\n"
        + "    }\n"
        + "    function create(_, vnode) {\n"
        + "        const real = vnode.elm;\n"
        + "        const attachData = vnode.data.attachData;\n"
        + "        const placeholder = document.createElement(\"span\");\n"
        + "        // Replace actual element with dummy placeholder\n"
        + "        // Snabbdom will then insert placeholder instead\n"
        + "        vnode.elm = placeholder;\n"
        + "        attachData.target.appendChild(real);\n"
        + "        attachData.real = real;\n"
        + "        attachData.placeholder = placeholder;\n"
        + "    }\n"
        + "    function attachTo(target, vnode) {\n"
        + "        if (vnode.data === undefined)\n"
        + "            vnode.data = {};\n"
        + "        if (vnode.data.hook === undefined)\n"
        + "            vnode.data.hook = {};\n"
        + "        const data = vnode.data;\n"
        + "        const hook = vnode.data.hook;\n"
        + "        data.attachData = { target: target, placeholder: undefined, real: undefined };\n"
        + "        hook.create = create;\n"
        + "        hook.prepatch = pre;\n"
        + "        hook.postpatch = post;\n"
        + "        hook.destroy = destroy;\n"
        + "        return vnode;\n"
        + "    }\n"
        + "\n"
        + "    function toVNode(node, domApi) {\n"
        + "        const api = domApi !== undefined ? domApi : htmlDomApi;\n"
        + "        let text;\n"
        + "        if (api.isElement(node)) {\n"
        + "            const id = node.id ? \"#\" + node.id : \"\";\n"
        + "            const cn = node.getAttribute(\"class\");\n"
        + "            const c = cn ? \".\" + cn.split(\" \").join(\".\") : \"\";\n"
        + "            const sel = api.tagName(node).toLowerCase() + id + c;\n"
        + "            const attrs = {};\n"
        + "            const children = [];\n"
        + "            let name;\n"
        + "            let i, n;\n"
        + "            const elmAttrs = node.attributes;\n"
        + "            const elmChildren = node.childNodes;\n"
        + "            for (i = 0, n = elmAttrs.length; i < n; i++) {\n"
        + "                name = elmAttrs[i].nodeName;\n"
        + "                if (name !== \"id\" && name !== \"class\") {\n"
        + "                    attrs[name] = elmAttrs[i].nodeValue;\n"
        + "                }\n"
        + "            }\n"
        + "            for (i = 0, n = elmChildren.length; i < n; i++) {\n"
        + "                children.push(toVNode(elmChildren[i], domApi));\n"
        + "            }\n"
        + "            const data = { attrs };\n"
        + "            if (sel[0] === \"s\" &&\n"
        + "                sel[1] === \"v\" &&\n"
        + "                sel[2] === \"g\" &&\n"
        + "                (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")) {\n"
        + "                addNS(data, children, sel);\n"
        + "            }\n"
        + "            return vnode(sel, data, children, undefined, node);\n"
        + "        }\n"
        + "        else if (api.isText(node)) {\n"
        + "            text = api.getTextContent(node);\n"
        + "            return vnode(undefined, undefined, undefined, text, node);\n"
        + "        }\n"
        + "        else if (api.isComment(node)) {\n"
        + "            text = api.getTextContent(node);\n"
        + "            return vnode(\"!\", {}, [], text, node);\n"
        + "        }\n"
        + "        else {\n"
        + "            return vnode(\"\", {}, [], undefined, node);\n"
        + "        }\n"
        + "    }\n"
        + "\n"
        + "    const xlinkNS = \"http://www.w3.org/1999/xlink\";\n"
        + "    const xmlNS = \"http://www.w3.org/XML/1998/namespace\";\n"
        + "    const colonChar = 58;\n"
        + "    const xChar = 120;\n"
        + "    function updateAttrs(oldVnode, vnode) {\n"
        + "        let key;\n"
        + "        const elm = vnode.elm;\n"
        + "        let oldAttrs = oldVnode.data.attrs;\n"
        + "        let attrs = vnode.data.attrs;\n"
        + "        if (!oldAttrs && !attrs)\n"
        + "            return;\n"
        + "        if (oldAttrs === attrs)\n"
        + "            return;\n"
        + "        oldAttrs = oldAttrs || {};\n"
        + "        attrs = attrs || {};\n"
        + "        // update modified attributes, add new attributes\n"
        + "        for (key in attrs) {\n"
        + "            const cur = attrs[key];\n"
        + "            const old = oldAttrs[key];\n"
        + "            if (old !== cur) {\n"
        + "                if (cur === true) {\n"
        + "                    elm.setAttribute(key, \"\");\n"
        + "                }\n"
        + "                else if (cur === false) {\n"
        + "                    elm.removeAttribute(key);\n"
        + "                }\n"
        + "                else {\n"
        + "                    if (key.charCodeAt(0) !== xChar) {\n"
        + "                        elm.setAttribute(key, cur);\n"
        + "                    }\n"
        + "                    else if (key.charCodeAt(3) === colonChar) {\n"
        + "                        // Assume xml namespace\n"
        + "                        elm.setAttributeNS(xmlNS, key, cur);\n"
        + "                    }\n"
        + "                    else if (key.charCodeAt(5) === colonChar) {\n"
        + "                        // Assume xlink namespace\n"
        + "                        elm.setAttributeNS(xlinkNS, key, cur);\n"
        + "                    }\n"
        + "                    else {\n"
        + "                        elm.setAttribute(key, cur);\n"
        + "                    }\n"
        + "                }\n"
        + "            }\n"
        + "        }\n"
        + "        // remove removed attributes\n"
        + "        // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)\n"
        + "        // the other option is to remove all attributes with value == undefined\n"
        + "        for (key in oldAttrs) {\n"
        + "            if (!(key in attrs)) {\n"
        + "                elm.removeAttribute(key);\n"
        + "            }\n"
        + "        }\n"
        + "    }\n"
        + "    const attributesModule = {\n"
        + "        create: updateAttrs,\n"
        + "        update: updateAttrs,\n"
        + "    };\n"
        + "\n"
        + "    function updateClass(oldVnode, vnode) {\n"
        + "        let cur;\n"
        + "        let name;\n"
        + "        const elm = vnode.elm;\n"
        + "        let oldClass = oldVnode.data.class;\n"
        + "        let klass = vnode.data.class;\n"
        + "        if (!oldClass && !klass)\n"
        + "            return;\n"
        + "        if (oldClass === klass)\n"
        + "            return;\n"
        + "        oldClass = oldClass || {};\n"
        + "        klass = klass || {};\n"
        + "        for (name in oldClass) {\n"
        + "            if (oldClass[name] && !Object.prototype.hasOwnProperty.call(klass, name)) {\n"
        + "                // was `true` and now not provided\n"
        + "                elm.classList.remove(name);\n"
        + "            }\n"
        + "        }\n"
        + "        for (name in klass) {\n"
        + "            cur = klass[name];\n"
        + "            if (cur !== oldClass[name]) {\n"
        + "                elm.classList[cur ? \"add\" : \"remove\"](name);\n"
        + "            }\n"
        + "        }\n"
        + "    }\n"
        + "    const classModule = { create: updateClass, update: updateClass };\n"
        + "\n"
        + "    const CAPS_REGEX = /[A-Z]/g;\n"
        + "    function updateDataset(oldVnode, vnode) {\n"
        + "        const elm = vnode.elm;\n"
        + "        let oldDataset = oldVnode.data.dataset;\n"
        + "        let dataset = vnode.data.dataset;\n"
        + "        let key;\n"
        + "        if (!oldDataset && !dataset)\n"
        + "            return;\n"
        + "        if (oldDataset === dataset)\n"
        + "            return;\n"
        + "        oldDataset = oldDataset || {};\n"
        + "        dataset = dataset || {};\n"
        + "        const d = elm.dataset;\n"
        + "        for (key in oldDataset) {\n"
        + "            if (!dataset[key]) {\n"
        + "                if (d) {\n"
        + "                    if (key in d) {\n"
        + "                        delete d[key];\n"
        + "                    }\n"
        + "                }\n"
        + "                else {\n"
        + "                    elm.removeAttribute(\"data-\" + key.replace(CAPS_REGEX, \"-$&\").toLowerCase());\n"
        + "                }\n"
        + "            }\n"
        + "        }\n"
        + "        for (key in dataset) {\n"
        + "            if (oldDataset[key] !== dataset[key]) {\n"
        + "                if (d) {\n"
        + "                    d[key] = dataset[key];\n"
        + "                }\n"
        + "                else {\n"
        + "                    elm.setAttribute(\"data-\" + key.replace(CAPS_REGEX, \"-$&\").toLowerCase(), dataset[key]);\n"
        + "                }\n"
        + "            }\n"
        + "        }\n"
        + "    }\n"
        + "    const datasetModule = {\n"
        + "        create: updateDataset,\n"
        + "        update: updateDataset,\n"
        + "    };\n"
        + "\n"
        + "    function invokeHandler(handler, vnode, event) {\n"
        + "        if (typeof handler === \"function\") {\n"
        + "            // call function handler\n"
        + "            handler.call(vnode, event, vnode);\n"
        + "        }\n"
        + "        else if (typeof handler === \"object\") {\n"
        + "            // call multiple handlers\n"
        + "            for (let i = 0; i < handler.length; i++) {\n"
        + "                invokeHandler(handler[i], vnode, event);\n"
        + "            }\n"
        + "        }\n"
        + "    }\n"
        + "    function handleEvent(event, vnode) {\n"
        + "        const name = event.type;\n"
        + "        const on = vnode.data.on;\n"
        + "        // call event handler(s) if exists\n"
        + "        if (on && on[name]) {\n"
        + "            invokeHandler(on[name], vnode, event);\n"
        + "        }\n"
        + "    }\n"
        + "    function createListener() {\n"
        + "        return function handler(event) {\n"
        + "            handleEvent(event, handler.vnode);\n"
        + "        };\n"
        + "    }\n"
        + "    function updateEventListeners(oldVnode, vnode) {\n"
        + "        const oldOn = oldVnode.data.on;\n"
        + "        const oldListener = oldVnode.listener;\n"
        + "        const oldElm = oldVnode.elm;\n"
        + "        const on = vnode && vnode.data.on;\n"
        + "        const elm = (vnode && vnode.elm);\n"
        + "        let name;\n"
        + "        // optimization for reused immutable handlers\n"
        + "        if (oldOn === on) {\n"
        + "            return;\n"
        + "        }\n"
        + "        // remove existing listeners which no longer used\n"
        + "        if (oldOn && oldListener) {\n"
        + "            // if element changed or deleted we remove all existing listeners unconditionally\n"
        + "            if (!on) {\n"
        + "                for (name in oldOn) {\n"
        + "                    // remove listener if element was changed or existing listeners removed\n"
        + "                    oldElm.removeEventListener(name, oldListener, false);\n"
        + "                }\n"
        + "            }\n"
        + "            else {\n"
        + "                for (name in oldOn) {\n"
        + "                    // remove listener if existing listener removed\n"
        + "                    if (!on[name]) {\n"
        + "                        oldElm.removeEventListener(name, oldListener, false);\n"
        + "                    }\n"
        + "                }\n"
        + "            }\n"
        + "        }\n"
        + "        // add new listeners which has not already attached\n"
        + "        if (on) {\n"
        + "            // reuse existing listener or create new\n"
        + "            const listener = (vnode.listener =\n"
        + "                oldVnode.listener || createListener());\n"
        + "            // update vnode for listener\n"
        + "            listener.vnode = vnode;\n"
        + "            // if element changed or added we add all needed listeners unconditionally\n"
        + "            if (!oldOn) {\n"
        + "                for (name in on) {\n"
        + "                    // add listener if element was changed or new listeners added\n"
        + "                    elm.addEventListener(name, listener, false);\n"
        + "                }\n"
        + "            }\n"
        + "            else {\n"
        + "                for (name in on) {\n"
        + "                    // add listener if new listener added\n"
        + "                    if (!oldOn[name]) {\n"
        + "                        elm.addEventListener(name, listener, false);\n"
        + "                    }\n"
        + "                }\n"
        + "            }\n"
        + "        }\n"
        + "    }\n"
        + "    const eventListenersModule = {\n"
        + "        create: updateEventListeners,\n"
        + "        update: updateEventListeners,\n"
        + "        destroy: updateEventListeners,\n"
        + "    };\n"
        + "\n"
        + "    function updateProps(oldVnode, vnode) {\n"
        + "        let key;\n"
        + "        let cur;\n"
        + "        let old;\n"
        + "        const elm = vnode.elm;\n"
        + "        let oldProps = oldVnode.data.props;\n"
        + "        let props = vnode.data.props;\n"
        + "        if (!oldProps && !props)\n"
        + "            return;\n"
        + "        if (oldProps === props)\n"
        + "            return;\n"
        + "        oldProps = oldProps || {};\n"
        + "        props = props || {};\n"
        + "        for (key in props) {\n"
        + "            cur = props[key];\n"
        + "            old = oldProps[key];\n"
        + "            if (old !== cur && (key !== \"value\" || elm[key] !== cur)) {\n"
        + "                elm[key] = cur;\n"
        + "            }\n"
        + "        }\n"
        + "    }\n"
        + "    const propsModule = { create: updateProps, update: updateProps };\n"
        + "\n"
        + "    // Bindig `requestAnimationFrame` like this fixes a bug in IE/Edge. See #360 and #409.\n"
        + "    const raf = (typeof window !== \"undefined\" &&\n"
        + "        window.requestAnimationFrame.bind(window)) ||\n"
        + "        setTimeout;\n"
        + "    const nextFrame = function (fn) {\n"
        + "        raf(function () {\n"
        + "            raf(fn);\n"
        + "        });\n"
        + "    };\n"
        + "    let reflowForced = false;\n"
        + "    function setNextFrame(obj, prop, val) {\n"
        + "        nextFrame(function () {\n"
        + "            obj[prop] = val;\n"
        + "        });\n"
        + "    }\n"
        + "    function updateStyle(oldVnode, vnode) {\n"
        + "        let cur;\n"
        + "        let name;\n"
        + "        const elm = vnode.elm;\n"
        + "        let oldStyle = oldVnode.data.style;\n"
        + "        let style = vnode.data.style;\n"
        + "        if (!oldStyle && !style)\n"
        + "            return;\n"
        + "        if (oldStyle === style)\n"
        + "            return;\n"
        + "        oldStyle = oldStyle || {};\n"
        + "        style = style || {};\n"
        + "        const oldHasDel = \"delayed\" in oldStyle;\n"
        + "        for (name in oldStyle) {\n"
        + "            if (!style[name]) {\n"
        + "                if (name[0] === \"-\" && name[1] === \"-\") {\n"
        + "                    elm.style.removeProperty(name);\n"
        + "                }\n"
        + "                else {\n"
        + "                    elm.style[name] = \"\";\n"
        + "                }\n"
        + "            }\n"
        + "        }\n"
        + "        for (name in style) {\n"
        + "            cur = style[name];\n"
        + "            if (name === \"delayed\" && style.delayed) {\n"
        + "                for (const name2 in style.delayed) {\n"
        + "                    cur = style.delayed[name2];\n"
        + "                    if (!oldHasDel || cur !== oldStyle.delayed[name2]) {\n"
        + "                        setNextFrame(elm.style, name2, cur);\n"
        + "                    }\n"
        + "                }\n"
        + "            }\n"
        + "            else if (name !== \"remove\" && cur !== oldStyle[name]) {\n"
        + "                if (name[0] === \"-\" && name[1] === \"-\") {\n"
        + "                    elm.style.setProperty(name, cur);\n"
        + "                }\n"
        + "                else {\n"
        + "                    elm.style[name] = cur;\n"
        + "                }\n"
        + "            }\n"
        + "        }\n"
        + "    }\n"
        + "    function applyDestroyStyle(vnode) {\n"
        + "        let style;\n"
        + "        let name;\n"
        + "        const elm = vnode.elm;\n"
        + "        const s = vnode.data.style;\n"
        + "        if (!s || !(style = s.destroy))\n"
        + "            return;\n"
        + "        for (name in style) {\n"
        + "            elm.style[name] = style[name];\n"
        + "        }\n"
        + "    }\n"
        + "    function applyRemoveStyle(vnode, rm) {\n"
        + "        const s = vnode.data.style;\n"
        + "        if (!s || !s.remove) {\n"
        + "            rm();\n"
        + "            return;\n"
        + "        }\n"
        + "        if (!reflowForced) {\n"
        + "            // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n"
        + "            vnode.elm.offsetLeft;\n"
        + "            reflowForced = true;\n"
        + "        }\n"
        + "        let name;\n"
        + "        const elm = vnode.elm;\n"
        + "        let i = 0;\n"
        + "        const style = s.remove;\n"
        + "        let amount = 0;\n"
        + "        const applied = [];\n"
        + "        for (name in style) {\n"
        + "            applied.push(name);\n"
        + "            elm.style[name] = style[name];\n"
        + "        }\n"
        + "        const compStyle = getComputedStyle(elm);\n"
        + "        const props = compStyle[\"transition-property\"].split(\", \");\n"
        + "        for (; i < props.length; ++i) {\n"
        + "            if (applied.indexOf(props[i]) !== -1)\n"
        + "                amount++;\n"
        + "        }\n"
        + "        elm.addEventListener(\"transitionend\", function (ev) {\n"
        + "            if (ev.target === elm)\n"
        + "                --amount;\n"
        + "            if (amount === 0)\n"
        + "                rm();\n"
        + "        });\n"
        + "    }\n"
        + "    function forceReflow() {\n"
        + "        reflowForced = false;\n"
        + "    }\n"
        + "    const styleModule = {\n"
        + "        pre: forceReflow,\n"
        + "        create: updateStyle,\n"
        + "        update: updateStyle,\n"
        + "        destroy: applyDestroyStyle,\n"
        + "        remove: applyRemoveStyle,\n"
        + "    };\n"
        + "\n"
        + "    /* eslint-disable @typescript-eslint/no-namespace, import/export */\n"
        + "    function Fragment(data, ...children) {\n"
        + "        const flatChildren = flattenAndFilter(children, []);\n"
        + "        if (flatChildren.length === 1 &&\n"
        + "            !flatChildren[0].sel &&\n"
        + "            flatChildren[0].text) {\n"
        + "            // only child is a simple text node, pass as text for a simpler vtree\n"
        + "            return vnode(undefined, undefined, undefined, flatChildren[0].text, undefined);\n"
        + "        }\n"
        + "        else {\n"
        + "            return vnode(undefined, data !== null && data !== void 0 ? data : {}, flatChildren, undefined, undefined);\n"
        + "        }\n"
        + "    }\n"
        + "    function flattenAndFilter(children, flattened) {\n"
        + "        for (const child of children) {\n"
        + "            // filter out falsey children, except 0 since zero can be a valid value e.g inside a chart\n"
        + "            if (child !== undefined &&\n"
        + "                child !== null &&\n"
        + "                child !== false &&\n"
        + "                child !== \"\") {\n"
        + "                if (Array.isArray(child)) {\n"
        + "                    flattenAndFilter(child, flattened);\n"
        + "                }\n"
        + "                else if (typeof child === \"string\" ||\n"
        + "                    typeof child === \"number\" ||\n"
        + "                    typeof child === \"boolean\") {\n"
        + "                    flattened.push(vnode(undefined, undefined, undefined, String(child), undefined));\n"
        + "                }\n"
        + "                else {\n"
        + "                    flattened.push(child);\n"
        + "                }\n"
        + "            }\n"
        + "        }\n"
        + "        return flattened;\n"
        + "    }\n"
        + "    /**\n"
        + "     * jsx/tsx compatible factory function\n"
        + "     * see: https://www.typescriptlang.org/docs/handbook/jsx.html#factory-functions\n"
        + "     */\n"
        + "    function jsx(tag, data, ...children) {\n"
        + "        const flatChildren = flattenAndFilter(children, []);\n"
        + "        if (typeof tag === \"function\") {\n"
        + "            // tag is a function component\n"
        + "            return tag(data, flatChildren);\n"
        + "        }\n"
        + "        else {\n"
        + "            if (flatChildren.length === 1 &&\n"
        + "                !flatChildren[0].sel &&\n"
        + "                flatChildren[0].text) {\n"
        + "                // only child is a simple text node, pass as text for a simpler vtree\n"
        + "                return h(tag, data, flatChildren[0].text);\n"
        + "            }\n"
        + "            else {\n"
        + "                return h(tag, data, flatChildren);\n"
        + "            }\n"
        + "        }\n"
        + "    }\n"
        + "    (function (jsx) {\n"
        + "    })(jsx || (jsx = {}));\n"
        + "\n"
        + "    exports.Fragment = Fragment;\n"
        + "    exports.array = array;\n"
        + "    exports.attachTo = attachTo;\n"
        + "    exports.attributesModule = attributesModule;\n"
        + "    exports.classModule = classModule;\n"
        + "    exports.datasetModule = datasetModule;\n"
        + "    exports.eventListenersModule = eventListenersModule;\n"
        + "    exports.fragment = fragment;\n"
        + "    exports.h = h;\n"
        + "    exports.htmlDomApi = htmlDomApi;\n"
        + "    exports.init = init$1;\n"
        + "    exports.jsx = jsx;\n"
        + "    exports.primitive = primitive;\n"
        + "    exports.propsModule = propsModule;\n"
        + "    exports.styleModule = styleModule;\n"
        + "    exports.thunk = thunk;\n"
        + "    exports.toVNode = toVNode;\n"
        + "    exports.vnode = vnode;\n"
        + "\n"
        + "    Object.defineProperty(exports, '__esModule', { value: true });\n"
        + "\n"
        + "}));\n";
  }

  public static String FormHtml() {
    return "<html lang=en>\n"
        + "    <head>\n"
        + "        <meta charset=\"utf-8\" />\n"
        + "        <title>GTFS Validator</title>\n"
        + "        <link rel=\"stylesheet\" href=\"index.css\" type=\"text/css\" />\n"
        + "    </head>\n"
        + "    <body>\n"
        + "        <h1>GTFS Validator</h1>\n"
        + "        <form class=\"table-like\" method=post action=\"./validate\" enctype=\"multipart/form-data\">\n"
        + "            <div> \n"
        + "                <p>Robot test. Please name a mass transit vehicle type, i.e. not a car.</p>\n"
        + "                <div class=\"row-like\">\n"
        + "                    <label for=\"vehicle\">Mass transit vehicle:</label>\n"
        + "                    <input name=vehicle id=vehicle type=text></input>\n"
        + "                </div>\n"
        + "                <div class=\"row-like\">\n"
        + "                    <label for=\"file\">GTFS ZIP file:</label>\n"
        + "                    <input name=file id=file type=file></input>\n"
        + "                </div>\n"
        + "            </div>\n"
        + "            <button type=submit>Validate</button>\n"
        + "        </form>\n"
        + "    </body>\n"
        + "</html>\n";
  }
}
