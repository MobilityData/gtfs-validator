package org.mobilitydata.gtfsvalidator.outputcomparator.cli;

import com.google.auto.value.AutoValue;
import com.google.common.flogger.FluentLogger;
import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.util.List;
import org.mobilitydata.gtfsvalidator.model.ValidationReport;
import org.mobilitydata.gtfsvalidator.notice.SeverityLevel;
import org.mobilitydata.gtfsvalidator.outputcomparator.io.ChangedNoticesCollector;
import org.mobilitydata.gtfsvalidator.outputcomparator.io.CorruptedSourcesCollector;
import org.mobilitydata.gtfsvalidator.outputcomparator.io.ValidationPerformanceCollector;
import org.mobilitydata.gtfsvalidator.outputcomparator.model.SourceUrlContainer;
import org.mobilitydata.gtfsvalidator.outputcomparator.model.report.AcceptanceReport;

/**
 * Compares a collection of validation reports generated by two instances of the validator to,
 * generating an {@link AcceptanceReport} describing the changes in notices between the two
 * instance, a summary string of the changes, and a failure indicator if the number of changes is
 * beyond a specified threshold.
 */
public class ValidationReportComparator {

  private static final FluentLogger logger = FluentLogger.forEnclosingClass();

  /**
   * Compare validation reports for the same set of feeds between two different instance of the
   * validator.
   *
   * @param args additional args that control the comparator
   * @param reportDirs a collection of directories, each containing a `reference` and `latest`
   *     validation report
   * @param sourceUrlContainer
   * @return
   */
  public Result compareValidationRuns(
      Arguments args, List<File> reportDirs, SourceUrlContainer sourceUrlContainer) {
    ChangedNoticesCollector newErrors =
        new ChangedNoticesCollector(
            SeverityLevel.ERROR,
            args.getNewErrorThreshold(),
            args.getPercentInvalidDatasetsThreshold());
    ChangedNoticesCollector droppedErrors =
        new ChangedNoticesCollector(
            SeverityLevel.ERROR,
            args.getNewErrorThreshold(),
            args.getPercentInvalidDatasetsThreshold());
    ChangedNoticesCollector newWarnings =
        new ChangedNoticesCollector(
            SeverityLevel.WARNING,
            args.getNewErrorThreshold(),
            args.getPercentInvalidDatasetsThreshold());
    ChangedNoticesCollector droppedWarnings =
        new ChangedNoticesCollector(
            SeverityLevel.WARNING,
            args.getNewErrorThreshold(),
            args.getPercentInvalidDatasetsThreshold());
    CorruptedSourcesCollector corruptedSources =
        new CorruptedSourcesCollector(args.getPercentCorruptedSourcesThreshold());
    ValidationPerformanceCollector validationPerformanceCollector =
        new ValidationPerformanceCollector();

    for (File file : reportDirs) {
      String sourceId = file.getName();
      // check if file.getName is sourceId aka check that we do not iterate over a directory created
      // by github
      if (!sourceUrlContainer.hasSourceId(sourceId)) {
        continue;
      }
      corruptedSources.addSource();
      String sourceUrl = sourceUrlContainer.getUrlForSourceId(sourceId);

      Path referenceReportPath = file.toPath().resolve(args.getReferenceValidationReportName());
      Path latestReportPath = file.toPath().resolve(args.getLatestValidationReportName());
      // in case a validation report does not exist for a sourceId we add the sourceId to
      // the list of corrupted sources
      if (!(referenceReportPath.toFile().exists() && latestReportPath.toFile().exists())) {
        corruptedSources.addCorruptedSource(
            sourceId,
            referenceReportPath.toFile().exists(),
            null,
            latestReportPath.toFile().exists(),
            null);
        continue;
      }
      ValidationReport referenceReport;
      ValidationReport latestReport;
      try {
        referenceReport = ValidationReport.fromPath(referenceReportPath);
      } catch (IOException ioException) {
        logger.atSevere().withCause(ioException).log("Error reading reference validation report");
        // in case a file is corrupted, add the sourceId to the list of corrupted sources
        corruptedSources.addCorruptedSource(sourceId, true, false, true, null);
        continue;
      }
      try {
        latestReport = ValidationReport.fromPath(latestReportPath);
      } catch (IOException ioException) {
        logger.atSevere().withCause(ioException).log("Error reading latest validation report");
        // in case a file is corrupted, add the sourceId to the list of corrupted sources
        corruptedSources.addCorruptedSource(sourceId, true, true, true, false);
        continue;
      }
      newErrors.compareValidationReports(sourceId, sourceUrl, referenceReport, latestReport);
      droppedErrors.compareValidationReports(sourceId, sourceUrl, latestReport, referenceReport);
      newWarnings.compareValidationReports(sourceId, sourceUrl, referenceReport, latestReport);
      droppedWarnings.compareValidationReports(sourceId, sourceUrl, latestReport, referenceReport);
      validationPerformanceCollector.compareValidationReports(
          sourceId, referenceReport, latestReport);
    }

    AcceptanceReport report =
        AcceptanceReport.create(
            newErrors.getChangedNotices(),
            droppedErrors.getChangedNotices(),
            newWarnings.getChangedNotices(),
            droppedWarnings.getChangedNotices(),
            corruptedSources.toReport(),
            validationPerformanceCollector.toReport());

    boolean failure =
        newErrors.isAboveThreshold()
            || droppedErrors.isAboveThreshold()
            || newWarnings.isAboveThreshold()
            || droppedWarnings.isAboveThreshold()
            || corruptedSources.isAboveThreshold();

    String reportSummaryString =
        generateReportSummaryString(
            failure,
            newErrors,
            droppedErrors,
            newWarnings,
            droppedWarnings,
            corruptedSources,
            validationPerformanceCollector,
            args);

    return Result.create(report, reportSummaryString, failure);
  }

  @AutoValue
  abstract static class Result {

    // A report documenting the changes in notices between the two validator runs.
    abstract AcceptanceReport report();

    // A human-readable summary string of the changes between the two validator runs.
    abstract String reportSummary();

    // True if the changes in notices between the two validator runs is above a specified threshold.
    abstract boolean failure();

    public static Result create(AcceptanceReport report, String reportSummary, boolean failure) {
      return new AutoValue_ValidationReportComparator_Result(report, reportSummary, failure);
    }
  }

  /**
   * Generates a textual string summary of the acceptance report, approprirate for display to a
   * user.
   */
  private static String generateReportSummaryString(
      boolean failure,
      ChangedNoticesCollector newErrors,
      ChangedNoticesCollector droppedErrors,
      ChangedNoticesCollector newWarnings,
      ChangedNoticesCollector droppedWarnings,
      CorruptedSourcesCollector corruptedSources,
      ValidationPerformanceCollector validationPerformanceCollector,
      Arguments args) {
    StringBuilder b = new StringBuilder();
    b.append("## \uD83D\uDCDD Acceptance Test Report\n");
    b.append("### \uD83D\uDCCB Summary\n");
    String status =
        failure ? "❌ The rule acceptance test has failed" : "✅ The rule acceptance has passed";
    b.append(status);
    if (args.getCommitSha().isPresent()) {
      b.append(" for commit ").append(args.getCommitSha().get()).append('\n');
    } else {
      b.append(".\n");
    }
    if (args.getRunId().isPresent()) {
      b.append(
          String.format(
              "Download the full acceptance test report [here](%s/%s) (report will disappear after 90 days).\n",
              "https://github.com/MobilityData/gtfs-validator/actions/runs",
              args.getRunId().get()));
    }

    b.append("### \uD83D\uDCCA Notices Comparison\n");
    b.append(newErrors.generateLogString("New Errors")).append('\n');
    b.append(droppedErrors.generateLogString("Dropped Errors")).append('\n');
    b.append(newWarnings.generateLogString("New Warnings")).append('\n');
    b.append(droppedWarnings.generateLogString("Dropped Warnings")).append("\n\n");
    b.append(corruptedSources.generateLogString()).append("\n").append("\n");
    b.append(validationPerformanceCollector.generateLogString()).append("\n");
    return b.toString();
  }
}
